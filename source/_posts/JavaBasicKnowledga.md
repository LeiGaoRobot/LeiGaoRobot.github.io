---
title: Java 基础知识
date: 2019-02-01 20:42:21
categories: java
tags: java
---

# 面向对象和面向过程

## 面向过程

+ **优点** ： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
+ **缺点** ： 没有面向对象易维护、易复用、易扩展

## 面向对象

+ **优点** ： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
+ **缺点** ： 性能比面向过程低

---

# Java语言特点

## 简单易学(Simple)

Java非常容易学习，其语法简单，干净且易于理解。根据Sun的说法，Java语言是一种简单的编程语言，因为：

+ Java语法基于 C++（程序员在 C++ 之后学习它更容易）。
+ Java已经删除了许多复杂且很少使用的功能，例如，显式指针，运算符重载等。
+ 由于Java中存在自动垃圾收集，因此无需删除未引用的对象。

## 面向对象(Object-oriented)

Java是一种面向对象的编程语言。 Java中的所有东西都是一个对象。面向对象意味着我们将软件组织为包含数据和行为的不同类型对象的组合。

面向对象编程（OOP）是一种通过提供一些规则来简化软件开发和维护的方法。

OOP的基本概念：

+ Object(对象)
+ Class(类)
+ Inheritance(继承)
+ Polymorphism(多态)
+ Abstraction(抽象)
+ Encapsulation(封装)

## 平台无关性(Platform Independent)
Java是独立于平台的，因为它不同于其他语言，如C，C ++等，它们被编译成平台特定的机器，而Java是 write once,run anywhere(一次编写，随处运行) 的语言。平台指的是程序运行的硬件或软件环境。

平台主要有两种类型，一种是基于软件和另一种基于硬件。 Java提供了一个基于软件的平台。

Java平台与大多数其他平台的不同之处在于它是基于软件的平台，可以运行在其他基于硬件的平台之上。它有两个组成部分：
+ Runtime Environment(运行环境)
+ Application Programming Interface(API)

Java代码可以在多个平台上运行，例如，Windows，Linux，Sun Solaris，Mac/OS等.Java代码由编译器编译并转换为字节码。此字节码是与平台无关的代码，因为它可以在多个平台上运行，即一次写入和随处运行（WORA）。

## 健壮性(Robust)

健壮只是意味着强壮。Java非常强壮，因为：
+ 它使用强大的内存管理。
+ 缺乏指针可以避免安全问题。
+ java中有自动垃圾收集，它在Java虚拟机上运行，​​以摆脱Java应用程序不再使用的对象。
+ Java中有异常处理和类型检查机制。

所有这些要点使Java变得健壮。

## 安全性(Secured)

Java以其安全性而闻名。使用Java，我们可以开发无病毒系统。 Java是安全的，因为：
+ 没有明确的指针
+ Java程序在虚拟机沙箱中运行
+ Classloader(类加载器): Java中的lassloader是Java运行时环境（JRE）的一部分，用于动态地将Java类加载到Java虚拟机中。它通过将本地文件系统的类的包与从网络源导入的包分开来增加安全性。
+ Bytecode Verifier(字节码验证器): 检查代码片段中是否存在违反对象访问权限的非法代码。
+ Security Manager(安全管理器): 它确定类可以访问哪些资源，例如读取和写入本地磁盘。

Java语言默认提供这些保障。应用程序开发人员还可以通过SSL，JAAS，Cryptography等明确提供某些安全性。

## 体系结构中立(Architecture-neutral)

Java是体系结构中立的，因为没有依赖于实现的特性，例如，原始类型的大小是固定的。

在C编程中，int数据类型占用32位架构的2字节内存和64位架构的4字节内存。但是，对于Java中的32位和64位体系结构，它都是占用4个字节的内存。

## 轻便(POrtable)

Java是可移植的，因为它便于您将Java字节码传送到任何平台。它不需要任何实现。

## 高性能(High-performance)

Java比其他传统的解释型编程语言更快，因为Java字节码与本机代码“接近”。它仍然比编译语言（例如，C++）慢一点。Java是一种解释型语言，这就是它比编译语言慢的原因，例如C，C ++等。

## 分布式(Distributed)

Java是分布式的，因为它有助于用户使用Java创建分布式应用程序。RMI和EJB用于创建分布式应用程序。Java的这一特性使我们能够通过从互联网上的任何机器调用方法来访问文件。

## 多线程(Multi-threaded)

线程就像一个单独的程序，并发执行。我们可以编写通过定义多个线程来同时处理许多任务的Java程序。多线程的主要优点是它不占用每个线程的内存。它共享一个共同的内存区域。线程对于多媒体，Web应用程序等很重要。

## 动态(Dynamic)

Java是一种动态语言。它支持动态加载类。这意味着按需加载类。它还支持来自其本机语言的函数，即C和C++。

Java支持动态编译和自动内存管理(垃圾回收，gatbage collection)。

---

# JVM,JDK,JRE

## JDK

Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。

JDK有以下三种版本： 
+ J2SE，standard edition，标准版，是我们通常用的一个版本
+ J2EE，enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序
+ J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序

我们常常用JDK来代指Java API，Java API是Java的应用程序接口，其实就是前辈们写好的一些java Class，包括一些重要的语言结构以及基本图形，网络和文件I/O等等，我们在自己的程序中，调用前辈们写好的这些Class，来作为我们自己开发的一个基础。当然，现在已经有越来越多的性能更好或者功能更强大的第三方类库供我们使用。

## JRE

Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。

## JVM

Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。

**字节码**
> 在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

# JavaBean

[JavaBean](https://en.wikipedia.org/wiki/JavaBeans)是遵循Sun定义的JavaBeans约定的类。
> JavaBeans是Java的可重用软件组件，可以在构建器工具中以可视方式进行操作。实际上，它们是用符合特定约定的Java编程语言编写的类。它们用于将许多对象封装到单个对象（bean）中，以便它们可以作为单个bean对象而不是作为多个单独对象传递。JavaBean是一个可序列化的Java对象，具有一个无参的构造函数，并允许使用getter和setter方法访问属性。
>
> 为了充当JavaBean类，对象类必须遵守有关方法命名，构造和行为的某些约定。这些约定使得可以使用可以使用，重用，替换和连接JavaBeans的工具。
>
> 所需的约定是：
>
> + 该类必须具有公共默认构造函数。这允许在编辑和激活框架内轻松实例化。  
> + 必须遵循标准命名约定，使用get，set，is (可以替代get，用在布尔型属性上)和其他方法（所谓的访问器方法和mutator方法）访问类属性。这允许在框架内轻松自动检查和更新bean状态，其中许多包括用于各种类型属性的自定义编辑器。  
> + 该类应该是可序列化的。这允许应用程序和框架以独立于VM和平台的方式可靠地保存，存储和恢复bean的状态。  
> + 因为这些需求主要表示为约定而不是实现接口，所以一些开发人员将JavaBeans视为遵循特定命名约定的Plain Old Java Objects。   

## POJO

[POJO(Plain Old Java Object)](https://en.wikipedia.org/wiki/Plain_old_Java_object)是一个术语，最初用于指定一个简单的轻量级Java对象，而不是实现任何javax.ejb接口，而不是重量级EJB 2.x（尤其是实体Bean，无状态会话Bean并不是那么糟糕的IMO）。今天，该术语用于任何没有额外内容的简单对象。

+ 在阿里Java开发手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。
+ 领域模型命名规约，POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。

## DO

DO(Data Object)与数据库表结构一一对应，通过DAO层向上传输数据源对象。

+ 领域模型命名规约,数据对象：xxxDO，xxx即为数据表名。

## BO

BO(Business Object)业务对象。由Service层输出的封装业务逻辑的对象。

## AO

AO(Application Object)应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

## VO

[VO(Value Object)](https://martinfowler.com/bliki/ValueObject.html)是一个对象，例如java.lang.Integer保存值（因此为值对象）。对于更正式的定义，请参考Martin Fowler对[Value Object](https://martinfowler.com/bliki/ValueObject.html)的描述。

+ VO表示一组固定的数据，类似于Java枚举。值对象的标识基于它们的状态而不是它们的对象标识，并且是不可变的。一个真实世界的例子是Color.RED，Color.BLUE，SEX.FEMALE等

另一种解释

VO（View Object）显示层对象，通常是Web向模板渲染引擎层传输的对象。

+ 领域模型命名规约，展示对象：xxxVO，xxx一般为网页名称。

## DTO

[DTO(Data Transfer Object)](https://en.wikipedia.org/wiki/Data_transfer_object)是EJB引入的（反）模式。不是在EJB上执行许多远程调用，而是将数据封装在可以通过网络传输的值对象中：数据传输对象，Service或Manager向外传输的对象。

+ 数据传输对象只是用于在层和层之间传输数据的数据容器。
+ 它主要包含属性。甚至可以在没有getter和setter的情况下使用公共属性。
+ 数据传输对象不包含任何业务逻辑。
+ DTO主要用于有效地通过网络传输数据，甚至可以从JVM到另一个JVM。
+ TO通常是`java.io.Serializable` 为了通过JVM传输数据。
+ 领域模型命名规约，数据传输对象：xxxDTO，xxx为业务领域相关的名称。

# JVM

## java内存组成 : 堆(Heap) 和 非堆(Non-heap) 内存

按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 
这些组成部分一些是线程私有的，其他的则是线程共享的。

**线程私有的**：
+ 程序计数器
+ 虚拟机栈
+ 本地方法栈

**线程共享的**:
+ 堆
+ 方法区
+ 直接内存


## JVM内存区域模型

### 方法区

方法区(Method Area)也称”永久代” 、“Non-Heap(非堆)”，是被线程共享的区域。它用于存储虚拟机加载的类信息（包括类的名称、方法信息、字段信息）、常量、静态变量以及即时编译器编译后的代码等数据。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。

虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

### 运行时常量池

运行时常量池(Runtime Constant Pool)，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非只有Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

《Java 中几种常量池的区分》： https://blog.csdn.net/qq_26222859/article/details/73135660

### 堆

**堆(Heap) 也叫做java堆、GC堆，是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象),几乎所有的对象实例以及数组都在这里分配内存**。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。

Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。

![gcheap](/img/article/gcheap.jpeg)

在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。

由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。

> 新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。

> 老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。

总结 
1. 存储的全部是对象，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。 
2. jvm只有一个堆区（heap）被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身。 
3. 堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。 
4. 缺点是，由于要在运行时动态分配内存，存取速度较慢。

### 虚拟机栈

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

虚拟机栈(Java Virtual Machine Stacks)描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

JVM栈只对栈帧进行存储，压栈和出栈操作。Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。

> 栈帧：一个栈帧随着一个方法的调用开始而创建，这个方法调用完成而销毁。栈帧内存放者方法中的局部变量，操作数栈等数据。

局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。

栈内存的大小可以有两种设置，固定值和根据线程需要动态增长。 
在JVM栈这个数据区可能会发生抛出两种错误。 
1. StackOverflowError 出现在栈内存设置成固定值的时候，当程序执行需要的栈内存超过设定的固定值会抛出这个错误。 
2. OutOfMemoryError 出现在栈内存设置成动态增长的时候，当JVM尝试申请的内存大小超过了其可用内存时会抛出这个错误

总结 
1. 每个线程包含一个栈区,栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。对象都存放在堆区中。 
2. 每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。 
3. 栈分为3个部分：基本类型变量，执行环境上下文，操作指令区(存放操作指令). 
4. 在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。 
5. 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

### 本地方法栈

一个支持native方法调用的JVM实现，需要有这样一个数据区，就是本地方法栈，Java官方对于本地方法的定义为methods written in a language other than the Java programming language，就是使用非Java语言实现的方法，但是通常我们指的一般为C或者C++，因此这个栈也有着C栈这一称号。一个不支持本地方法执行的JVM没有必要实现这个数据区域。本地方法栈基本和JVM栈一样，其大小也是可以设置为固定值或者动态增加。

和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

### 程序计数器

在通用的计算机体系中，程序计数器用来记录当前正在执行的指令，在JVM中也是如此。程序计数器是线程私有，所以当一个新的线程创建时，程序计数器也会创建。由于Java是支持多线程，Java中的程序计数器用来记录当前线程中正在执行的指令。如果当前正在执行的方法是本地方法，那么此刻程序计数器的值为undefined。

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

从上面的介绍中我们知道程序计数器主要有两个作用：
1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

## 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。

JDK1.4中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## JVM 内存总结

+ Java堆内存是操作系统分配给JVM的内存的一部分。
+ 当我们创建对象时，它们存储在Java堆内存中。
+ 为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。
+ 你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。
+ 你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。
+ 你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。
+ Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。
+ 当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。
+ 请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。
+ Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。


# HotSpot 虚拟机对象探秘

通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。

## 对象的创建

Java 对象的创建过程。

1. 类加载检查 - 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. 分配内存 - 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

**内存分配的两种方式**：

![memAllocation](/img/article/creationObject.jpeg)

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

**内存分配并发问题**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

CAS+失败重试 - CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。

TLAB - 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

3. 初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行 init 方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

