<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>PaulGao Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="PaulGao Blog">
<meta property="og:url" content="https://leigaorobot.github.io/index.html">
<meta property="og:site_name" content="PaulGao Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Paul Gao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="PaulGao Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PaulGao Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://leigaorobot.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ECMAScript6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/20/ECMAScript6/" class="article-date">
  <time datetime="2019-06-20T02:58:36.000Z" itemprop="datePublished">2019-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-Script/">Java Script</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/20/ECMAScript6/">ECMAScript6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-ECMAScript"><a href="#What-is-ECMAScript" class="headerlink" title="What is ECMAScript?"></a>What is ECMAScript?</h1><p>ECMAScript（或ES）是由Ecma International(前身为欧洲计算机制造商协会) 在 ECMA-262 和 ISO/IEC 16262 中标准化的脚本语言规范。它是为了标准化JavaScript而创建的，以便促进多个独立的实现。自标准首次发布以来，JavaScript一直是ECMAScript最着名的实现，其他知名实现包括JScript和ActionScript。 ECMAScript通常用于万维网上的客户端脚本，它越来越多地用于使用Node.js编写服务器应用程序和服务。</p>
<p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。</p>
<h1 id="What-is-ECMAScript-6"><a href="#What-is-ECMAScript-6" class="headerlink" title="What is ECMAScript 6?"></a>What is ECMAScript 6?</h1><p>ECMAScript第6版，最初称为ECMAScript 6（ES6），后来更名为ECMAScript 2015，于2015年6月完成。此更新为编写复杂应用程序添加了重要的新语法，包括类声明( <code>class Foo &#123; ... &#125;</code> )*，ES6的模块<code>import * as moduleName from &quot;...&quot;; export const Foo</code>，但在语义上用与ECMAScript 5严格模式相同的术语定义它们。其它新功能包括iterators 和 for/of loops，Python风格的generator，<strong>箭头函数表达式( <code>()=&gt;&#123; ... &#125;</code> )<strong>，</strong>let</strong>关键字为局部声明，关键字为<strong>const</strong>的常量声明，二进制数据类型数组，新的集合（maps，sets和WeakMap）， promise, 数字和数学增强，反射，代理（虚拟对象和wrappers的元编程）和字符串的模板文字。完整的清单很广泛。作为第一个“ECMAScript Harmony”规范，它也被称为“ES6 Harmony”。</p>
<h1 id="What-is-Babel"><a href="#What-is-Babel" class="headerlink" title="What is Babel?"></a>What is Babel?</h1><p><a target="_blank" rel="noopener" href="https://babeljs.io/">Babel</a> 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 转码前</span><br><span class="line">input.map(item =&gt; item + 1);</span><br><span class="line"></span><br><span class="line">// 转码后</span><br><span class="line">input.map(function (item) &#123;</span><br><span class="line">  return item + 1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<p>下面的命令在项目目录中，安装 Babel。</p>
<p><code>npm install --save-dev @babel/core</code></p>
<h2 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h2><p>Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 最新转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line"># react 转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-react</span><br></pre></td></tr></table></figure>

<p>然后，将这些规则加入.babelrc。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@babel/env&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令行转码"><a href="#命令行转码" class="headerlink" title="命令行转码"></a>命令行转码</h2><p>Babel 提供命令行工具@babel/cli，用于命令行转码。</p>
<p>安装命令 <code>npm install --save-dev @babel/cli</code></p>
<p>基本用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 转码结果输出到标准输出</span><br><span class="line">$ npx babel example.js</span><br><span class="line"></span><br><span class="line"># 转码结果写入一个文件</span><br><span class="line"># --out-file 或 -o 参数指定输出文件</span><br><span class="line">$ npx babel example.js --out-file compiled.js</span><br><span class="line"># 或者</span><br><span class="line">$ npx babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"># 整个目录转码</span><br><span class="line"># --out-dir 或 -d 参数指定输出目录</span><br><span class="line">$ npx babel src --out-dir lib</span><br><span class="line"># 或者</span><br><span class="line">$ npx babel src -d lib</span><br><span class="line"></span><br><span class="line"># -s 参数生成source map文件</span><br><span class="line">$ npx babel src -d lib -s</span><br></pre></td></tr></table></figure>

<h2 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h2><p>@babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。</p>
<p>安装命令 <code>npm install --save-dev @babel/node</code></p>
<p>基本用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npx babel-node</span><br><span class="line">&gt; (x =&gt; x * 2)(1)</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"># es6.js 的代码</span><br><span class="line"># console.log((x =&gt; x * 2)(1));</span><br><span class="line">$ npx babel-node es6.js</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="babel-register"><a href="#babel-register" class="headerlink" title="babel/register"></a>babel/register</h2><p>@babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。</p>
<p>安装命令 <code>npm install --save-dev @babel/register</code></p>
<p>基本用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用时，必须首先加载@babel/register。</span><br><span class="line">// index.js</span><br><span class="line">require(&#x27;@babel/register&#x27;);</span><br><span class="line">require(&#x27;./es6.js&#x27;);</span><br><span class="line"></span><br><span class="line">//然后，就不需要手动对index.js转码了。</span><br><span class="line">$ node index.js</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。</p>
<h2 id="babel-API"><a href="#babel-API" class="headerlink" title="babel API"></a>babel API</h2><p>如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var babel = require(&#x27;@babel/core&#x27;);</span><br><span class="line"></span><br><span class="line">// 字符串转码</span><br><span class="line">babel.transform(&#x27;code();&#x27;, options);</span><br><span class="line">// =&gt; &#123; code, map, ast &#125;</span><br><span class="line"></span><br><span class="line">// 文件转码（异步）</span><br><span class="line">babel.transformFile(&#x27;filename.js&#x27;, options, function(err, result) &#123;</span><br><span class="line">  result; // =&gt; &#123; code, map, ast &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 文件转码（同步）</span><br><span class="line">babel.transformFileSync(&#x27;filename.js&#x27;, options);</span><br><span class="line">// =&gt; &#123; code, map, ast &#125;</span><br><span class="line"></span><br><span class="line">// Babel AST转码</span><br><span class="line">babel.transformFromAst(ast, code, options);</span><br><span class="line">// =&gt; &#123; code, map, ast &#125;</span><br></pre></td></tr></table></figure>

<p>配置对象options，可以参看官方文档<a target="_blank" rel="noopener" href="http://babeljs.io/docs/usage/options/%E3%80%82">http://babeljs.io/docs/usage/options/。</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var es6Code = &#x27;let x = n =&gt; n + 1&#x27;;</span><br><span class="line">var es5Code = require(&#x27;@babel/core&#x27;)</span><br><span class="line">  .transform(es6Code, &#123;</span><br><span class="line">    presets: [&#x27;@babel/env&#x27;]</span><br><span class="line">  &#125;)</span><br><span class="line">  .code;</span><br><span class="line"></span><br><span class="line">console.log(es5Code);</span><br><span class="line">// &#x27;&quot;use strict&quot;;\n\nvar x = function x(n) &#123;\n  return n + 1;\n&#125;;&#x27;</span><br></pre></td></tr></table></figure>

<p>上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。</p>
<h2 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h2><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p>
<p>举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<p>安装命令 <code>npm install --save-dev @babel/polyfill</code></p>
<p>然后，在脚本头部，加入如下一行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;@babel/polyfill&#x27;;</span><br><span class="line">// 或者</span><br><span class="line">require(&#x27;@babel/polyfill&#x27;);</span><br></pre></td></tr></table></figure>

<p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a target="_blank" rel="noopener" href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/runtime-corejs3-definitions.js">definitions.js</a>文件。</p>
<h2 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h2><p>Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">// Your ES6 code</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>Babel 提供一个 <a target="_blank" rel="noopener" href="https://babeljs.io/repl/">REPL 在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<h1 id="Traceur-转码器"><a href="#Traceur-转码器" class="headerlink" title="Traceur 转码器"></a>Traceur 转码器</h1><p>Google 公司的 <a target="_blank" rel="noopener" href="https://github.com/google/traceur-compiler">Traceur转码器</a>，也可以将 ES6 代码转为 ES5 代码。</p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓 <code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code> 对象有以下两个特点。</p>
<ol>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a target="_blank" rel="noopener" href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署Promise更好的选择。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code> 对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code> 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code> 实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>一个Promise对象的简单例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, &#x27;done&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).then((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  console.log(&#x27;Promise&#x27;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function() &#123;</span><br><span class="line">  console.log(&#x27;resolved.&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Hi!&#x27;);</span><br><span class="line"></span><br><span class="line">// Promise</span><br><span class="line">// Hi!</span><br><span class="line">// resolved</span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p>
<p>下面是一个异步加载图片的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loadImageAsync(url) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    const image = new Image();</span><br><span class="line"></span><br><span class="line">    image.onload = function() &#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = function() &#123;</span><br><span class="line">      reject(new Error(&#x27;Could not load image at &#x27; + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。</p>
<p>下面是一个用Promise对象实现的 Ajax 操作的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">  const promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    const handler = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const client = new XMLHttpRequest();</span><br><span class="line">    client.open(&quot;GET&quot;, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = &quot;json&quot;;</span><br><span class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  console.log(&#x27;Contents: &#x27; + json);</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  console.error(&#x27;出错了&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(&#x27;fail&#x27;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail</span><br></pre></td></tr></table></figure>

<p>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;).then(r =&gt; &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  return resolve(1);</span><br><span class="line">  // 后面的语句不会执行</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p>「async/await」是 promises 的另一种更便捷更流行的写法，同时它也更易于理解和使用。</p>
<h3 id="Async-functions"><a href="#Async-functions" class="headerlink" title="Async functions"></a>Async functions</h3><p>让我们以 <code>async</code> 这个关键字开始。它可以被放置在任何函数前面，像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数前面的「async」这个单词表达了一个简单的事情：即这个函数总是返回一个 <strong>promise</strong>。即使这个函数在语法上返回了一个非 promise 的值，加了「async」这个关键字就会指示 JavaScript 引擎自动将返回值包装成一个解析后的 <strong>promise</strong>。</p>
<p>例如，以下的代码就返回了一个以 1 为结果的解析后的 <strong>promise</strong> , 让我们试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(alert); // 1</span><br></pre></td></tr></table></figure>

<p>… 我们也可以显式返回一个 <strong>promise</strong> ，结果是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  return Promise.resolve(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(alert); // 1</span><br></pre></td></tr></table></figure>

<p>所以说， <code>async</code> 确保了函数的返回值是一个 <strong>promise</strong> ，也会包装非 <strong>promise</strong> 的值。很简单是吧？但是还没完。还有一个关键字叫 <code>await</code> ，它只在 <code>async</code> 函数中有效，也非常酷。</p>
<h3 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h3><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 只在 async 函数中有效</span><br><span class="line">let value = await promise;</span><br></pre></td></tr></table></figure>

<p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 <strong>promise</strong> 完成并返回结果。</p>
<p>这里的例子就是一个 1 秒后解析的 <strong>promise</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line"></span><br><span class="line">  let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  let result = await promise; // 等待直到 promise 解析 （*）</span><br><span class="line"></span><br><span class="line">  alert(result); // &quot;done!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>这个函数在执行的时候，「暂停」在了 (*) 那一行，并且当 <strong>promise</strong> 完成后，拿到 result 作为结果继续往下执行。所以「done!」是在一秒后显示的。</p>
<p>划重点： <code>await</code> 字面的意思就是让 <strong>JavaScript</strong> 引擎等待直到 <strong>promise</strong> 状态完成，然后以完成的结果继续执行。这个行为不会耗费 CPU 资源，因为引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p>
<p>相比 <code>promise.then</code> 来获取 <strong>promise</strong> 结果，这只是一个更优雅的语法，同时也更易书写。</p>
<h3 id="不能在普通函数中使用-await"><a href="#不能在普通函数中使用-await" class="headerlink" title="不能在普通函数中使用 await"></a>不能在普通函数中使用 await</h3><p>如果我们尝试在非 <code>async</code> 函数中使用 <code>await</code> 的话，就会报语法错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  let promise = Promise.resolve(1);</span><br><span class="line">  let result = await promise; // 语法错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数前面没有 <code>async</code> 关键字，我们就会得到一个语法错误。就像前面说的，<code>await</code> 只在 <code>async</code> 函数 中有效。</p>
<h3 id="async-await-example"><a href="#async-await-example" class="headerlink" title="async/await example"></a>async/await example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">async function showAvatar() &#123;</span><br><span class="line"></span><br><span class="line">  // 读取 JSON</span><br><span class="line">  let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);</span><br><span class="line">  let user = await response.json();</span><br><span class="line"></span><br><span class="line">  // 读取 github 用户信息</span><br><span class="line">  let githubResponse = await fetch(`https://api.github.com/users/$&#123;user.name&#125;`);</span><br><span class="line">  let githubUser = await githubResponse.json();</span><br><span class="line"></span><br><span class="line">  // 显示头像</span><br><span class="line">  let img = document.createElement(&#x27;img&#x27;);</span><br><span class="line">  img.src = githubUser.avatar_url;</span><br><span class="line">  img.className = &quot;promise-avatar-example&quot;;</span><br><span class="line">  document.body.append(img);</span><br><span class="line"></span><br><span class="line">  // 等待 3 秒</span><br><span class="line">  await new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000));</span><br><span class="line"></span><br><span class="line">  img.remove();</span><br><span class="line"></span><br><span class="line">  return githubUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showAvatar();</span><br></pre></td></tr></table></figure>

<h3 id="await-不能在顶层代码运行"><a href="#await-不能在顶层代码运行" class="headerlink" title="await 不能在顶层代码运行"></a>await 不能在顶层代码运行</h3><p>刚开始使用 <code>await</code> 的人常常会忘记 <code>await</code> 不能用在顶层代码中。如，下面这样就不行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 用在顶层代码中会报语法错误</span><br><span class="line">let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);</span><br><span class="line">let user = await response.json();</span><br></pre></td></tr></table></figure>

<p>我们可以将其包裹在一个匿名 async 函数中，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);</span><br><span class="line">  let user = await response.json();</span><br><span class="line">  ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="await-可以接收「thenables」"><a href="#await-可以接收「thenables」" class="headerlink" title="await 可以接收「thenables」"></a>await 可以接收「thenables」</h3><p>像 <code>promise.then</code> 那样，<code>await</code> 被允许接收 <code>thenable</code> 对象（具有 <code>then</code> 方法的对象）。有些对象虽然不是 <code>promise</code>，但是却兼容 <code>promise</code>，如果这些对象支持 <code>.then</code>，那么就可以对它们使用 <code>await</code>。</p>
<p>下面是一个 <code>Thenable</code> 类，<code>await</code> 接收了该类的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Thenable &#123;</span><br><span class="line">  constructor(num) &#123;</span><br><span class="line">    this.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    alert(resolve);</span><br><span class="line">    // 1 秒后解析为 this.num*2</span><br><span class="line">    setTimeout(() =&gt; resolve(this.num * 2), 1000); // (*)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">async function f() &#123;</span><br><span class="line">  // 等待 1 秒, result 变为 2</span><br><span class="line">  let result = await new Thenable(1);</span><br><span class="line">  alert(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>如果 await 接收了一个非 <strong>promise</strong> 的但是提供了 <code>.then</code> 方法的对象，它就会调用这个 <code>then</code> 方法，并将原生函数 <code>resolve，reject</code> 作为参数传入。然后 <code>await</code> 等到这两个方法中的某个被调用（在例子中发生在（*）的那一行），再处理得到的结果。</p>
<h3 id="Async-methods"><a href="#Async-methods" class="headerlink" title="Async methods"></a>Async methods</h3><p>如果想定义一个 <code>async</code> 的类方法，在方法前面添加 <code>async</code> 就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Waiter &#123;</span><br><span class="line">  async wait() &#123;</span><br><span class="line">    return await Promise.resolve(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Waiter()</span><br><span class="line">  .wait()</span><br><span class="line">  .then(alert); // 1</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果一个 <strong>promise</strong> 正常解析，<code>await promise</code> 返回的就是其结果。但是如果 <strong>promise</strong> 被拒绝，就会抛出一个错误，就像在那一行有个 <code>throw</code> 语句那样。</p>
<p>这里的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  await Promise.reject(new Error(&quot;Whoops!&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…和下面是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  throw new Error(&quot;Whoops!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在真实的环境下，<strong>promise</strong> 被拒绝前通常会等待一段时间。所以 <code>await</code> 会等待，然后抛出一个错误。</p>
<p>我们可以用 <code>try...catch</code> 来捕获上面的错误，就像对一般的 <code>throw</code> 语句那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    let response = await fetch(&#x27;http://no-such-url&#x27;);</span><br><span class="line">  &#125; catch(err) &#123;</span><br><span class="line">    alert(err); // TypeError: failed to fetch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>如果有错误发生，代码就会跳到 <code>catch</code> 块中。当然也可以用 <code>try</code> 包裹多行 <code>await</code> 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    let response = await fetch(&#x27;/no-user-here&#x27;);</span><br><span class="line">    let user = await response.json();</span><br><span class="line">  &#125; catch(err) &#123;</span><br><span class="line">    // 捕获到 fetch 和 response.json 中的错误</span><br><span class="line">    alert(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>如果我们不使用 <code>try...catch</code>，由f() 产生的 <strong>promise</strong> 就会被拒绝。我们可以在函数调用后添加 <code>.catch</code> 来处理错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  let response = await fetch(&#x27;http://no-such-url&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// f() 变为一个被拒绝的 promise</span><br><span class="line">f().catch(alert); // TypeError: failed to fetch // (*)</span><br></pre></td></tr></table></figure>

<p>如果我们忘了添加 <code>.catch</code>，我们就会得到一个未处理的 <strong>promise</strong> 错误（显示在控制台）。我们可以通过在错误处理与全局事件处理器来捕获这些。</p>
<h3 id="async-await-和-promise-then-catch"><a href="#async-await-和-promise-then-catch" class="headerlink" title="async/await 和 promise.then/catch"></a>async/await 和 promise.then/catch</h3><p>当我们使用 <code>async/await</code> 时，几乎就不会用到 <code>.then</code> 了，因为为我们<code>await</code> 处理了异步等待。并且我们可以用 <code>try...catch</code> 来替代 <code>.catch</code>。这通常更加方便（当然不是绝对的）。</p>
<p>但是当我们在顶层代码，外面并没有任何 <code>async</code> 函数，我们在语法上就不能使用 <code>await</code> 了，所以这时候就可以用 <code>.then/catch</code> 来处理结果和异常。</p>
<p>就像上面代码的 (*) 那行一样。</p>
<h3 id="async-await-可以和-Promise-all-一次使用"><a href="#async-await-可以和-Promise-all-一次使用" class="headerlink" title="async/await 可以和 Promise.all 一次使用"></a>async/await 可以和 Promise.all 一次使用</h3><p>当我们需要同时等待多个 <strong>promise</strong> 时，我们可以用 <code>Promise.all</code> 来包裹他们，然后使用 <code>await</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 等待多个 promise 结果</span><br><span class="line">let results = await Promise.all([</span><br><span class="line">  fetch(url1),</span><br><span class="line">  fetch(url2),</span><br><span class="line">  ...</span><br><span class="line"> ]);</span><br></pre></td></tr></table></figure>

<p>如果发生错误，也会正常传递：先从失败的 <strong>promise</strong> 传到 <code>Promise.all</code>，然后变成我们能用 <code>try...catch</code> 处理的异常。</p>
<h3 id="Microtask-queue"><a href="#Microtask-queue" class="headerlink" title="Microtask queue"></a>Microtask queue</h3><p><strong>promise</strong> 回调是异步执行的。每个 <code>.then/catch/finally</code> 回调首先被放入「微任务队列」然后在当前代码执行完成后被执行。</p>
<p><code>Async/await</code> 是基于 <strong>promise</strong> 的，所以它内部使用相同的微任务队列，并且相对宏任务来说具有更高的优先级。</p>
<p>例如，看代码：</p>
<ul>
<li><code>setTimeout(handler, 0)</code>，应该以零延迟运行 handler 函数。</li>
<li><code>let x = await f()</code>，函数 f() 是异步的，但是会立即运行。</li>
</ul>
<p>那么如果 <code>await</code> 在 <code>setTimeout</code> 下面，哪一个先执行呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; alert(&#x27;timeout&#x27;), 0);</span><br><span class="line"></span><br><span class="line">    await f();</span><br><span class="line"></span><br><span class="line">    alert(&#x27;await&#x27;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这里很确定：<code>await</code> 总是先完成，因为（作为微任务）它相比 <code>setTimeout</code> 具有更高的优先级。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数前面的关键字 <code>async</code> 有两个作用：</p>
<ol>
<li>让这个函数返回一个 promise</li>
<li>允许在函数内部使用 await</li>
</ol>
<p>这个 <code>await</code> 关键字又让 <strong>JavaScript</strong> 引擎等待直到 <strong>promise</strong> 完成，然后：</p>
<ol>
<li>如果有错误，就会抛出异常，就像那里有一个 throw error 语句一样。</li>
<li>否则，就返回结果，并赋值。</li>
</ol>
<p>这两个关键字一起用就提供了一个很棒的方式来控制异步代码，并且易于读写。</p>
<p>有了 <code>async/await</code> 我们就几乎不需要使用 <code>promise.then/catch</code>，但是不要忘了它们是基于 <strong>promise</strong> 的，所以在有些时候（如在最外层代码）我们就可以用 <strong>promise</strong> 的形式。再有就是 <code>Promise.all</code> 可以帮助我们同时处理多个异步任务。</p>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>Wikipedia - ECMAScript : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ECMAScript#cite_note-27">https://en.wikipedia.org/wiki/ECMAScript#cite_note-27</a></li>
<li>ecma-international - 官网 : <a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/">https://www.ecma-international.org/ecma-262/6.0/</a></li>
<li>ECMAScript 6 入门 - 阮一峰 : <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a></li>
<li>[译]带你理解 Async/await : <a target="_blank" rel="noopener" href="https://savokiss.com/tech/async-await.html">https://savokiss.com/tech/async-await.html</a></li>
<li>javascript.info - async-await : <a target="_blank" rel="noopener" href="https://javascript.info/async-await">https://javascript.info/async-await</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/06/20/ECMAScript6/" data-id="ckvgcipj20001plqhfsd24nzd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-script/" rel="tag">java script</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LinuxCommandLine" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/LinuxCommandLine/" class="article-date">
  <time datetime="2019-05-30T02:29:23.000Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Command-Line/">Command Line</a>►<a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/LinuxCommandLine/">Linux Command-Line</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://explainshell.com/#">explainshell</a></p>
<h1 id="Everything-is-file"><a href="#Everything-is-file" class="headerlink" title="Everything is file"></a>Everything is file</h1><h1 id="Daily-use"><a href="#Daily-use" class="headerlink" title="Daily use"></a>Daily use</h1><ul>
<li><strong>cat</strong>: 连接文件, 读取一个或多个文件，然后复制它们到标准输出.</li>
<li><strong>sort</strong>: 排序文本行</li>
<li><strong>uniq</strong>: 报道或省略重复行,uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序 列表（详情查看 man uniq）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | uniq | less</span><br><span class="line">ls /bin /usr/bin | sort | uniq -d | less (&quot;-d&quot;,显示重复的数据列表)</span><br></pre></td></tr></table></figure></li>
<li><strong>grep</strong>: 打印匹配行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">bunzip2</span><br><span class="line">bzip2</span><br><span class="line">gunzip</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><strong>wc</strong>: wc（字计数）命令是用来显示文件所包含的行数、字数和字节数.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ wc ls-output.txt</span><br><span class="line">7902 64566 503634 ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l (&quot;-l&quot;,限制命令输出只能报道行数)</span><br><span class="line">2728</span><br></pre></td></tr></table></figure></li>
<li><strong>head</strong>: 输出文件第一部分(打印文件开头部分)</li>
<li><strong>tail</strong>: 输出文件最后一部分(打印文件结尾部分)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ head -n 5 ls-output.txt  (&quot;-n&quot;,打印的行数)</span><br><span class="line">total 343496</span><br><span class="line">...</span><br><span class="line">[me@linuxbox ~]$ tail -n 5 ls-output.txt</span><br><span class="line">...</span><br><span class="line">[me@linuxbox ~]$ tail -f /var/log/messages (&quot;-f&quot;, )</span><br><span class="line">Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li>
<li><strong>tee</strong>: 从标准输入读取数据，并同时写到标准输出和文件</li>
<li><strong>man [any command]</strong>: 查看任意命令的帮助文档</li>
<li>Tab: 补全</li>
<li><strong>ctrl-r</strong>: 搜索命令历史记录（按下后，键入要搜索的值，反复按ctrl-r循环切换更多匹配，按Enter键执行找到的命令，或者点击右箭头将结果放在当前行中以允许编辑）</li>
<li><strong>ctrl-w</strong>: 删除最后一个单词</li>
<li><strong>ctrl-u</strong>: 将当前光标中的内容删除回行的开头</li>
<li><strong>alt-b/alt-f</strong>: 按单词向左/右移动</li>
<li><strong>ctrl-a/ctrl-e</strong>: 将光标移动到行首/行尾</li>
<li><strong>ctrl -k</strong>: 清除到行尾</li>
<li><strong>ctrl -l</strong>: 清除屏幕</li>
<li><strong>history</strong>: 查看最近的命令。跟随!n（n命令编号在哪里）再次执行。!$最后一个参数和!!最后一个命令（请参见手册页中的“HISTORY EXPANSION”）。但是，这些通常很容易被ctrl-r和alt-.取代。</li>
<li><strong>cd -</strong>: 要返回上一个工作目录</li>
<li><strong>xargs</strong>: 将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题，可以正确处理输入中有空格等特殊字符的情况。对于经常产生大量输出的命令如find、locate和grep来说非常有用。</li>
<li>pstree -p: 显示进程树</li>
<li>pgrep &amp; pkill: find or signal processes by name</li>
<li>man 7 signal: signal detail info</li>
<li><strong>nohup/disown</strong>: want a background process to keep running forever</li>
<li>netstat -ln[tp(TCP)/u(UDP)] / ss -pla[t(TCP)/u(UDP)] / lsof -iTCP -sTCP:LISTEN -P -n: 检查监听进程</li>
<li>lsof / fuser: open sockets and files</li>
<li>uptime: 系统到现在运行了多长时间</li>
<li><strong>alias</strong>: 别名<blockquote>
<p>save alias see more <a target="_blank" rel="noopener" href="https://superuser.com/questions/183870/difference-between-bashrc-and-bash-profile/183980#183980">arrange for login shells to source it.</a><br>传统上，当登录Unix系统时，系统会为启动一个程序。该程序是一个shell，即一个旨在启动其他程序的程序。它是一个命令行shell：通过键入其名称来启动另一个程序。默认shell（Bourne shell）从<del>/.profile作为登录shell调用时读取命令。<br>Bash是一个类似Bourne的shell。它从</del>/.bash_profile作为登录shell调用时读取命令，如果该文件不存在，则会尝试读取<del>/.profile。<br>您可以随时直接调用shell，例如在GUI环境中启动终端仿真器。如果shell不是登录shell，则不会读取</del>/.profile。当您将bash作为交互式shell启动时（即，不运行脚本），它会读取<del>/.bashrc（除非作为登录shell调用时，它只读取</del>/.bash_profile或~/.profile。<br>因此：  </p>
<ul>
<li>~/.profile 是放置适用于整个会话的内容的地方，例如您希望在登录时启动的程序（但不是图形程序，它们会进入不同的文件）和环境变量定义。</li>
<li><del>/.bashrc 是放置仅适用于bash本身的东西的地方，例如别名和函数定义，shell选项和提示设置。（你也可以在那里放置键绑定，但对于bash，他们通常会进入</del>/.inputrc。）</li>
<li><del>/.bash_profile 可以代替使用</del>/.profile，但它只能由bash读取，而不能由任何其他shell读取。（如果您希望初始化文件在多台计算机上运行并且您的登录shell不是所有计算机上的bash，那么这主要是一个问题。）<del>/.bashrc如果shell是交互式的，这是一个合乎逻辑的位置。我推荐以下内容</del>/.bash_profile：z  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if [ -r ~/.profile ]; then . ~/.profile; fi</span><br><span class="line">case &quot;$-&quot; in *i*) if [ -r ~/.bashrc ]; then . ~/.bashrc; fi;; esac</span><br></pre></td></tr></table></figure>
在现代unices上，有一个与<del>/.profile相关的附加复杂性。如果您在图形环境中登录(也就是说，如果您键入密码的程序以图形模式运行)，则不会自动获得一个读取</del>/.profile的登录shell。根据图形登录程序、随后运行的窗口管理器或桌面环境以及发行版如何配置这些程序，您的<del>/.的配置文件可以读取，也可以不读取。如果不是，通常还可以在另一个地方定义环境变量和程序，以便在登录时启动，但遗憾的是没有标准位置。<br>注意，您可能会在这里和那里看到一些建议，将环境变量定义放在</del>/中。bashrc或总是在终端中启动登录shell。两者都是坏主意。这两种方法中最常见的问题是，环境变量只能在通过终端启动的程序中设置，而不能在直接使用图标、菜单或键盘快捷方式启动的程序中设置。<br>为了完整起见，请按请求:如果.bash_profile不存在，bash还会在返回.profile之前尝试.bash_login。请忘记它的存在。</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="I-O-redirection"><a href="#I-O-redirection" class="headerlink" title="I/O redirection"></a>I/O redirection</h1><p>Many of the programs that we have used so far produce output of some kind. This output often consists of two types. First, we have the program’s results; that is, the data the program is designed to produce, and second, we have status and error messages that tell us how the program is getting along. If we look at a command like ls, we can see that it displays its results and its error messages on the screen.</p>
<p>到目前为止，我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成。 第一，程序运行结果；这是说，程序要完成的功能。第二，我们得到状态和错误信息， 这些告诉我们程序进展。如果我们观察一个命令，例如 ls，会看到它的运行结果和错误信息 显示在屏幕上。</p>
<p>Keeping with the Unix theme of “everything is a file,” programs such as ls actually send their results to a special file called standard output (often expressed as stdout) and their status messages to another file called standard error (stderr). By default, both standard output and standard error are linked to the screen and not saved into a disk file. In addition, many programs take input from a facility called standard input (stdin) which is, by default, attached to the keyboard.</p>
<p>与 Unix 主题“任何东西都是一个文件”保持一致，像 ls这样的程序实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。</p>
<h2 id="Standard-output"><a href="#Standard-output" class="headerlink" title="Standard output"></a>Standard output</h2><p>I/O redirection allows us to redefine where standard output goes. To redirect standard output to another file besides the screen, we use the “&gt;” redirection operator followed by the name of the file. Why would we want to do this? It’s often useful to store the output of a command in a file. For example, we could tell the shell to send the output of the ls command to the file ls-output.txt instead of the screen:</p>
<p>I/O 重定向允许我们来重定义标准输出的地点。我们使用 “&gt;” 重定向符后接文件名将标准输出重定向到除屏幕 以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去， 由文件代替屏幕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>when we redirect output with the “&gt;” redirection operator, the destination file is always rewritten from the beginning. Since our ls command generated no results and only an error message, the redirection operation started to rewrite the file and then stopped because of the error, resulting in its truncation. In fact, if we ever need to actually truncate a file (or create a new, empty file) we can use a trick like this:</p>
<p>当我们使用 “&gt;” 重定向符来重定向输出结果时，目标文件总是从开头被重写。 因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后 由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>Simply using the redirection operator with no command preceding it will truncate an existing file or create a new, empty file.</p>
<p>简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是 创建一个新的空文件。</p>
<p>So, how can we append redirected output to a file instead of overwriting the file from the beginning? For that, we use the “&gt;&gt;” redirection operator, like so:</p>
<p>所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目的， 我们使用”&gt;&gt;“重定向符，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>Using the “&gt;&gt;” operator will result in the output being appended to the file. If the file does not already exist, it is created just as though the “&gt;” operator had been used. Let’s put it to the test:</p>
<p>使用”&gt;&gt;“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”&gt;”操作符。把它放到测试中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me   me    503634 2008-02-01 15:45 ls-output.txt</span><br></pre></td></tr></table></figure>

<p>We repeated the command three times resulting in an output file three<br>我们重复执行命令三次，导致输出文件大小是原来的三倍</p>
<h2 id="Standard-error"><a href="#Standard-error" class="headerlink" title="Standard error"></a>Standard error</h2><p>Redirecting standard error lacks the ease of a dedicated redirection operator. To redirect standard error we must refer to its file descriptor. A program can produce output on any of several numbered file streams. While we have referred to the first three of these file streams as standard input, output and error, the shell references them internally as file descriptors zero, one and two, respectively. The shell provides a notation for redirecting files using the file descriptor number. Since standard error is the same as file descriptor number two, we can redirect standard error with this notation:</p>
<p>标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前 三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure>

<p>The file descriptor “2” is placed immediately before the redirection operator to perform the redirection of standard error to the file ls-error.txt.</p>
<p>文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。</p>
<h2 id="Redirect-both-standard-output-and-standard-error"><a href="#Redirect-both-standard-output-and-standard-error" class="headerlink" title="Redirect both standard output and standard error"></a>Redirect both standard output and standard error</h2><p>There are cases in which we may wish to capture all of the output of a command to a single file. To do this, we must redirect both standard output and standard error at the same time. There are two ways to do this. First, the traditional way, which works with old versions of the shell:</p>
<p>有时我们希望将一个命令的所有输出保存到一个文件。为此，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个是传统的方法， 在旧版本 shell 中也有效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>Using this method, we perform two redirections. First we redirect standard output to the file ls-output.txt and then we redirect file descriptor two (standard error) to file descriptor one (standard output) using the notation 2&gt;&amp;1.</p>
<p>使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2&gt;&amp;1。</p>
<p>Notice that the order of the redirections is significant. The redirection of standard error must always occur after redirecting standard output or it doesn’t work. In the example above,</p>
<p>注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。上面的例子，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ls-output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>standard error is directed to the screen.</p>
<p>则标准错误定向到屏幕。</p>
<p>Recent versions of bash provide a second, more streamlined method for performing this combined redirection:</p>
<p>现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>

<p>In this example, we use the single notation &amp;&gt; to redirect both standard output and standard error to the file ls-output.txt.</p>
<p>在这个例子里面，我们使用单单一个表示法 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt。</p>
<h2 id="Bit-bucket"><a href="#Bit-bucket" class="headerlink" title="Bit bucket"></a>Bit bucket</h2><p>Sometimes “silence is golden,” and we don’t want output from a command, we just want to throw it away. This applies particularly to error and status messages. The system provides a way to do this by redirecting output to a special file called “/dev/null”. This file is a system device called a bit bucket which accepts input and does nothing with it. To suppress error messages from a command, we do this:</p>
<p>有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; /dev/null</span><br></pre></td></tr></table></figure>

<blockquote>
<p>/dev/null in Unix Culture<br>Unix 文化中的/dev/null<br>The bit bucket is an ancient Unix concept and due to its universality, has appeared in many parts of Unix culture. When someone says he/she is sending your comments to /dev/null, now you know what it means. For more examples, see the Wikipedia article on “/dev/null”.<br>位存储桶是个古老的 Unix 概念，由于它的普遍性，它的身影出现在 Unix 文化的 许多部分。当有人说他/她正在发送你的评论到/dev/null，现在你应该知道那是 什么意思了。更多的例子，可以阅读 Wikipedia 关于”/dev/null”的文章。</p>
</blockquote>
<h1 id="pipelines"><a href="#pipelines" class="headerlink" title="pipelines"></a>pipelines</h1><p>The ability of commands to read data from standard input and send to standard output is utilized by a shell feature called pipelines. Using the pipe operator “|” (vertical bar), the standard output of one command can be piped into the standard input of another:</p>
<p>命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure>

<p>To fully demonstrate this, we are going to need some commands. Remember how we said there was one we already knew that accepts standard input? It’s less. We can use less to display, page-by-page, the output of any command that sends its results to standard output:</p>
<p>为了全面地说明这个命令，我们需要一些命令。是否记得我们说过，我们已经知道有一个 命令接受标准输入？它是 less 命令。我们用 less 来一页一页地显示任何命令的输出，命令把 它的运行结果输送到标准输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin | less</span><br></pre></td></tr></table></figure>

<p>Pipelines are often used to perform complex operations on data. It is possible to put several commands together into a pipeline. Frequently, the commands used this way are referred to as filters. Filters take input, change it somehow and then output it. The first one we will try is sort. Imagine we wanted to make a combined list of all of the executable programs in /bin and /usr/bin, put them in sorted order and view it:</p>
<p>管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。第一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | less</span><br></pre></td></tr></table></figure>

<p>Since we specified two directories (/bin and /usr/bin), the output of ls would have consisted of two sorted lists, one for each directory. By including sort in our pipeline, we changed the data to produce a single, sorted list.</p>
<p>因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>grep is a powerful program used to find text patterns within files. It’s used like this:</p>
<p>grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern [file...]</span><br></pre></td></tr></table></figure>

<p>There are a couple of handy options for grep: “-i” which causes grep to ignore case when performing the search (normally searches are case sensitive) and “-v” which tells grep to only print lines that do not match the pattern.</p>
<p>grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/05/30/LinuxCommandLine/" data-id="ckvgcipjd000fplqhenm22978" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/command/" rel="tag">command</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/command-line/" rel="tag">command-line</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OSIApplicationLayer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/24/OSIApplicationLayer/" class="article-date">
  <time datetime="2019-05-24T06:17:03.000Z" itemprop="datePublished">2019-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Computer-Network/">Computer Network</a>►<a class="article-category-link" href="/categories/Internet-Protocol-Suite/">Internet Protocol Suite</a>►<a class="article-category-link" href="/categories/OSI-Model/">OSI Model</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/24/OSIApplicationLayer/">Application Layer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-Applicaton-Layer？"><a href="#What-is-Applicaton-Layer？" class="headerlink" title="What is Applicaton Layer？"></a>What is Applicaton Layer？</h1><p>应用层(Application Layer) 是一个抽象层，它指定通信网络中主机使用的共享 通信协议(communications protocols) 和接口方法。应用层抽象用于计算机网络的两种标准模型：Internet Protocol Suite(TCP/IP) 和 OSI Model。虽然两个模型对于各自的最高级别层使用相同的术语，但详细的定义和目的是不同的。</p>
<p>在 TCP/IP 协议中，应用层包含用于跨 Internet Protocols(IP) 计算机网络进行进程间通信的通信协议和接口方法。应用层仅标准化通信，并且依赖底层传输层协议来建立 主机到主机(host-to-host) 的数据传输通道，并在 cilent-server 或 peer-to-peer networking model 中管理数据交换。虽然 TCP/IP 应用层没有描述应用程序在通信时必须考虑的特定规则或数据格式，但是原始规范<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc1123">(RFC 1123)</a>依赖并推荐了应用程序设计的健壮性原则。</p>
<blockquote>
<p>RFC: 请求意见稿（英语：Request For Comments，缩写：RFC）是由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社群的软件文件，以编号排定。当前RFC文件是由互联网协会（ISOC）赞助发行。<br>RFC始于1969年，由当时就读加州大学洛杉矶分校（UCLA）的斯蒂芬·克罗克（Stephen D. Crocker）用来记录有关ARPANET开发的非正式文档，他是第一份RFC文档的撰写者。最终演变为用来记录互联网规范、协议、过程等的标准文件。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多的论题在标准内，例如对于互联网新开发的协议及发展中所有的记录。</p>
</blockquote>
<p>在 OSI Model 中，应用层的定义范围更窄。OSI Model 将应用程序层定义为负责向用户显示接收到的信息的用户界面。相反，Internet Protocol Suite 并不关心这些细节。OSI 还显式地区分了应用程序层之下的其他功能，但在传输层之上还有两层: Seesion Layer(会话层) 和 Persentation Layer(表示层)。OSI在这些层上指定了严格的功能模块化分离，并为每一层提供协议实现。</p>
<h2 id="Application-Layer-Protocols-Introduces"><a href="#Application-Layer-Protocols-Introduces" class="headerlink" title="Application Layer Protocols Introduces"></a>Application Layer Protocols Introduces</h2><p>(OSI Model 下的 会话层)Internet Protocol Suite 中的应用层 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force">IETF</a>定义文档是RFC 1123.它提供了一组初始协议，涵盖了早期Internet功能的主要方面。</p>
<blockquote>
<p>IETF： 互联网工程任务小组（英语：Internet Engineering Task Force，缩写：IETF）负责互联网标准的开发和推动。<br>它的组织形式主要是大量负责特定议题的工作组，每个都有一个指定主席（或者若干副主席）。工作组再用主题组织为领域（area）；每个领域都有一个领域指导（area director，AD），大多数领域还有两个副AD；AD任命工作组主席。AD和IETF主席构成Internet Engineering Steering Group（IESG），负责IETF的整体运作。</p>
</blockquote>
<ul>
<li>Remote login to hosts(远程登录主机)： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Telnet">Telnet</a>,<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Secure_Shell">Secure Shell</a>(SSH)</li>
<li>File transfer(文件传输)： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">File Transfer Potocol</a>(FTP)，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol">Trivial File Transfer Protocol</a>(TFTP)</li>
<li>Eletronic mail transport(电子邮件传输)： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol">Simple Mail Transfer Protocol</a>(SMTP)</li>
<li>Networking support(网络支持)： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</a>(DNS)</li>
<li>Host initialization(主机初始化)： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bootstrap_Protocol">BOOTP</a>,<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">Dynamic Host Configuration Protocol</a>(DHCP)</li>
<li>Remote host management(远程主机管理)： <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">Simple Network Management Protocol</a>（SNMP），<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Common_Management_Information_Protocol">Common Management Information over TCP</a>（CMOT）</li>
</ul>
<h3 id="Design-patterns-for-application-layer-protocols"><a href="#Design-patterns-for-application-layer-protocols" class="headerlink" title="Design patterns for application layer protocols"></a>Design patterns for application layer protocols</h3><p>在通信协议的设计和实现中经常会出现重复出现的问题，这些问题可以通过几种不同模式语言的模式来解决：</p>
<ul>
<li>应用级通信协议的模式语言(<a target="_blank" rel="noopener" href="http://commdp.serv.usu.edu/">CommDP</a>)</li>
<li>服务设计模式(R. Daigneau, Service Design Patterns: Fundamental Design Solutions for SOAP/WSDL and RESTful Web Services, 1 edition. Upper Saddle River, NJ: Addison-Wesley Professional, 2011.)</li>
<li>企业应用程序架构模式(M. Fowler, Patterns of Enterprise Application Architecture, 1 edition. Boston: Addison-Wesley Professional, 2002.)</li>
<li>模式导向软件架构：分布式计算的模式语言。(F. Buschmann, K. Henney, and D. C. Schmidt, Pattern-Oriented Software Architecture Volume 4: A Pattern Language for Distributed Computing, Volume 4 edition. Chichester England; New York: Wiley, 2007.)</li>
</ul>
<p>这些模式语言中的第一种侧重于协议的设计，而不是它们的实现。另一些则涉及这两个领域或只是后者的问题。</p>
<h2 id="Other-protocol-examples"><a href="#Other-protocol-examples" class="headerlink" title="Other protocol examples"></a>Other protocol examples</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/9P_(protocol)">9P</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs">Plan 9 from Bell Labs(贝尔实验室九号项目)</a> - distributed file system protocol(分布式文件系统协议)</li>
<li>AFP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Apple_Filing_Protocol">Apple Filing Protocol(苹果归档协议)</a></li>
<li>APPC, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IBM_Advanced_Program-to-Program_Communication">Advanced Program-to-Program Communication</a></li>
<li><strong>AMQP， <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">Advanced Message Queuing Protocol(高级消息队列协议)</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Atom_(Web_standard)">Atom Publishing Protocol(Atom出版协定,用于新增及修改网络资源，基于HTTP的协议。)</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BEEP">BEEP</a>, Block Extensible Exchange Protocol</li>
<li><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bitcoin">Bitcoin(比特币)</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BitTorrent">BitTorrent(简称BT，俗称比特洪流、BT下载)</a></strong></li>
<li>CFDP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coherent_file_distribution_protocol">Coherent File Distribution Protocol</a></li>
<li>CoAP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol">Constrained Application Protocol(约束应用程序协议, 该协议专为机器对机器（M2M）应用而设计，如智能能源和楼宇自动化。)</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Machine_to_machine">M2M</a></li>
<li>DDS, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_Distribution_Service">Data Distribution Service</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DeviceNet">DeviceNet</a>(DeviceNet使用控制器局域网络（CAN）为其底层的通讯协定，其应用层有针对不同设备所定义的行规（profile）。主要的应用包括资讯交换、安全设备及大型控制系统。)</li>
<li>ENRP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endpoint_Handlespace_Redundancy_Protocol">Endpoint Handlespace Redundancy Protocol</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FastTrack">FastTrack - peer to peer protocol, file sharing network</a>(KaZaa, Grokster, iMesh)</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Finger_protocol">Finger</a>, User Information Protocol</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Freenet">Freenet</a>, Peer to Peer Platform</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FTAM">FTAM</a>, File Transfer Access and Management</li>
<li>Gopher, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gopher_(protocol)">Gopher protoco</a>(分布型的文件搜集获取网络协议)</li>
<li>HL7, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Health_Level_7">Health Level Seven</a>(卫生信息交换标准)</li>
<li><strong>HTTP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HyperText Transfer Protocol</a>(HTTP是万维网的数据通信的基础)</strong></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/H.323">H.323</a>, Packet-Based Multimedia Communications System</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol">IMAP</a>, Internet Message Access Protocol，用来从本地邮件客户端（如Microsoft Outlook、Outlook Express、Foxmail、Mozilla Thunderbird）访问远程服务器上的邮件。</li>
<li>IRCP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat Protocol</a>, 主要用于群体聊天，但同样也可以用于个人对个人的聊天。IRC使用的服务器端口有6667（明文传输，如irc://irc.freenode.net）、6697（SSL加密传输，如ircs://irc.freenode.net:6697）等。</li>
<li>IPFS, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">InterPlanetary File System</a>, 旨在创建持久且分布式存储和共享文件的网络传输协议。它是一种内容可寻址的对等超媒体分发协议。在IPFS网络中的节点将构成一个分布式文件系统。它是一个开放源代码项目，自2014年开始由Protocol Labs在开源社区的帮助下发展。</li>
<li>LDAP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">Lightweight Directory Access Protocol</a>, 通过IP协议提供访问控制和维护分布式信息的目录信息。一个常用用途是单点登录，用户可以在多个服务中使用同一个密码，通常用于公司内部网站的登录中（这样他们可以在公司计算机上登录一次，便可以自动在公司内部网上登录）。</li>
<li>LPD, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Line_Printer_Daemon_protocol">Line Printer Daemon Protocol</a>, 一个网络打印协议提交打印作业到远程打印机</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MIME">MIME(S-MINE)</a>, Multipurpose Internet Mail Extensions and Secure MIME (多用途互联网邮件扩展)</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Modbus">Modbus</a>, 一种串行通信协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而发表。Modbus已经成为工业领域通信协议的业界标准（De facto），并且现在是工业电子设备之间常用的连接方式。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MQTT">MQTT</a> Protocol, MQTT消息队列遥测传输(Message Queuing Telemetry Transport)是ISO 标准(ISO/IEC PRF 20922)下基于发布/订阅范式的消息协议。它工作在 TCP/IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议，为此，它需要一个消息中间件。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NETCONF">Netconf</a>, 网络配置协议（NETCONF）是一种网络管理由开发和标准化协议IETF。它是在NETCONF工作组中开发的，并于2006年12月作为RFC 4741发布，后来在2011年6月进行了修订，并作为RFC 6241发布。NETCONF协议​​规范是Internet标准跟踪文档。</li>
<li>NFS, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_File_System">Network File System</a>, 网络文件系统（英语：Network File System，缩写作 NFS）是一种分布式文件系统协议，最初由Sun Microsystems公司开发，并于1984年发布。其功能旨在允许客户端主机可以像访问本地存储一样通过网络访问服务器端文件。</li>
<li>NIS, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_Information_Service">Network Information Service</a>, 网络信息服务简称 NIS（Network Information Service），时又译为网络数据服务协议，亦即一般简称之“黄页”YP（Yellow Pages），最早由昇阳公司开发出来，为一套用来管理计算机网络中所有与计算机系统管理相关之配置文件，如用户账号、密码、主机名称或组群等的主从式目录服务协议。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_layer">…</a></li>
</ul>
<h1 id="Application-Layer-Protocols"><a href="#Application-Layer-Protocols" class="headerlink" title="Application Layer Protocols"></a>Application Layer Protocols</h1><h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p>传输层安全性协议（Transport Layer Security，TLS） 及其前身安全套接层（Secure Sockets Layer，SSL）是一种加密安全协议，旨在确保计算机网络提供通信安全性。主要目标是提供数据完整性和通信隐私。SSL协议是为此目的而设计的第一个协议，TLS是其后续协议。SSL现在被认为是过时且不安全的（甚至是最新版本），IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如Google、Facebook等也以这个协议来创建安全连线，发送数据。当前已成为互联网上保密通信的工业标准。</p>
<p>SSL协议最早由Netscape于1994年推出。互联网正在发展，并且需要Web浏览器和各种TCP协议的传输安全性。SSL版本1.0从未发布，因为它存在严重的安全漏洞。SSL的第一个正式版本2.0版本于1995年推出.SSL协议的最终版本SSL 3.0于1996年11月发布。</p>
<p>2011年，互联网工程任务组（IETF）宣布弃用SSL 2.0版。IETF建议完全放弃SSL v2，因为根据他们发布的文档（RFC 6176），该协议有几个主要缺陷。这些包括使用MD5进行消息身份验证，缺乏对握手的保护，使用相同的密钥进行消息完整性和加密，以及轻松的会话终止。2015年6月，IETF还宣布弃用SSL 3.0。正如IETF发布的文件（RFC 7568），任何TLS版本都比所有版本的SSL更安全。SSL也不能使用TLS协议的功能，例如 Authenticated Encryption with Additional Data（AEAD），Elliptic Curve Diffie-Hellman（ECDH） 和 Elliptic Curve Digital Signature Algorithm（ECDSA），stateless session tickets，a datagram mode of operation（DTLS）和 application-layer protocol negotiation。</p>
<p>输层安全性（TLS）协议于1999年首次引入，作为SSL v3的升级。TLS 1.0 RFC文档（RFC 2246）文档指出TLS 1.0和SSL 3.0之间的差异并不显着，但它们足以排除互操作性。TLS 1.1（RFC 4346）是对2006年4月发布的TLS 1.0的一个小更新。此版本中的一些差异包括对 Cipher Block Chaining（CBC）攻击的保护。TLS 1.2（RFC 5246）于2008年8月发布。更改包括添加了 cipher-suite-specified psedorandom functions （PRFs），AES cipher suite，删除了 IDEA 和 DES cipher suiter 以及 其他一些增强功能。</p>
<p>当前版本的TLS，TLS 1.3于2018年8月发布（RFC 8446）。IETF花费了10年时间和28个草稿才能完成。这一次，协议经历了一些重大变化，重点是简单性。删除了一些不安全的技术，包括SHA-1，MD5，RC4，DES 和 3DES。简化了协议以获得更好的性能：握手现在只需要一次往返（在某些情况下甚至为零）。其他变化包括加密SNI信息以获得更好的隐私和新的签名标准（RSA-PSS）。所有现代浏览器都支持 TLS v1.3。</p>
<p>Web浏览器通常使用 SSL 和 TLS 来保护 Web应用程序 和 Web服务器 之间的连接。许多其他基于TCP的协议也使用 TLS/SSL，包括电子邮件（SMTP/POP3），即时消息（XMPP），FTP，VoIP，VPN等。通常，当一个服务如果使用 TLS/SSL ,就会把安全连接字母 S 被附加到协议名称后面，例如，HTTP S，SMTP S，FTP S，SIP S。在大多数情况下，SSL/TLS 实现基于OpenSSL库。</p>
<p>SSL 和 TLS 是使用许多 <a target="_blank" rel="noopener" href="https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/">不同加密算法</a> 的框架，例如 RSA 和各种 Diffie-Hellman 算法。双方协商在初始通信期间使用哪种算法。最新的TLS版本（TLS 1.3）在IETF（Internet工程任务组）文档RFC 8446中指定，最新的SSL版本（SSL 3.0）在IETF文档RFC 6101中指定。</p>
<p>TLS协议主要旨在提供两个或更多通信计算机应用程序之间的隐私和数据完整性。当通过TLS保护时，客户端（例如，Web浏览器）和服务器（例如，wikipedia.org）之间的连接应具有以下一个或多个属性：</p>
<ul>
<li>连接是私有的（或安全的），因为 symmetric cryptography(对称加密) 用于加密传输的数据。键是 symmetric cryptography 针对每个连接唯一生成的，并根据 share secret 在开始协商会话（见 TLS 握手）。服务器和客户端在传输数据的第一个字节之前要协商使用的加密算法和加密密钥的详细信息（参见 Algorithm ）。share secret 的协商是安全的（窃听者无法获得协商的秘密,并且即使是将自己置于连接中间的攻击者也无法获得)且可靠的（攻击者无法在未经检测到的情况下修改协商期间的通信）。</li>
<li>可以使用公钥加密来验证通信方的身份。该认证可以是可选的，但通常需要至少一方（通常是服务器）。</li>
<li>连接是可靠的，因为每个传输的消息都包括使用消息验证码进行的消息完整性检查，以防止在传输过程中出现未检测到丢失或更改数据。</li>
</ul>
<p>除了上述属性之外，详细配置 TLS 还可以提供其他与隐私相关的属性，例如 forward secrecy ，确保未来任何泄露的加密密钥都不能用于解密过去记录的任何TLS通信。</p>
<p>SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密算法来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p>
<p>TLS协议包括：TLS record 和 TLS handshake protocols。</p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>TLS/SSL 协议允许加密两个介质（客户端 - 服务器）之间的连接。加密可以确保没有第三方能够读取数据或篡改数据。未加密的通信可能会暴露敏感数据，如用户名，密码，信用卡号等。如果我们使用未加密的连接并且第三方拦截我们与服务器的连接，他们可以看到以纯文本形式交换的所有信息。例如，如果我们访问没有SSL的网站管理面板，并且攻击者正在嗅探本地网络流量，他们会看到以下信息。</p>
<p><img src="/img/TSL-SSL/image32.png" alt="gcheap"></p>
<p>我们用于在我们网站上进行身份验证的cookie以纯文本形式发送，任何拦截连接的人都可以看到它。攻击者可以使用此信息登录我们的网站管理面板。从那时起，攻击者的选择范围急剧扩大。但是，如果我们使用 TLS/SSL 访问网站，那么嗅探流量的攻击者会看到一些完全不同的东西。</p>
<p><img src="/img/TSL-SSL/image04-1.png" alt="gcheap"></p>
<p>这种情况下，该信息对攻击者无用。</p>
<p>TLS/SSL 协议使用公钥加密。除加密外，此技术还用于验证通信方。这意味着，一方或双方确切地知道他们正在与谁沟通。这对于在线交易等应用程序至关重要，因为必须确保将资金转移给他们声称的人或公司。</p>
<p>建立安全连接后，服务器会将其 TSL/SSL 证书发送给客户端。然后，客户端针对可信证书颁发机构检查证书，验证服务器的身份。这样的证书不能被伪造，因此客户可能百分之百确定他们正在与正确的服务器进行通信。</p>
<p>Perfect forward security（PFS）是一种机制，用于在服务器的私钥被泄露时保护客户端。由于PFS，攻击者无法解密任何先前的TLS通信。为了确保完美的 forward security ，我们为每个会话使用新密钥。只要会话处于活动状态，这些密钥就有效。</p>
<p>由于应用程序可以使用或不使用TLS(或SSL)进行通信，因此客户端有必要向服务器表明 TLS 连接的设置。实现此目的的主要方法之一是为TLS连接使用不同的端口号，例如HTTPS的端口443。另一种机制是客户端向服务器发出特定于协议的请求，将连接切换到TLS;例如，在使用邮件和新闻协议时发出 STARTTLS 请求。</p>
<p>一旦客户端和服务器同意使用TLS，它们就通过 handshaking(握手) 过程协商有状态连接。协议使用与非对称密码的握手，不仅建立密码设置，而且建立特定于会话的共享密钥，使用对称密码对进一步的通信进行加密。在这个握手过程中，客户端和服务器就用于建立连接安全性的各种参数达成一致:</p>
<ul>
<li>当客户端连接到启用TLS的服务器请求安全连接并且客户端提供受支持的密码套件列表（密码和散列函数）时，握手开始。</li>
<li>从该列表中，服务器选择它也支持的密码和散列函数，并通知客户端该决定。</li>
<li>然后，服务器通常以数字证书的形式提供标识。证书包含服务器名称，证明证书真实性的可信证书颁发机构（CA）以及服务器的公共加密密钥。</li>
<li>客户在继续之前确认证书的有效性。</li>
<li>要生成用于安全连接的会话密钥，客户端要么：<ul>
<li>使用服务器的公钥加密随机数，并将结果发送到服务器（只有服务器能够使用其私钥解密）; 然后，双方使用随机数生成唯一的会话密钥，用于在会话期间对数据进行后续加密和解密</li>
<li>使用Diffie-Hellman密钥交换来安全地生成用于加密和解密的随机且唯一的会话密钥，该密钥具有前向保密的附加属性：如果将来公开服务器的私钥，则它不能用于解密当前会话，即使会话被第三方截获并记录。</li>
</ul>
</li>
</ul>
<h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><h4 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h4><p>Encryption(加密) 是将人类可读消息（明文）转换为加密的非人类可读格式（密文）的过程。加密的主要目的是确保只有授权的收件人才能解密和读取原始邮件。当双方之间使用任何媒体交换未加密的数据时，第三方可以拦截并读取所交换的通信。</p>
<p>如果交换包含敏感信息，则意味着失去机密性。此外，如果第三方可以拦截和读取消息，他们可以篡改数据。这意味着他们可以更改正在交换的信息，因此会破坏邮件的完整性。</p>
<p>想象一下，使用未加密的Web浏览器连接发送付款。付款包括您的银行帐户详细信息以及您授权的金额。攻击者可以使用中间人攻击来篡改发送到Web服务器的信息，并将金额从100美元更改为10,000美元。银行接收来自第三方而非您的篡改数据，这意味着没有真实性。如果您使用加密的安全会话，攻击者可能仍然能够拦截流量，但他们将无法读取数据或篡改数据。</p>
<p><img src="/img/TSL-SSL/terminology-encryption.png" alt="gcheap"></p>
<h4 id="Symmetric-Encryption"><a href="#Symmetric-Encryption" class="headerlink" title="Symmetric Encryption"></a>Symmetric Encryption</h4><p>Symmetric Encryption(对称加密) 是使用相同密钥加密和解密数据的过程。如果Thomas想要向Bob发送信息，他将使用共享密钥加密数据，Bob将使用相同的密钥解密数据。</p>
<p><img src="/img/TSL-SSL/terminology-symmetric_encryption.png" alt="gcheap"></p>
<p>对称密钥加密的最大问题是交换数据的双方必须具有共享密钥。如果公开该共享密钥，攻击者将能够解密使用该密钥加密的所有通信。这就是为什么共享密钥必须使用已经建立的，安全的加密通信信道在各方之间分配的原因。对称加密的另一个缺点是您无法验证邮件的发件人，这会损害真实性。</p>
<p>对称加密的优点：</p>
<ul>
<li>快速，低资源使用</li>
<li>操作简单</li>
<li>安全</li>
</ul>
<p>对称加密的缺点：</p>
<ul>
<li>用于加密/解密的相同密钥</li>
<li>密钥必须使用已建立的安全通道进行分发</li>
<li>不同方的不同关键密钥 - 密钥管理/分配困难</li>
<li>无法验证用户身份</li>
</ul>
<h4 id="Asymmetric-Encryption"><a href="#Asymmetric-Encryption" class="headerlink" title="Asymmetric Encryption"></a>Asymmetric Encryption</h4><p>Asymmetric Encryption(非对称加密,也称为 Public Key Cryptography 公钥加密)使用密钥对：公钥和私钥。这些加密密钥是唯一相关的。这意味着使用密钥对中的一个密钥加密的内容只能使用另一个密钥进行解密。顾名思义，公钥可以与任何人共享。私钥必须仅为所有者所知。</p>
<p><img src="/img/TSL-SSL/terminology-asymmetric_encryption.png" alt="gcheap"></p>
<p>还可以使用非对称加密通过签名对发件人进行身份验证。如果Bob使用他的私钥签署消息，那么使用Bob的公钥验证签名的人可以确定Bob是发送者。</p>
<p>非对称加密的优点：</p>
<ul>
<li>密钥分发很容易</li>
<li>真实性</li>
<li>公正</li>
<li>安全</li>
</ul>
<p>非对称加密的缺点：</p>
<ul>
<li>比对称加密慢</li>
<li>需要更多资源</li>
</ul>
<h4 id="Ciphers"><a href="#Ciphers" class="headerlink" title="Ciphers"></a>Ciphers</h4><p>Ciphers(密码)是用于加密和解密数据的方法/算法。TLS是一种允许使用许多不同方法/算法的协议。它们提供称为 cipher suites(密码套件)的包。这样的包对于每个任务具有不同的方法/算法。</p>
<h4 id="Block-Ciphers"><a href="#Block-Ciphers" class="headerlink" title="Block Ciphers"></a>Block Ciphers</h4><p>如果使用 Block Ciphers(分组密码)，则将数据分成固定长度的块（例如64位或128位块），然后进行加密。如果最后一个数据块短于指定的块长度，则算法使用填充来填充空白空间。通常使用随机数据填充块。流行的分组密码包括 AES，Blowfish，3DES，DES 和 RC5。</p>
<h4 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h4><p>分组密码具有指定的固定长度，并且大多数密码要求输入数据是其大小的倍数。最后一个块通常包含不符合此要求的数据。在这种情况下，Padding(填充,通常是随机数据)用于使其达到所需的块长度。</p>
<h4 id="Initialization-Vector-IV"><a href="#Initialization-Vector-IV" class="headerlink" title="Initialization Vector (IV)"></a>Initialization Vector (IV)</h4><p>Initialization Vector(初始化向量) 是加密方法中使用的随机（或伪随机）固定大小的输入。IV的主要目的是启动加密方法。在诸如Cipher Block Chainning（CBC,密码块链接）的密码模式中，每个块与前一个块进行异或(XOR-ed)。在第一个块中，没有先前的块与异或。则初始化向量用作第一个块的输入以开始该过程。</p>
<p>如果IV对于每条消息都是唯一的，则称为 nonce，这意味着它只能使用一次。随机数应该是不可预测的。它还用于防止攻击者通过猜测IV来解密所有消息。如果使用随机数，则可以使用相同的密钥将相同的明文加密成不同的密文。</p>
<h4 id="Block-Cipher-Operation-Modes"><a href="#Block-Cipher-Operation-Modes" class="headerlink" title="Block Cipher Operation Modes"></a>Block Cipher Operation Modes</h4><p>Block Cipher Operation Modes(分组密码操作模式) 定义使用密码编码的块之间的关系。创建了不同的模式以使攻击者更难以猜测消息的原始内容。</p>
<h4 id="Electronic-Code-Book-ECB"><a href="#Electronic-Code-Book-ECB" class="headerlink" title="Electronic Code Book (ECB)"></a>Electronic Code Book (ECB)</h4><p>使用ECB时，每个数据块都是单独加密的，然后按原始顺序连接起来。由于块不相互依赖，因此可以进行并行处理。没有必要进行IV。ECB的主要问题是如果相同的数据块被加密，它将始终生成相同的密文。这使攻击者更容易根据重复模式猜测原始数据。</p>
<p><img src="/img/TSL-SSL/terminology-ECB.png" alt="gcheap"></p>
<h4 id="Cipher-Block-Chainning-CBC"><a href="#Cipher-Block-Chainning-CBC" class="headerlink" title="Cipher Block Chainning (CBC)"></a>Cipher Block Chainning (CBC)</h4><p>使用CBC时，每个块在加密前与先前的密文进行异或(XOR-ed)。这消除了重复图案的问题。需要IV来加密第一个明文块。由于块是链接的，因此不可能进行并行处理。CBC有一个主要缺点：如果消息的一部分出现乱码或丢失，则消息的其余部分将丢失。</p>
<p><img src="/img/TSL-SSL/terminology-CBC.png" alt="gcheap"></p>
<h4 id="Cipher-Feedback-CFB"><a href="#Cipher-Feedback-CFB" class="headerlink" title="Cipher Feedback (CFB)"></a>Cipher Feedback (CFB)</h4><p>CFB方法将块密码转换为 self-synchronizing stream cipher(自同步流密码)。这意味着如果消息的一部分是乱码或丢失，则密码可以在几个块之后同步，并且消息的其余部分不一定丢失。</p>
<p><img src="/img/TSL-SSL/terminology-CFB.png" alt="gcheap"></p>
<h4 id="Output-Feedback-OFB"><a href="#Output-Feedback-OFB" class="headerlink" title="Output Feedback (OFB)"></a>Output Feedback (OFB)</h4><p>OFB方法创建 synchronous stream cipher(同步流密码)。该技术保留了纠错码。加密和解密过程完全相同。</p>
<p><img src="/img/TSL-SSL/terminology-OFB.png" alt="gcheap"></p>
<h4 id="Counter-Mode-CTR"><a href="#Counter-Mode-CTR" class="headerlink" title="Counter Mode (CTR)"></a>Counter Mode (CTR)</h4><p>CTR方法类似于OFB，因为它还创建了一个 synchronous stream cipher(同步流密码)。但是，它为每个块使用 counter 和 nonce，并且不将块链接在一起。因此，可以并行加密和解密块。</p>
<p><img src="/img/TSL-SSL/terminology-CTR.png" alt="gcheap"></p>
<h4 id="Stream-Ciphers"><a href="#Stream-Ciphers" class="headerlink" title="Stream Ciphers"></a>Stream Ciphers</h4><p>Stream Ciphers(流密码) 每次只加密一位或一个字节的数据。每一位都用不同的密钥加密。在现代密码术中不经常使用流密码。流密码的一个流行示例是 RC4 cipher。</p>
<h4 id="Message-Authentication-Code-MAC"><a href="#Message-Authentication-Code-MAC" class="headerlink" title="Message Authentication Code (MAC)"></a>Message Authentication Code (MAC)</h4><p>Message Authentication Code(MAC,消息认证码) 是一种用于检查消息的真实性和完整性的方法。它接受两个输入参数：密钥和任意长度的消息。结果称为 tag(标签)。收件人还具有密钥，可以使用它来检测邮件内容的任何更改。MAC有时称为 checksum(校验和)， cyptographic checksum(加密校验和) 或 protected checksum(受保护的校验和)。</p>
<p><img src="/img/TSL-SSL/terminology-MAC.png" alt="gcheap"></p>
<p>如果发件人的MAC标记与收件人的计算MAC标记匹配，则没有人篡改该消息。如果它们不匹配，则有人在传输过程中更改了消息。</p>
<h4 id="Hash-Based-Message-Authtication-Code-HMAC"><a href="#Hash-Based-Message-Authtication-Code-HMAC" class="headerlink" title="Hash-Based Message Authtication Code (HMAC)"></a>Hash-Based Message Authtication Code (HMAC)</h4><p>HMAC是一种使用散列函数的MAC。以下是使用SHA256哈希算法的HMAC示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMAC_SHA256(&quot;s3cr3tk3y&quot;,&quot;Hello World&quot;) = 2d9615ee921dab63c7c4c839842703fe338db46fdf17593a681bcee2c52721de</span><br></pre></td></tr></table></figure>

<p>下图显示了HMAC功能的工作原理：</p>
<p><img src="/img/TSL-SSL/terminology-HMAC.png" alt="gcheap"></p>
<h3 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h3><h4 id="Certificates-Authorities"><a href="#Certificates-Authorities" class="headerlink" title="Certificates Authorities"></a>Certificates Authorities</h4><p>如果您访问银行的网站并收到由其他实体签名的证书，您可能仍会对网站安全性感到不确定。您可能会担心签署证书的实体是冒名顶替者。公钥基础结构（PKI）解决了这个问题。PKI包括管理数字证书和公钥加密所需的一切。</p>
<p>您可以信任几个PKI实体。它们被称为 Certificates Authorities (CAs, 证书颁发机构)。他们验证其他实体（公司，组织，个人）并确认他们确实是他们所说的人。经过此类验证，CA会使用自己的证书对证书进行签名。CA的证书称为 root certificate(根证书)。</p>
<p>所有CA的 root certificate （以及它们的公钥）都被认为是可信的。它们安装在Chrome，Firefox和Edge等所有浏览器中以及操作系统（包括Windows）中。流行的CA包括IdenTrust，Comodo，DigiCert，GoDaddy，GlobalSign和Symantec。目前有超过200个根证书受到浏览器的信任。</p>
<p>TLS/SSL Web连接需要 TLS/SSL 证书，但该证书可由任何人签名。它甚至可以自签名（由创建证书的实体签名）。访问使用 TLS/SSL 保护的网站时，浏览器会通过检查该网站是否由受信任的根证书签名来检查该网站是否具有有效证书。它还会检查证书是否适用于您正在访问的域，并显示有关证书所有者的信息以供您验证。如果证书未由受信任的根证书签名，则Web浏览器会显示明确的警告。您通常可以选择忽略警告（取决于Web浏览器设置），但您不能错过它。</p>
<h4 id="Secure-Browsing"><a href="#Secure-Browsing" class="headerlink" title="Secure Browsing"></a>Secure Browsing</h4><p>容易识别网站是否具有有效证书以及您是否使用安全连接。您需要做的就是查看地址栏（类似于所有主流浏览器）</p>
<p><img src="/img/TSL-SSL/certificates-secure_browsing.png" alt="gchesp"></p>
<p>绿色锁和HTTPS协议（ https:// ）表示与Web服务器的连接是加密且安全的。</p>
<h4 id="Insecure-Browsing"><a href="#Insecure-Browsing" class="headerlink" title="Insecure Browsing"></a>Insecure Browsing</h4><p>识别非安全网站也很容易。没有绿色锁，也没有提到HTTPS。</p>
<p><img src="/img/TSL-SSL/certificates-insecure_browsing1.png" alt="gcheap"></p>
<p>但是，有些网站使用HTTP来传递部分内容，例如图像。在这种情况下，您将看到类似于此消息的消息：</p>
<p><img src="/img/TSL-SSL/certificates-insecure_browsing2.png" alt="gcheap"></p>
<p>仅部分受保护的内容称为混合内容。混合内容违背了安全连接的目的。当您从登录的网站请求文件时，Web浏览器会自动发送您的身份验证Cookie以及请求。</p>
<p>因此，如果使用HTTP加载资源，则会通过非加密连接发送您的请求。如果攻击者正在嗅探网络，他们就能以明文形式看到此请求。这会危及会话的安全性，因为攻击者使用cookie登录网站并冒充您。因此，您应该像处理未加密的网站一样处理混合内容的网站。</p>
<h4 id="Type-of-TLS-SSL-Certificates"><a href="#Type-of-TLS-SSL-Certificates" class="headerlink" title="Type of TLS/SSL Certificates"></a>Type of TLS/SSL Certificates</h4><p>TLS/SSL 证书有不同的版本。从技术角度来看，它们可以分为三组，具体取决于它们适用的域的范围。</p>
<h5 id="Sigle-Domain"><a href="#Sigle-Domain" class="headerlink" title="Sigle-Domain"></a>Sigle-Domain</h5><p>此类证书仅适用于一个主机名（Full Qualified Domain Name, 完全限定域名 - FQDN）或子域。例如，您可能会获得<a target="_blank" rel="noopener" href="http://www.example.com或my.example.com的证书.但是,mail.example.com不会包含在此证书的范围内.证书仅对您在注册期间指定的一个主机名有效./">www.example.com或my.example.com的证书。但是，mail.example.com不会包含在此证书的范围内。证书仅对您在注册期间指定的一个主机名有效。</a></p>
<h5 id="Wildcard"><a href="#Wildcard" class="headerlink" title="Wildcard"></a>Wildcard</h5><p>此类证书适用于包含其所有子域的整个域。例如，如果您注册 *.example.com， 则证书将应用于 mail.example.com， secret.example.com， admin.example.com和所有其他子域。只要域相同，您就可以在不同服务器上托管每个子域，并在多个服务器上使用相同的通配符 TLS/SSL 证书。</p>
<h5 id="Muti-Domain"><a href="#Muti-Domain" class="headerlink" title="Muti-Domain"></a>Muti-Domain</h5><p>此类证书适用于多个不同的域名。每个域名可以是 Single-Domain 或 Wildcard 。通常，当您获得此类证书时，您可以随时更改域名。此类证书通常也称为 Subject Alternative Name(SAN,主题备用名称) 证书。</p>
<h4 id="TLS-SSL-Certificates-Validation"><a href="#TLS-SSL-Certificates-Validation" class="headerlink" title="TLS/SSL Certificates Validation"></a>TLS/SSL Certificates Validation</h4><p>从身份验证的角度来看，TLS/SSL 证书也有不同的版本。身份验证越多，证书越可信，但获取证书所需的时间越多。</p>
<h5 id="Domain-Validation"><a href="#Domain-Validation" class="headerlink" title="Domain Validation"></a>Domain Validation</h5><p>域验证证书仅确认申请证书的人是域名的所有者（或至少可以访问域名）。这种验证通常只需要几分钟到几个小时。</p>
<h5 id="Organization-Validation"><a href="#Organization-Validation" class="headerlink" title="Organization Validation"></a>Organization Validation</h5><p>Certification Authority（CA）不仅验证域名所有权，还验证所有者的身份。这意味着可能会要求所有者提供证明其身份的个人信息和身份证明文件。此类验证可能需要几天时间。</p>
<h5 id="Extended-Validation"><a href="#Extended-Validation" class="headerlink" title="Extended Validation"></a>Extended Validation</h5><p>这是最高级别的验证。它包括域名所有权和所有者身份的验证，但它也要求企业提供合法注册证明。</p>
<h4 id="Certification-Generation"><a href="#Certification-Generation" class="headerlink" title="Certification Generation"></a>Certification Generation</h4><p>如果要从证书颁发机构申请证书，则需要生成 Certificate Signing Request(CSR,证书签名请求)。首先，创建一个用于解密证书的私钥。然后，生成CSR。生成CSR时，系统会要求您指定域名以及有关您组织的详细信息，例如姓名，国家/地区和电子邮件。以下是CSR的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE REQUEST-----</span><br><span class="line">MIICtzCCAZ8CAQAwUTELMAkGA1UEBhMCQ1kxCjAIBgNVBAgMAWExCzAJBgNVBAcM</span><br><span class="line">Ak1lMQowCAYDVQQKDAFhMQowCAYDVQQLDAFhMREwDwYDVQQDDAh0ZXN0LmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKvFkdX1qwMNu0i0GHW/lotRKYM0I3yvHQmeS5DtYqmnMGsIZaUO7qv+z8CW4cIIqZhR/hlXEsh+ARM/po37OjzzSDo1U7gyKciSf2s+JsuLmlrHoZPto+/4uWgp9xyQW177/MvWtOVejaUnzrjmPnE0</span><br><span class="line">AT9KAZ3w+2uwjrhJG5w52psENUT+tTOMlDgIVlKSbZcvD5bS/X7RvfsOS3Q/y9wG</span><br><span class="line">Q53rbZqK19y5CtM808wGOQhrNfp3M1EA6+m7RRO1Yw2Rp+wLY0aA9UzjzImaL5Sr</span><br><span class="line">/job1EoJWzKClY20GXB6HKn+wJ/n4sz725bF6l6r4yoBY1f4gYBn3QW+sQXLrDsC</span><br><span class="line">AwEAAaAhMB8GCSqGSIb3DQEJBzESDBBkZmpoZ2tqaGpoZGZramhnMA0GCSqGSIb3</span><br><span class="line">DQEBCwUAA4IBAQCFQ7/R+/ioSj7X4gs+GBbDHEcnJHshwoX9vVBDYvOoQ56iER7f</span><br><span class="line">cEtja18yeXu3PNyeOoDLSYd0FhM16XKLlJ0llIy46Vb8RMdS4JNEx2yob3W/bIAS</span><br><span class="line">z2n+p58zp2/Gp7gG2LtH+RwcvRGRGdKhrsU8D+fHGHpSGvGJg++IhS2HZvTs5pkD</span><br><span class="line">3AwMpDojVYtWuJteDVHGc4PH5TeJot7+6lGetkhq1uRhD4KjJDY5KUvCNQIjeoaL</span><br><span class="line">eFf/xGp6JGNE5taK2liBs+QlgLZc8Sm7fTYCi0YXAsEhMm9HjbXX28Ou6zTroDP3</span><br><span class="line">elT3tN9pd1aG6ujGjkrM6T8JiVWxqYFEnFqd</span><br><span class="line">-----END CERTIFICATE REQUEST-----</span><br></pre></td></tr></table></figure>

<p>生成CSR后，必须将其提交给CA. 证书准备就绪后，CA通常会将其作为 *.crt 文件发送到您的电子邮件地址。您必须在服务器上安装此文件。</p>
<h3 id="Establishing-a-TLS-Connection"><a href="#Establishing-a-TLS-Connection" class="headerlink" title="Establishing a TLS Connection"></a>Establishing a TLS Connection</h3><p>建立安全 TLS/SSL 连接的过程涉及几个步骤。TLS/SSL 安全协议使用非对称和对称加密的组合。客户端和服务器必须协商使用的算法并交换密钥信息。</p>
<p>为了解释这个复杂的过程，我们使用TLS 1.2连接，而不是最新的TLS 1.3协议。对于所有先前版本的TLS/SSL，TLS 1.2中使用的过程几乎相同。但是，最新版本的传输层安全性大大简化了它。</p>
<p>建立安全连接最重要的部分称为 handshake(握手)。在TLS握手期间，服务器和客户端交换用于确定连接属性的重要信息。此示例基于Web浏览器握手，但这同样适用于所有其他 TLS/SSL 握手。</p>
<h4 id="Step-1-Client-Hello-Client-Server"><a href="#Step-1-Client-Hello-Client-Server" class="headerlink" title="Step 1:Client Hello (Client - Server)"></a>Step 1:Client Hello (Client - Server)</h4><p><img src="/img/TSL-SSL/tlsConnection-step1.png" alt="gcheap"></p>
<p>首先，客户端向服务器发送客户端Hello。Client Hello包含以下信息。</p>
<p><strong>Client Version</strong></p>
<p>客户端发送它支持的所有 TLS/SSL 协议版本的列表，首选列表中的首选版本通常是最新版本。例如，TL​​S 1.2有一个client_version 3,3。这是因为TLS 1.0被视为 Secure Sockets Layer（SSL 3.0）的次要修订版，因此 TLS 1.0 为 3.1，TLS 1.1 为 3.2，依此类推。</p>
<p><strong>Client Random</strong></p>
<p>客户端和服务器随机生成一个32字节的随机数用于后来生成加密密钥。</p>
<p>原始的TLS 1.2规范中，前4个字节应该表示客户端的当前日期和时间（以纪元格式），其余28个字节应该是随机生成的数字。但是，IETF后来建议不使用这个格式。</p>
<p><strong>Session ID</strong></p>
<p>这是用于连接的 Session ID。如果session_id不为空，则服务器搜索先前缓存的会话，并在找到匹配时恢复该会话。</p>
<p><strong>compression_methods</strong></p>
<p>这是将用于 compression(压缩) SSL 数据包的方法。通过使用压缩，我们可以实现更低的带宽使用率，从而提高传输速度。但是使用压缩是有风险的。</p>
<p><strong>Cipher Suites</strong></p>
<p>Cipher Suites 是加密算法的组合。通常，每个 Cipher Suites 都包含一个用于以下任务的加密算法： key exchange(密钥交换)， authentication(身份验证)， bulk encryption (批量数据加密) 和 message authentication(消息身份验证)。客户端按先后顺序发送它支持的所有 Cipher Suites 的列表。这意味着客户端更希望使用发送的第一个 Cipher Suites 建立连接。</p>
<p>Cipger Suites 由字符串标识。示例 Cipher Suites 字符串：</p>
<p>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</p>
<p>该字符串包含以下信息：</p>
<ul>
<li>正在使用的协议是TLS</li>
<li>密钥交换算法是ECDHE（Elliptic Curve Diffie-Hellman）</li>
<li>认证算法是ECDSA（Elliptic Curve Digital Signature Alogrithm）</li>
<li>数据加密算法是AES_128_GCM（Advanced Encryption Standard 128 bit Galois/Counter Mode）</li>
<li>消息验证码（Message Authentication Code,MAC）算法是SHA256（Secure Hash Alogrithm 256 bit）</li>
</ul>
<p><strong>Compression Methods</strong></p>
<p>这是一个用于 Compression(压缩数据) 的方法列表（在加密之前）。如果使用压缩，则可以降低带宽使用率并加快传输速度。但是，压缩是有风险的，建议不要：详情查看下面的 <a href="#CRIME_and_BREACH_attacks">CRIME and BREACH attacks</a>。</p>
<p><strong>Extensions</strong></p>
<p>客户端可以请求连接的其他功能。这可以通过 Extensions(扩展) 来完成，例如 supported groups for elliptic curve cryptography， point formats for elliptic curve cryptography， signature 等。如果服务器无法提供附加功能，则客户端可以在需要时中止握手。</p>
<p>以下是Wireshark捕获中实际的Client Hello的样子。</p>
<p><img src="/img/TSL-SSL/tlsConnection-step1-wireshark.png" alt="gcheap"></p>
<h4 id="Step-2-Server-Hello-Server-Client"><a href="#Step-2-Server-Hello-Server-Client" class="headerlink" title="Step 2:Server Hello (Server - Client)"></a>Step 2:Server Hello (Server - Client)</h4><p>在服务器接收到客户端Hello之后，它将使用服务器Hello进行响应。服务器Hello可以包含选定的选项(从客户端Hello期间建议的选项中选择)，也可以是握手失败消息。一般包含以下内容：</p>
<p><strong>Server Version</strong></p>
<p>服务器从客户端的提供信息中选择 TLS/SSL 协议的首选版本。</p>
<p><strong>Server Random</strong></p>
<p>客户端和服务器随机生成一个32字节的随机数用于后来生成加密密钥。</p>
<p>原始的TLS 1.2规范中，前4个字节应该表示客户端的当前日期和时间（以纪元格式），其余28个字节应该是随机生成的数字。但是，IETF后来建议不使用这个格式。</p>
<p><strong>Session ID</strong></p>
<p>如果客户端 Seesion ID 不为空，则服务器搜索先前缓存的 Session ，如果找到匹配，则使用该 Session ID恢复 Session。如果客户端 Session ID为空，则服务器可以创建一个新 Session 并将其发送到服务器 Session ID中。</p>
<p><strong>Cipher Suites</strong></p>
<p>服务器从Client Hello中发送的 Cipher Suites 中选择 Cipher Suites。</p>
<p><strong>Compression Methods</strong></p>
<p>服务器从Client Hello中发送的压缩方法里中选择压缩方法。</p>
<h4 id="Step-3-Server-Certificate-Server-Client"><a href="#Step-3-Server-Certificate-Server-Client" class="headerlink" title="Step 3:Server Certificate (Server - Client)"></a>Step 3:Server Certificate (Server - Client)</h4><p>服务器发送签名的 TLS/SSL 证书，证明其身份给客户端。它还包含服务器的公钥。</p>
<h4 id="Step-4-Client-Certificate-Client-Server-Optional"><a href="#Step-4-Client-Certificate-Client-Server-Optional" class="headerlink" title="Step 4:Client Certificate (Client - Server,Optional)"></a>Step 4:Client Certificate (Client - Server,Optional)</h4><p>在极少数情况下，服务器可能要求客户端使用客户端证书进行身份验证。如果是，则客户端将其签名证书提供给服务器。</p>
<h4 id="Step-5-Server-Key-Exchange-Server-Client"><a href="#Step-5-Server-Key-Exchange-Server-Client" class="headerlink" title="Step 5:Server Key Exchange (Server - Client)"></a>Step 5:Server Key Exchange (Server - Client)</h4><p>仅当服务器提供的证书不足以使客户端交换 pre-master sercet 时，才发送服务器密钥交换消息。 （这适用于 DHE_DSS， DHE_RSA和 DH_anon）。</p>
<h4 id="Step-6-Server-Hello-Done-Server-Client"><a href="#Step-6-Server-Hello-Done-Server-Client" class="headerlink" title="Step 6:Server Hello Done (Server - Client)"></a>Step 6:Server Hello Done (Server - Client)</h4><p>服务器将此发送到客户端以确认服务器Hello消息已完成。</p>
<p>Wireshark捕获中的服务器Hello看起来是这样子。</p>
<p><img src="/img/TSL-SSL/tlsConnection-step6.png" alt="gcheap"></p>
<h4 id="Step-7-Client-Key-Exchange-Server-Client"><a href="#Step-7-Client-Key-Exchange-Server-Client" class="headerlink" title="Step 7:Client Key Exchange (Server - Client)"></a>Step 7:Client Key Exchange (Server - Client)</h4><p>从服务器收到服务器Hello Done后立即发送客户端密钥交换消息。如果服务器请求客户端证书，则在此之后发送客户端密钥交换。在此阶段，客户端创建 pre-master key。</p>
<p><strong>Pre-Master Sercet</strong></p>
<p>Pre-Master Sercet 由客户端创建（创建方法取决于 cipher suites），然后与服务器共享。</p>
<p>在将 Pre-Master Sercet 发送到服务器之前，客户端使用从服务器提供的证书中提取的服务器公钥对其进行加密。这意味着只有服务器才能解密消息，因为非对称加密（密钥对）用于 pre-master sercet 交换。</p>
<p>这就是Wireshark捕获中的密钥交换（使用Diffie-Hellman）。</p>
<p><img src="/img/TSL-SSL/tlsConnection-step7.png" alt="gcheap"></p>
<p><strong>Master Sercet</strong></p>
<p>服务器接收到 pre-master sercet key 后，使用其私钥对其解密。现在，客户机和服务器使用伪随机函数(PRF)根据前面交换的随机值(客户机随机值和服务器随机值)计算主密钥。PRF是一个函数，用于生成任意数量的伪随机数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;, ClientHello.random + ServerHello.random) [0..47];</span><br></pre></td></tr></table></figure>

<p>然后，客户端和服务器将使用长度为48字节的主密钥对对称地加密用于剩余通信的数据。</p>
<p>客户端和服务器各创建一组3个密钥：</p>
<ul>
<li>client_write_MAC_key: Authentication and Integrity check(身份验证和完整性检查)</li>
<li>server_write_MAC_key: Authentication and Integrity check(身份验证和完整性检查)</li>
<li>client_write_key: Message encryption using symmetric key(使用对称密钥进行消息加密)</li>
<li>server_write_key: Message encryption using symmetric key(使用对称密钥进行消息加密)</li>
<li>client_write_IV: Initialization Vector used by some AHEAD ciphers(一些前置密码使用的初始化向量)</li>
<li>server_write_IV: Initialization Vector used by some AHEAD ciphers(一些前置密码使用的初始化向量)</li>
</ul>
<p>客户端和服务器都将使用 master sercet 生成将加密/解密数据的 session keys。</p>
<h4 id="Step-8-Client-Change-Cipher-Spec-Client-Server"><a href="#Step-8-Client-Change-Cipher-Spec-Client-Server" class="headerlink" title="Step 8:Client Change Cipher Spec (Client - Server)"></a>Step 8:Client Change Cipher Spec (Client - Server)</h4><p>此时，客户端已准备好切换到安全的加密环境。 Change Cipher Spec 协议用于更改加密。客户端从现在开始发送的任何数据都将使用对称共享密钥进行加密。</p>
<p>这是Change Cipher Spec在Wireshark捕获中的样子。</p>
<p><img src="/img/TSL-SSL/tlsConnection-step8.png" alt="gcheap"></p>
<h4 id="Step-9-Client-Handshake-Finished-Client-Server"><a href="#Step-9-Client-Handshake-Finished-Client-Server" class="headerlink" title="Step 9:Client Handshake Finished (Client - Server)"></a>Step 9:Client Handshake Finished (Client - Server)</h4><p>来自客户端的握手过程的最后一条消息表示握手已完成。这也是安全连接的第一个加密消息。</p>
<p><img src="/img/TSL-SSL/tlsConnection-step9.png" alt="gcheap"></p>
<h4 id="Step-10-Server-Change-Cipher-Spec-Server-Client"><a href="#Step-10-Server-Change-Cipher-Spec-Server-Client" class="headerlink" title="Step 10:Server Change Cipher Spec (Server - Client)"></a>Step 10:Server Change Cipher Spec (Server - Client)</h4><p>服务器也准备切换到加密环境。服务器从现在开始发送的任何数据都将使用对称共享密钥进行加密。</p>
<h4 id="Step-11-Server-Handshake-Finished-Server-Client"><a href="#Step-11-Server-Handshake-Finished-Server-Client" class="headerlink" title="Step 11:Server Handshake Finished (Server - Client)"></a>Step 11:Server Handshake Finished (Server - Client)</h4><p>来自服务器的握手过程的最后一条消息（已加密发送）表示握手已完成。</p>
<p><img src="/img/TSL-SSL/tlsConnection-step11_1.png" alt="gcheap"></p>
<p>回顾一下，以下说明了典型的握手</p>
<p><img src="/img/TSL-SSL/tlsConnection-step11_2.png" alt="gcheap"></p>
<h3 id="The-TLS-Handshake-in-TLS-1-3"><a href="#The-TLS-Handshake-in-TLS-1-3" class="headerlink" title="The TLS Handshake in TLS 1.3"></a>The TLS Handshake in TLS 1.3</h3><p>在TLS 1.2及更早版本中，TLS握手需要完成两次往返。第一次往返是交换hellos，第二次是密钥交换和更改密码规范。在TLS 1.3中，这个过程简化了，只需要往返一次。 TLS 1.3也不再支持 TLS Compression(压缩)</p>
<p><img src="/img/TSL-SSL/tlsConnection-tls13_handshake.png" alt="gcheap"></p>
<p>在TLS 1.3中，当客户端发送hello时，它会立即自动判断处服务器最有可能选择的密钥协商协议。同时，它使用判断出的协议共享其密钥。服务器的hello消息还包含共享密钥，证书和服务器完成消息。不需要密码更改，因为在交换了hellos之后，双方已经拥有加密通信所需的全部内容。</p>
<h3 id="TLS-Vulnerabilitis-and-Attacks"><a href="#TLS-Vulnerabilitis-and-Attacks" class="headerlink" title="TLS Vulnerabilitis and Attacks"></a>TLS Vulnerabilitis and Attacks</h3><p>Secure Sockets Layer（SSL）和 Transport Layer Security（TLS）加密协议像其他所有技术一样存在缺陷。以下是 TLS/SSL 协议中的主要漏洞。它们都会影响协议的旧版本（TLSv1.2及更早版本）。在发布时，只发现了一个影响TLS 1.3的主要漏洞。但是，与此处列出的许多其他攻击一样，此漏洞也基于强制降级攻击。(由于它们利用的攻击和漏洞的复杂性，示例简化了描述并基于Web示例（Web客户端和Web服务器）)</p>
<h4 id="POODLE"><a href="#POODLE" class="headerlink" title="POODLE"></a>POODLE</h4><p>Padding Oracle On Downgraded Legacy Encryption（POODLE）攻击于2014年10月发布，并利用了两个因素。第一个因素是某些服务器/客户端仍支持SSL 3.0，以实现与旧系统的互操作性和兼容性。第二个因素是SSL 3.0中存在的漏洞，该漏洞与块填充有关。 POODLE漏洞在NIST NVD数据库中注册为CVE-2014-3566。</p>
<p>客户端启动握手并发送支持的 SSL/TLS 版本列表。攻击者拦截流量，执行中间人（MITM）攻击，并模拟服务器，直到客户端同意将连接降级到SSL 3.0。</p>
<p><img src="/img/TLS-SSL/POODLE.png" alt="gcheap"></p>
<p>SSL 3.0漏洞处于 Cipher Block Chaining（CBC）模式。分组密码需要固定长度的块。如果最后一个块中的数据不是块大小的倍数，则通过填充填充额外的空间。服务器忽略填充的内容。它仅检查填充长度是否正确并验证明文的Message Authentication Code（MAC）。这意味着服务器无法验证是否有人修改了填充内容。</p>
<p>攻击者可以通过修改填充字节和观察服务器响应来解密加密块。解密单个字节最多需要256个SSL 3.0请求。这意味着每256个请求一次，服务器将接受修改后的值。攻击者不需要知道加密方法或密钥。使用自动化工具，攻击者可以逐个字符地检索明文。这可以很容易地是密码，cookie，session或其他敏感数据。</p>
<p><strong>Prevention</strong></p>
<ul>
<li>完全禁用服务器上的SSL 3.0（强烈建议,除非您必须支持Internet Explorer 6.0）。</li>
<li>将浏览器（客户端）升级到最新版本。如果必须使用旧版本，请禁用SSLv2和SSLv3。大多数当前的浏览器/服务器使用TLS_FALLBACK_SCSV。如果客户端请求的TLS协议版本低于服务器（和客户端）支持的最高版本，则服务器会将其视为故意降级并断开连接。</li>
<li>一些 TLS 1.0/1.1 实现也容易受到POODLE的攻击，因为它们在解密后接受不正确的填充结构。</li>
</ul>
<h4 id="BEAST"><a href="#BEAST" class="headerlink" title="BEAST"></a>BEAST</h4><p>Browser Exploit Against SSL/TLS（BEAST）攻击于2011年9月披露。它适用于SSL 3.0和TLS 1.0，因此它会影响支持TLS 1.0或更早版本协议的浏览器。攻击者可以利用TLS 1.0中 Cipher Block Chaining （CBC）模式实施中的漏洞来解密双方之间交换的数据。 BEAST漏洞在NIST NVD数据库中注册为CVE-2011-3389。</p>
<p>这是一种使用中间人技术的客户端攻击。攻击者使用MITM将数据包注入TLS流。这允许他们猜测与注入消息一起使用的初始化向量（IV），然后简单地将结果与他们想要解密的块进行比较。</p>
<p>为了使BEAST攻击成功，攻击者必须对受害者的浏览器有一些控制权。因此，攻击者可以选择更容易的攻击向量而不是这个。</p>
<p><strong>Prevention</strong></p>
<ul>
<li>Use TLS 1.1 or TLS 1.2</li>
<li><ul>
<li>最初，建议用于缓解BEAST攻击的方法之一是使用RC4密码。但是，后来发现RC4加密协议不安全。 PCI DSS（支付卡行业数据安全标准）禁止使用此密码，Microsoft也强烈建议不要在Windows中使用它。</li>
</ul>
</li>
</ul>
<h4 id="CRIME-CVE-2012-4929"><a href="#CRIME-CVE-2012-4929" class="headerlink" title="CRIME (CVE-2012-4929)"></a>CRIME (CVE-2012-4929)</h4><p>Compression Ratio Info-leak Made East（CRIME）漏洞影响TLS压缩。压缩方法包含在Client Hello消息中，并且是可选的。您可以在不压缩的情况下建立连接。压缩被引入 SSL/TLS 以减少带宽。 DEFLATE是最常用的压缩算法。 CRIME漏洞在NIST NVD数据库中注册为CVE-2012-4929。</p>
<p>这是一个Wireshark捕获服务器Hello消息（响应客户端Hello）。服务器选择NULL压缩方法，这意味着不使用压缩。</p>
<p><img src="/img/TLS-SSL/CRIME1.png" alt="gcheap"></p>
<p>压缩算法使用的主要技术之一是用指向该序列的第一个实例的指针替换重复的字节序列。重复的序列越大，压缩比越高。</p>
<p><img src="/img/TLS-SSL/CRIME2.png" alt="gcheap"></p>
<p>让我们假设攻击者想要获得受害者的cookie。他们知道目标网站（examplebank.com）为名为adm的会话创建了一个cookie。攻击者知道DEFLATE压缩方法替换重复的字节。因此，攻击者将 Cookie：adm = 0 注入受害者的cookie中。服务器只会在压缩响应中附加0，因为 Cookie：adm = 已经在受害者的cookie中发送，因此会重复。</p>
<p><img src="/img/TLS-SSL/CRIME4.png" alt="gcheap"></p>
<p>攻击者必须做的就是注入不同的字符，然后监视响应的大小。如果响应比初始响应短，则注入的字符包含在cookie值中，因此它被压缩。如果字符不在cookie值中，则响应将更长。</p>
<p><img src="/img/TLS-SSL/CRIME3.png" alt="gcheap"></p>
<p>使用此方法，攻击者可以使用从服务器获得的反馈来重建cookie值。</p>
<p><strong>Prevention</strong></p>
<ul>
<li>将浏览器升级到最新版本</li>
</ul>
<h4 id="BREACH"><a href="#BREACH" class="headerlink" title="BREACH"></a>BREACH</h4><p>通过 Browser Reconnasance（BREACH）漏洞进行浏览器侦察和泄漏与CRIME非常相似，但BREACH的目标是HTTP压缩，而不是TLS压缩。即使关闭TLS压缩，也可以进行此攻击。攻击者强制受害者的浏览器连接到启用TLS的第三方网站，并使用中间人攻击监视受害者与服务器之间的流量。 BREACH漏洞在NIST NVD数据库中注册为CVE-2013-3587。</p>
<p>易受攻击的Web应用程序必须满足以下条件:</p>
<ul>
<li>从使用HTTP级压缩的服务器提供服务</li>
<li>反映HTTP响应正文中的用户输入</li>
<li>在HTTP响应主体中反映一 sercet（例如CSRF令牌）（因此使用 HTTP Header 中的值，例如cookie，可以免受此攻击）</li>
</ul>
<p><strong>Prevention</strong></p>
<ul>
<li>Disable HTTP compression</li>
<li>Separate secrets from user input</li>
<li>Randomize secrets per request</li>
<li>Mask secrets (effectively randomize by XORing with a random secret per request)</li>
<li>Protect pages against CSRF</li>
<li>Hide the length (by adding random numbers of bytes to responses)</li>
<li>Limit the rate of requests</li>
</ul>
<h4 id="Heartbleed"><a href="#Heartbleed" class="headerlink" title="Heartbleed"></a>Heartbleed</h4><p>Heartbleed是一个重要的漏洞，可以在流行的OpenSSL库的 Heartbleed 扩展中找到。只要双方仍在那里，此扩展用于保持连接存活。 Heartbleed 漏洞在 NIST NVD数据库中注册为 CVE-2014-0160。</p>
<p>客户端使用包含数据和数据大小（以及填充）的有效负载向服务器发送心跳消息。服务器必须使用相同的心跳请求进行响应，该请求包含客户端发送的数据和数据大小。</p>
<p><img src="/img/TLS-SSL/Heartbleed.png" alt="gcheap"></p>
<p>Heartbleed漏洞基于以下事实：如果客户端发送了错误的数据长度，服务器将使用客户端接收的数据和来自其内存的随机数据来响应，以满足发送方指定的长度要求。</p>
<p><img src="/img/TLS-SSL/Heartbleed1.png" alt="gcheap"></p>
<p>从服务器内存中获取未加密的数据可能是灾难性的。已经存在此漏洞的概念验证漏洞，其中攻击者将获取服务器的私钥。这意味着攻击者可以解密到服务器的所有流量。服务器内存可能包含任何内容：凭据，敏感文档，信用卡号，电子邮件等。</p>
<p><strong>Prevention</strong></p>
<ul>
<li>更新到最新版本的OpenSSL。如果无法做到这一点，请使用-DOPENSSL_NO_HEARTBEATS重新编译已安装的版本</li>
</ul>
<p><strong>Conclusion</strong></p>
<p>TLS/SSL 协议用于保护数据传输，但配置错误的服务器可能会暴露数据而不是保护数据。</p>
<p>在大多数情况下，保护自己免受 TLS/SSL 相关攻击的最佳方法是禁用较旧的协议版本。这甚至是某些行业的标准要求。例如，2018年6月30日是根据PCI数据安全标准禁用对SSL和早期版本的TLS（包括TLS 1.0）的支持的截止日期。互联网工程任务组（IETF）发布了有关SSL安全性的建议：RFC 6176和RFC 7568.IETF很快就会对TLS 1.0和1.1进行弃用。</p>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_layer">Wikipedia - Application layer</a></li>
<li><a target="_blank" rel="noopener" href="https://www.acunetix.com/blog/articles/tls-security-what-is-tls-ssl-part-1/">acunetix - What Is SSL/TLS</a></li>
<li><a target="_blank" rel="noopener" href="https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/">acunetix - Recommendations for TLS/SSL Cipher Hardening</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/05/24/OSIApplicationLayer/" data-id="ckvgcipjo0016plqhcs2uf7xt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compuer-network/" rel="tag">compuer network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/internet/" rel="tag">internet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/osi/" rel="tag">osi</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/protocol/" rel="tag">protocol</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/protocol-suite/" rel="tag">protocol suite</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TransactionProcessing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/21/TransactionProcessing/" class="article-date">
  <time datetime="2019-05-21T03:47:51.000Z" itemprop="datePublished">2019-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DatabaseTransaction/">DatabaseTransaction</a>►<a class="article-category-link" href="/categories/Transaction/">Transaction</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/21/TransactionProcessing/">Transaction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Transaction-Processing"><a href="#Transaction-Processing" class="headerlink" title="Transaction Processing"></a>Transaction Processing</h1><h2 id="What-is-Transaction-Processing"><a href="#What-is-Transaction-Processing" class="headerlink" title="What is Transaction Processing?"></a>What is Transaction Processing?</h2><p>事务处理是计算机科学中的信息处理，它被分成称为事务的单个不可分割的操作。每笔交易必须作为一个完整的单位成功或失败;它永远不会只是部分完成。</p>
<p>事务处理是一种计算方式，通常由大型服务器计算机执行，支持交互式应用程序。在事务处理中，工作分为单个的，不可分割的操作，称为事务。相比之下，批处理是一种计算方式，其中一个或多个程序处理一系列记录（批处理），用户或操作员很少或没有动作。</p>
<p>详情：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transaction_processing">Wikipedia - Transaction Processing</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/support/knowledgecenter/en/SSGMCP_5.2.0/com.ibm.cics.ts.productoverview.doc/concepts/TransactionProcessing.html">IBM Knowledge Center - Transaction Processing</a></li>
</ul>
<h2 id="Methodlogy"><a href="#Methodlogy" class="headerlink" title="Methodlogy"></a>Methodlogy</h2><p>所有 Transaction processing system 的基本原理都是相同的。但是，术语可能因交易处理系统而异，下面使用的术语不一定是通用的。</p>
<h3 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h3><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rollback_(data_management)">Rollback (data management)</a></em></p>
<p>事务处理系统在修改数据库时记录数据库的中间状态，然后在无法提交事务时使用这些记录将数据库恢复到已知状态，从而确保数据库的完整性。例如，在事务进行任何修改之前，数据库上的信息的副本将由系统在事务进行任何修改之前保留(有时称为before image)。如果事务的任何部分在提交之前失败，则使用这些副本将数据库恢复到事务开始之前的状态。</p>
<h3 id="Rollforward"><a href="#Rollforward" class="headerlink" title="Rollforward"></a>Rollforward</h3><p>对数据库管理系统的所有修改都可以单独保存日志。(有时称为 after image)。这对于回滚失败的事务不是必需的，但是对于在数据库发生故障时更新数据库管理系统是有用的，因此一些事务处理系统提供了它。如果数据库管理系统完全失败，则必须从最近的备份中恢复它。备份将不反映自备份以来所提交的事务。但是，数据库管理系统一旦恢复，就可以将 after image 日志应用到数据库中(前滚)，使数据库管理系统保持最新。然后可以回滚发生故障时正在进行的任何事务。结果是一个处于一致的、已知状态的数据库，其中包括在失败之前提交的所有事务的结果。</p>
<h3 id="Deadlocks"><a href="#Deadlocks" class="headerlink" title="Deadlocks"></a>Deadlocks</h3><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deadlock">Deadlock</a></em></p>
<p>在某些情况下，两个事务在处理过程中可能试图同时访问数据库的同一部分，从而阻止它们继续处理。例如，事务A可以访问数据库的X部分，事务B也可以访问数据库的Y部分。如果此时，事务A试图访问数据库的Y部分，同时事务B也试图访问X部分，则会发生死锁，并且两个事务都不能继续往下处理。事务处理系统的设计目的是在这些死锁发生时检测它们。通常这两个事务都将被取消和回滚，然后它们将以不同的顺序自动重新启动，这样死锁就不会再次发生。有时，只有一个死锁事务将被取消、回滚，并在短暂延迟后自动重新启动。</p>
<p>三个或更多事务之间也可能发生死锁。涉及的事务越多，它们检测的难度就越大，以至于事务处理系统发现它们可以检测到的死锁存在实际限制。</p>
<h3 id="Compensating-transaction"><a href="#Compensating-transaction" class="headerlink" title="Compensating transaction"></a>Compensating transaction</h3><p>在提交和回滚机制不可用或没有预期处理的系统中，补偿事务通常用于撤消失败的事务并将系统恢复到先前的状态。</p>
<h2 id="ACID-criteria"><a href="#ACID-criteria" class="headerlink" title="ACID criteria"></a>ACID criteria</h2><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ACID_(computer_science)">ACID</a></em></p>
<p>Jim Gray在20世纪70年代后期以ACID（atomicity，consistency，isolation 和 durability）的首字母缩写定义了可靠的 transaction system 的属性。</p>
<h3 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity (原子性)"></a>Atomicity (原子性)</h3><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">Atomicity (database systems)</a></em></p>
<p>事务对状态的更改是原子的：要么全部发生，要么都不发生。这些更改包括数据库更改，消息和传感器上的操作。…</p>
<h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency (一致性)"></a>Consistency (一致性)</h3><p>一致性:事务是状态的正确转换。作为一个组所采取的操作不违反与状态相关的任何完整性约束。</p>
<h3 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation (隔离性)"></a>Isolation (隔离性)</h3><p>即使事务并发执行，在其中一个事务T看起来，其他事务在T之前或T之后执行，但不是两者都执行。</p>
<h3 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability (持久性)"></a>Durability (持久性)</h3><p>一旦事务成功完成（提交），它对数据库的更改将在失败后继续存在并保留其更改。</p>
<h2 id="Implements"><a href="#Implements" class="headerlink" title="Implements"></a>Implements</h2><p>标准事务处理软件，例如IBM的信息管理系统，最初是在20世纪60年代开发的，并且常常与特定的数据库管理系统紧密耦合。客户机-服务器计算在上世纪80年代实现了类似的原则，但成败参半。然而，近年来，分布式 客户端-服务器模型的维护变得相当困难。由于响应各种在线服务(特别是 Web )的事务数量不断增加，因此单一的分布式数据库并不是一个实用的解决方案。此外，大多数在线系统由一组共同运行的程序组成，而不是严格的客户端-服务器模型，在这种模型中，单个服务器可以处理事务处理。今天，有许多事务处理系统可以在程序间级别工作，并且可以扩展到大型系统，包括大型机。</p>
<p>其中一项工作是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X/Open_XA">X/Open 分布式事务处理（Distributed Transaction Processing）</a>（另请参阅Java Transaction API（JTA）。但是，专有的事务处理环境，例如IBM的CICS仍然非常受欢迎，虽然CICS已经发展到包括开放行业标准也是如此。</p>
<p>术语极端事务处理（XTP）用于描述具有非常具有挑战性的要求的事务处理系统，特别是吞吐量要求（每秒事务数）。可以通过分布式或集群式架构来实现这样的系统。</p>
<h1 id="Transaction-Processing-System"><a href="#Transaction-Processing-System" class="headerlink" title="Transaction Processing System"></a>Transaction Processing System</h1><p>事务处理系统是一组信息，其处理在监视数据库系统中的数据事务处理的事务的程序。当通过互联网销售某些东西时，该系统很有用。它允许在物品被销售到实际销售之间的时间延迟。一个例子是体育赛事门票。客户填写他们的信息以购买座位票; 交易处理系统持有票证，以便另一个客户也不能购买它。它允许不向两个不同的客户出售机票。</p>
<p>事务处理是一种计算方式，它将工作划分为单独的，不可分割的操作，称为事务。事务处理系统（TPS）是一种软件系统，或软件/硬件结合，支持事务处理。</p>
<p>事务处理系统（TPS）是一种软件系统，或软件/硬件结合，支持事务处理。</p>
<p>第一个事务处理系统是SABRE，由IBM为美国航空公司制造，于1970年投入运营。该系统设计为每天处理多达83,000个事务，系统运行在两台IBM 7090计算机上。SABER 于1972 年迁移到IBM System/360 计算机，并首先成为IBM产品，作为航空公司控制计划（Airline Control Program），后来成为事务处理设施（Transaction Processing Facility）。除航空公司外，大型银行，信用卡公司和连锁酒店也使用TPF。</p>
<p>惠普 的NonStop系统（前身为 Tandem 的 NonStop）是一个硬件和软件系统，设计用于联机事务处理（OnLine Transaction Processing）在1976年引入的系统被设计用于处理事务和提供的可用性和数据完整性的极端水平。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transaction_processing_system">more info about transaction processing systems</a></p>
<h2 id="Processing-types"><a href="#Processing-types" class="headerlink" title="Processing types"></a>Processing types</h2><p>事务处理不同于其他计算机处理模型 - batch processing(批处理), time-sharing(分时), and real-time processing(实时处理).</p>
<h3 id="Batch-processing"><a href="#Batch-processing" class="headerlink" title="Batch processing"></a>Batch processing</h3><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Batch_processing">Batch processing</a></em></p>
<p>批处理是在计算机上执行一系列程序(作业)，不需要人工干预。同时收集和处理几个称为批处理的事务。当输入事务时，每个事务的结果不是立即可用的;存在一定时间延迟。</p>
<p>最早的计算机是极其昂贵的设备，与后来的型号相比速度很慢。机器通常用于一组特定的任务，由控制面板操作，操作员通过开关手动输入小程序，以便加载和运行一系列程序。这些程序可能需要数小时，甚至数周才能运行。随着计算机速度的增长，运行时间下降，很快启动下一个程序所需的时间就成为一个问题。批处理方法通过对程序进行排队来减少这些“死周期”，以便一旦一个程序完成，下一个程序就会启动。</p>
<p>为了支持批处理操作，程序员使用一些相对便宜的卡片穿孔机或纸带写入器来“脱机”编写程序。当输入(或打孔)完成后，程序被提交给操作团队，操作团队计划运行这些程序。重要项目快速启动;在不那么重要的项目开始之前多久是不可预测的。当程序运行最终完成时，输出(通常打印)返回给程序员。整个过程可能需要几天的时间，在此期间程序员可能永远看不到计算机。</p>
<p>允许用户直接操作计算机的另一种选择通常过于昂贵，难以考虑。这是因为当计算机处于空闲状态时，用户可能需要很长时间输入代码。这种情况将交互开发限制在那些能够负担得起浪费计算周期的组织中:大部分是大型大学。大学里的程序员们谴责批处理强加给他们的行为，以至于斯坦福大学的学生拍了一部短片，幽默地批评了这种行为。他们试验了与计算机直接交互的新方法，这个领域今天被称为human-computer interaction(人机交互)。</p>
<p>拓展阅读:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Human%E2%80%93computer_interaction">Wikipedia - Human-computer interaction</a></li>
</ul>
<h3 id="Real-time-processing"><a href="#Real-time-processing" class="headerlink" title="Real-time processing"></a>Real-time processing</h3><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Real-time_computing">Real-time processing</a></em></p>
<p>“实时系统试图确保对 stimulus 或请求的适当响应足够快，足以影响引发 stimulus 的条件。”实时处理中的每个事务都是唯一的;它不是一组事务的一部分。</p>
<h3 id="Time-sharing"><a href="#Time-sharing" class="headerlink" title="Time-sharing"></a>Time-sharing</h3><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time-sharing">Time-sharing</a></em></p>
<p>分时（time-sharing）是对计算机资源的一种共享方式，利用多道程序与多任务处理使多个用户可以同时使用一台计算机。</p>
<p>一般来说，计算机用户（可以是多个）通过特定的端口向计算机发送指令，计算机完成相应任务后再将结果通过端口反馈给用户。</p>
<p>在早期的计算机系统中，计算机处理多个用户发送出的指令的时候，处理的方案即为分时，即计算机把它的运行时间分为多个时间段，并且将这些时间段平均分配给用户们指定的任务。轮流地为每一个任务运行一定的时间，如此循环，直至完成所有任务。</p>
<h3 id="Transaction-processing"><a href="#Transaction-processing" class="headerlink" title="Transaction processing"></a>Transaction processing</h3><p><em>Main article: <a href="#Transaction-Processing">Transaction processing</a></em></p>
<p>事务处理系统（TPS）是一种收集，存储，修改和检索企业数据事务的信息系统。事务处理系统还尝试为请求提供可预测的响应时间，尽管这不像实时系统那样重要。事务处理不允许用户作为时间共享运行任意程序，而是仅允许预定义的结构化事务。每笔交易通常是短期的，并且每笔交易的处理活动都是预先编制的。</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><p>在评估事务处理系统时，以下功能被认为是重要的</p>
<h3 id="Performance-性能"><a href="#Performance-性能" class="headerlink" title="Performance (性能)"></a>Performance (性能)</h3><p>事务处理系统（TPS）的响应时间非常重要，因为企业在进行交易之前无法让客户等待很长一段时间。事务处理系统通常通过在给定时间段内可以处理的事务数量来衡量其性能。</p>
<h3 id="Continuous-availability-连续可用性"><a href="#Continuous-availability-连续可用性" class="headerlink" title="Continuous availability (连续可用性)"></a>Continuous availability (连续可用性)</h3><p>良好的TPS必须非常可靠，因为如果要分解，企业可能会失去很大一部分收入，因为客户无法购买他们的产品。系统必须在用户输入事务的时间段内可用。系统必须能够在不破坏数据的情况下处理硬件或软件问题。</p>
<h3 id="Data-integrity-数据完整性"><a href="#Data-integrity-数据完整性" class="headerlink" title="Data integrity (数据完整性)"></a>Data integrity (数据完整性)</h3><p>必须保护多个用户不尝试同时更改相同的数据块，例如两个运营商不能在飞机上出售相同的座位。</p>
<h3 id="Ease-of-use-便于使用"><a href="#Ease-of-use-便于使用" class="headerlink" title="Ease of use (便于使用)"></a>Ease of use (便于使用)</h3><p>TPS必须能够允许授权员工随时访问它。通常，事务处理系统的用户是临时用户。系统应该易于理解，尽可能地保护它们免受数据输入错误的影响，并允许它们轻松纠正错误。</p>
<h3 id="Modular-growth-模块化增长"><a href="#Modular-growth-模块化增长" class="headerlink" title="Modular growth (模块化增长)"></a>Modular growth (模块化增长)</h3><p>该系统应能够以增量成本增长，而不是需要完全替代。应该可以在不关闭系统的情况下添加，替换或更新硬件和软件组件。</p>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><h3 id="Processing-in-a-batch-批量处理"><a href="#Processing-in-a-batch-批量处理" class="headerlink" title="Processing in a batch (批量处理)"></a>Processing in a batch (批量处理)</h3><p>同时处理多个事务，并带有时间延迟。</p>
<p>可以在批处理中收集和处理事务。事务将被收集并随后在批处理时方便或便捷地进行处理。从历史上看，这是最常用的方法，因为当时还没有允许实时处理的信息技术。</p>
<h3 id="Processing-in-a-real-time-实时处理"><a href="#Processing-in-a-real-time-实时处理" class="headerlink" title="Processing in a real-time (实时处理)"></a>Processing in a real-time (实时处理)</h3><p>一次处理一个事务，没有时间延迟。</p>
<p>这是对数据的即时处理。它提供对事务的即时确认。它可能涉及同时执行更改数据的事务的大量用户。由于技术的进步(如数据传输速度的提高和更大的带宽)，实时更新是可能的。</p>
<h2 id="Database-for-transaction-processing"><a href="#Database-for-transaction-processing" class="headerlink" title="Database for transaction processing"></a>Database for transaction processing</h2><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database">Database</a></em></p>
<p>数据库是有组织的数据集合。与典型的事务处理应用程序一样，数据库为非结构化的请求提供快速检索时间。 可以使用分层，网络或关系结构来构造用于事务处理的数据库。</p>
<ul>
<li>Hierachical structure(分层结构)：以一系列级别组织数据。它的从上到下的结构由节点和分支组成; 每个子节点都有分支，并且只链接到一个更高级别的父节点。</li>
<li>Network structure(网络结构)：网络结构还使用节点和分支来组织数据。但是，与分层结构不同，每个子节点都可以链接到多个更高的父节点。</li>
<li>Relational structure(关系结构)：关系数据库在一系列相关表中组织其数据。这提供了灵活性，因为构建表之间的关系。</li>
</ul>
<p><img src="/img/TransactionProcessing/Hierachical-Diagram.png" alt="gcheap"><br><img src="/img/TransactionProcessing/Network-Diagram.png" alt="gcheap"><br><img src="/img/TransactionProcessing/Relational-Diagram.png" alt="gcheap"></p>
<p>在事务处理系统中使用的数据库系统中需要以下功能：</p>
<ul>
<li>良好的数据放置：数据库应设计为访问来自许多同时用户的数据模式。</li>
<li>短事务：短事务可以快速处理。这避免了并发性并使系统步调。</li>
<li>实时备份：应在低活动时间之间安排备份，以防止服务器滞后。</li>
<li>高规范化：这会降低冗余信息以提高速度并提高并发性，这也可以改善备份。</li>
<li>归档历史数据：将不常用的数据移动到其他数据库或备份表中。这样可以保持较小的表，还可以缩短备份时间</li>
<li>良好的硬件配置：硬件必须能够处理许多用户并提供快速响应时间。</li>
</ul>
<h2 id="Backup-procedures"><a href="#Backup-procedures" class="headerlink" title="Backup procedures"></a>Backup procedures</h2><p><em>Main article: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Backup">Backup</a></em></p>
<p>由于业务组织已经非常依赖于事务处理，故障可能会破坏业务的常规例程并在一定时间内停止其运行。为了防止数据丢失并最大限度地减少中断，必须有精心设计的备份和恢复程序。恢复过程可以在系统停机时重建系统。</p>
<h3 id="Recovery-process"><a href="#Recovery-process" class="headerlink" title="Recovery process"></a>Recovery process</h3><p>TPS可能由于多种原因而失败，例如系统故障，人为错误，硬件故障，数据不正确或无效，计算机病毒，软件应用程序错误或自然灾害或人为灾难。由于无法防止所有故障，因此TPS必须能够在发生错误时检测并纠正错误并应对故障。TPS将通过恢复数据库，可能涉及备份，日志，检查点和恢复管理器：</p>
<ul>
<li>Journal： Journal 维护着交易和数据库变更的审计线索。使用事务日志和数据库更改日志，事务日志记录每个事务的所有基本数据，包括数据值，事务时间和终端号。数据库更改日志包含已由事务修改的记录副本之前和之后。</li>
<li>Checkpoint： Checkpoint 的目的是提供数据库中数据的快照。通常， checkpoint 是标识某个时间点的数据库状态的任何标识符或其他引用。对数据库页面的修改在内存中执行，并且不必在每次更新后写入磁盘。因此，数据库系统必须定期执行检 checkpoint，将保存在内存中的这些更新写入存储磁盘。将这些更新写入存储磁盘会创建一个时间点，在该时间点，数据库系统可以在数据库系统意外关闭或崩溃后的恢复期间应用事务日志中包含的更改。如果 checkpoint 中断并且需要恢复，则数据库系统必须从先前成功的 checkpoint 开始恢复。 checkpoint 可以是事务一致的或非事务一致的（也称为 fuzzy checkpoint）。事务一致性的 checkpoint 生成一个持久数据库映像，该映像足以将数据库恢复到开始 checkpoint 时外部感知的状态。非事务一致的 checkpoint 导致持久数据库映像不足以执行数据库状态的恢复。要执行数据库恢复，需要其他信息，通常包含在事务日志中。事务一致性 checkpoint 是指一致的数据库，它不一定包括所有最新提交的事务，但是在启动 checkpoint 创建时提交的事务所做的所有修改都完全存在。不一致的事务是指一个 checkpoint ，它不一定是一致的数据库，如果没有为 checkpoint 中包含的打开事务生成的所有日志记录，则无法恢复到该 checkpoint 。取决于实现的数据库管理系统的类型 checkpoint 可以包含索引或存储页面（用户数据），索引和存储页面。如果 checkpoint 中未包含任何索引，则必须在从 checkpoint 映像还原数据库时创建索引。</li>
<li>Recovery Manager： Recovery Manager 是一个将数据库恢复到正确状态的程序，该状态允许重新启动事务处理。</li>
</ul>
<p>根据系统的失败方式，可以使用两种不同的恢复过程。通常，这些过程涉及恢复从备份设备收集的数据，然后再次运行事务处理。两种类型的恢复是向后恢复和向前恢复：</p>
<ul>
<li>Backward recovery：用于撤消对数据库的不必要更改。它将反转已中止的交易所做的更改。</li>
<li>Forward recovery：它从数据库的备份副本开始。然后，事务将根据在进行备份和当前时间之间发生的事务日志进行重新处理。</li>
</ul>
<p>另请参阅：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Checkpoint_restart">Checkpoint restart</a></p>
<h3 id="Types-of-back-up-procedures"><a href="#Types-of-back-up-procedures" class="headerlink" title="Types of back-up procedures"></a>Types of back-up procedures</h3><p>主要有两种类型的备份程序：grandfather-father-son 和 partial backups：</p>
<h4 id="Grandfather-father-son"><a href="#Grandfather-father-son" class="headerlink" title="Grandfather - father - son"></a>Grandfather - father - son</h4><p>此过程涉及定期对所有数据进行完整备份 - 每天，每周，每月或任何适当的数据。保留了多代备份，通常是三代，这就产生了名称。最近的备份是 son ，前一个 father ，最老的备份是 grandfather 。该方法通常用于具有磁带的批量交易处理系统。如果在批处理运行期间系统出现故障，则通过还原子备份然后重新启动批处理来重新创建主文件。但是，如果子备份失败，被破坏或被破坏，则使用上一代备份（father）。同样，如果失败，则需要在father（即grandfather）之前生成备份。当然，这一代人越老，数据就越过时。仅组织已更改的记录。例如，可以每周执行完整备份，并在每晚执行部分备份。使用此方案进行恢复涉及还原上次完整备份，然后还原所有部分备份以生成最新数据库。此过程比仅进行完整备份更快，但代价是恢复时间更长。</p>
<h4 id="Backup-plus-journal"><a href="#Backup-plus-journal" class="headerlink" title="Backup plus journal"></a>Backup plus journal</h4><p>此技术还与常规完整备份结合使用。主文件定期备份。自上次备份以来完成的事务将单独存储，称为日志或日志文件。可以通过还原上一个完整备份然后从日志文件重新处理事务来重新创建主文件。这将生成最新的数据库副本，但由于处理大量日志记录所需的时间，恢复可能需要更长时间。</p>
<h1 id="Java-Transaction-API"><a href="#Java-Transaction-API" class="headerlink" title="Java Transaction API"></a>Java Transaction API</h1><p>Java Transaction API，通常称为JTA，是用于管理 Java 中的事务的API 。它允许我们以资源无关的方式启动，提交和回滚事务。</p>
<p>JTA的真正强大之处在于它能够在单个事务中管理多个资源（即数据库，消息传递服务）。</p>
<p>在Java Transaction API（JTA），在一个Java企业版（Java EE的）的API，能使分布式事务跨多个进行的 X/Open XA的资源的Java环境。JTA是在Java Community Process下开发的JSR 907 规范.JTA规定：</p>
<ul>
<li>事务边界的划分</li>
<li>X/Open XA API允许资源参与事务。</li>
</ul>
<p>JTA提供了对业务代码的事务控制(开始，提交和回滚)的抽象。</p>
<p>如果没有这种抽象，我们必须处理每种资源类型的各个API。</p>
<p>例如，我们需要像这样处理JDBC资源。同样，JMS资源可能具有类似但不兼容的模型。</p>
<p>通过JTA，我们可以以一致和协调的方式管理不同类型的多种资源。</p>
<p>作为API，JTA定义了由事务管理器实现的接口和语义。</p>
<p>JTA的实现：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/bitronix/btm">Bitronix</a></li>
<li><a target="_blank" rel="noopener" href="http://narayana.io/">Narayana</a></li>
</ul>
<h2 id="What-is-X-Open-XA-architecture？"><a href="#What-is-X-Open-XA-architecture？" class="headerlink" title="What is X/Open XA architecture？"></a>What is X/Open XA architecture？</h2><p>在 X/Open XA 体系结构中，事务管理器或事务处理监视器（TP监视器）协调跨多个资源（例如数据库和消息队列）的事务。每个资源都有自己的资源管理器。资源管理器通常有自己的API来操作资源，例如JDBC API用于处理关系数据库。此外，资源管理器允许TP监视器协调其自身和其他资源管理器之间的分布式事务。最后，有一个应用程序以开始与TP监视器通信，提交或回滚事务。应用程序还使用自己的API与各个资源进行通信以修改资源。</p>
<h2 id="JTA-Implements-of-the-X-Open-XA-architecture？"><a href="#JTA-Implements-of-the-X-Open-XA-architecture？" class="headerlink" title="JTA Implements of the X/Open XA architecture？"></a>JTA Implements of the X/Open XA architecture？</h2><p>JTA API由两个Java包中的类组成：</p>
<ul>
<li>javax.transaction</li>
<li>javax.transaction.xa</li>
</ul>
<p>JTA以 X/Open XA 架构为模型，但它定义了两个不同的API来划分事务边界。它区分应用程序服务器（如EJB服务器）和应用程序组件。它提供了一个接口，javax.transaction.TransactionManager ,应用程序服务器本身使用该接口来开始，提交和回滚事务。它提供了一个不同的接口，javax.transaction.UserTransaction由一般客户端代码（如servlet或EJB）用来管理事务。</p>
<p>JTA体系结构要求每个资源管理器必须实现该 javax.transaction.xa.XAResource 接口才能由TP监视器进行管理。如前所述，每个资源都有自己的特定API，例如：</p>
<ul>
<li>关系数据库使用JDBC</li>
<li>消息传递服务使用JMS</li>
<li>广义EIS（企业信息系统）资源使用Java EE Con​​nector API。</li>
</ul>
<h2 id="Java-Transaction-API-J2EE"><a href="#Java-Transaction-API-J2EE" class="headerlink" title="Java Transaction API (J2EE)"></a>Java Transaction API (J2EE)</h2><p>Java Transaction API由三个元素组成：高级应用程序事务划分接口，用于应用程序服务器的高级事务管理器接口，以及用于事务资源管理器的 X/Open XA协议的标准Java映射。</p>
<h3 id="UserTransaction-接口"><a href="#UserTransaction-接口" class="headerlink" title="UserTransaction 接口"></a>UserTransaction 接口</h3><p>javax.transaction.UserTransaction 接口为应用程序提供了以编程方式控制事务边界的能力。Java客户端程序或EJB bean可以使用此接口。</p>
<p>UserTransaction.begin()方法启动全局事务并将事务与调用线程相关联。事务管理器透明地管理事务到线程关联。</p>
<p>不需要支持嵌套事务。当调用线程已与事务关联且事务管理器的实现不支持嵌套事务时，UserTransaction.begin方法抛出NotSupportedException。</p>
<p>应用程序之间的事务上下文传播由客户端和服务器计算机上的基础事务管理器实现提供。用于传播的事务上下文格式取决于协议，必须在客户端和服务器主机之间协商。例如，如果事务管理器是JTS规范的实现，它将使用CORBA OTS 1.1规范中指定的事务上下文传播格式。事务传播对应用程序是透明的。</p>
<h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.html">@Transactional</a></h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.html">javax.transaction.Transactional</a> 注解提供了应用程序以声明式的方式控制事务的边界。此注解可以应用于Java EE规范定义为托管bean（包括CDI托管bean）的任何类。</p>
<p>下面的代码示例说明了在请求范围的CDI托管bean中<a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.html">@Transactional</a>的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestScoped</span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void foo() &#123; // A transaction is active here</span><br><span class="line">        </span><br><span class="line">        // Do work</span><br><span class="line"></span><br><span class="line">    &#125; // After the method returns transaction is committed or rolled back</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过注释上的属性配置事务行为。可用选项与EJB规范的选项非常相似。</p>
<h3 id="TransactionScoped"><a href="#TransactionScoped" class="headerlink" title="@TransactionScoped"></a>@TransactionScoped</h3><p>javax.transaction.TransactionScoped 注解使应用程序能够声明bean所处的作用域与给定事务的活动时间相关联。</p>
<p>下面的代码示例说明了在请求范围的CDI托管bean中@TransactionScoped的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@TransactionScoped</span><br><span class="line">public class TxScopedBean &#123;</span><br><span class="line">    public int number;</span><br><span class="line"></span><br><span class="line">    public int getNumber() &#123;return number;&#125;</span><br><span class="line">    public void setNumber(int number) &#123;this.number = number;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestScoped</span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    private TxScopedBean txScopedBean;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        txScopedBean.setNumber(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void bar() &#123;</span><br><span class="line">        System.out.print(tXscopedBean.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果首先在ExampleBean的托管实例上调用foo()方法，然后调用方法bar()，那么输出的数字将是0而不是1。这是因为每个方法都有自己的事务，因此也有自己的TxScopedBean实例。因此，在调用foo()期间设置的数字1将不会在调用bar()期间显示。</p>
<h2 id="EJB服务器中的UserTransaction支持"><a href="#EJB服务器中的UserTransaction支持" class="headerlink" title="EJB服务器中的UserTransaction支持"></a>EJB服务器中的UserTransaction支持</h2><p>EJB服务器需要支持UserTransaction接口，以便EJB BEAN使用javax.ejb中的BEAN值。TransactionManagement 注解(称为bean管理的事务或BMT)。UserTransaction接口通过使用getUserTransaction方法的EJBContext接口公开给EJB组件，或者直接通过使用通用 @Resource 注解的注入公开给EJB组件。因此，EJB应用程序不直接与事务管理器接口进行事务界定;相反，EJB bean依赖EJB服务器为其在Enterprise javabean规范中定义的所有事务工作提供支持。(EJB服务器和TM之间的底层交互对应用程序是透明的;实现事务管理的重担落在EJB容器和服务器提供者身上。</p>
<p>面的代码示例说明了EJB会话bean中通过bean管理的事务对UserTransaction的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Stateless</span><br><span class="line">@TransactionManagement(BEAN)</span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserTransaction utx;</span><br><span class="line"></span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        // start a transaction</span><br><span class="line">        utx.begin();</span><br><span class="line"></span><br><span class="line">        // Do work</span><br><span class="line"></span><br><span class="line">        // Commit it</span><br><span class="line">        utx.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，可以从SessionContext获取UserTransaction：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Stateless</span><br><span class="line">@TransactionManagement(BEAN)</span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private SessionContext ctx;</span><br><span class="line"></span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        UserTransaction utx = ctx.getUserTransaction();</span><br><span class="line"></span><br><span class="line">        // start a transaction</span><br><span class="line">        utx.begin();</span><br><span class="line"></span><br><span class="line">        // Do work</span><br><span class="line"></span><br><span class="line">        // Commit it</span><br><span class="line">        utx.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在上面的示例中，如果省略了@TransactionManagement(BEAN)注释，则无论何时调用foo()都会自动启动JTA事务，并且在foo()退出时自动提交或回滚JTA事务。因此，在EJB编程中不需要使用UserTransaction，但是对于非常特殊的代码可能需要。</p>
<blockquote>
<p>Java Transaction Service，简称JTS,Java事务服务是构建事务管理器的规范，将事务管理器映射到对象管理组织 (OMG)的基于CORBA体系架构的对象事务服务（OTS）上， 它使用IIOP在在多个JTS事务管理器之间传播事务。</p>
</blockquote>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>示例应用程序是银行应用程序的一个非常简单的后端服务。我们有两个服务，BankAccountService 和  AuditService 使用两个不同的数据库。这些独立的数据库需要在事务开始，提交或回滚时进行协调。</p>
<p>首先，使用Spring Boot来简化配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jta-bitronix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在每个测试方法之前，我们用空数据初始化AUDIT_LOG， 用2行初始化数据库 ACCOUNT：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+----------------+</span><br><span class="line">| ID        |  BALANCE       |</span><br><span class="line">+-----------+----------------+</span><br><span class="line">| a0000001  |  1000          |</span><br><span class="line">| a0000002  |  2000          |</span><br><span class="line">+-----------+----------------+</span><br></pre></td></tr></table></figure>

<h3 id="Declarative-Transaction-Demarcation"><a href="#Declarative-Transaction-Demarcation" class="headerlink" title="Declarative Transaction Demarcation"></a>Declarative Transaction Demarcation</h3><p>在JTA中处理事务的第一种方法是使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.html">@Transactional</a> 注释。有关更详细的说明和配置，请参阅此<a target="_blank" rel="noopener" href="https://www.baeldung.com/transaction-configuration-with-jpa-and-spring">文章</a>。</p>
<p>用@Transactional注释facade服务方法 executeTranser()。这指示事务管理器开始事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void executeTransfer(String fromAccontId, String toAccountId, BigDecimal amount) &#123;</span><br><span class="line">    bankAccountService.transfer(fromAccontId, toAccountId, amount);</span><br><span class="line">    auditService.log(fromAccontId, toAccountId, amount);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里方法executeTranser()调用2个不同的服务，AccountService和AuditService。这些服务使用2个不同的数据库</p>
<p>当 executeTransfer() 返回时，事务管理器认识到这是事务的结束，并将提交给两个数据库:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tellerService.executeTransfer(&quot;a0000001&quot;, &quot;a0000002&quot;, BigDecimal.valueOf(500));</span><br><span class="line">assertThat(accountService.balanceOf(&quot;a0000001&quot;)).isEqualByComparingTo(BigDecimal.valueOf(500));        </span><br><span class="line">assertThat(accountService.balanceOf(&quot;a0000002&quot;)).isEqualByComparingTo(BigDecimal.valueOf(2500));</span><br><span class="line"></span><br><span class="line">TransferLog lastTransferLog = auditService.lastTransferLog();</span><br><span class="line">assertThat(lastTransferLog).isNotNull();        </span><br><span class="line">assertThat(lastTransferLog.getFromAccountId()).isEqualTo(&quot;a0000001&quot;);</span><br><span class="line">assertThat(lastTransferLog.getToAccountId()).isEqualTo(&quot;a0000002&quot;); </span><br><span class="line">assertThat(lastTransferLog.getAmount()).isEqualByComparingTo(BigDecimal.valueOf(500));</span><br></pre></td></tr></table></figure>

<h3 id="Rolling-back-in-Declarative-Demarcation"><a href="#Rolling-back-in-Declarative-Demarcation" class="headerlink" title="Rolling back in Declarative Demarcation"></a>Rolling back in Declarative Demarcation</h3><p>在方法的执行结束时，executeTransfer()检查帐户余额，如果源资金不足，则抛出RuntimeException:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void executeTransfer(String fromAccontId, String toAccountId, BigDecimal amount) &#123;</span><br><span class="line">    bankAccountService.transfer(fromAccontId, toAccountId, amount);</span><br><span class="line">    auditService.log(fromAccontId, toAccountId, amount);</span><br><span class="line">    BigDecimal balance = bankAccountService.balanceOf(fromAccontId);</span><br><span class="line">    if(balance.compareTo(BigDecimal.ZERO) &lt; 0) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Insufficient fund.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超过第一个@Transactional的未处理的RuntimeException将事务回滚到两个数据库。实际上，执行金额大于余额的转移将导致回滚：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assertThatThrownBy(() -&gt; &#123;</span><br><span class="line">    tellerService.executeTransfer(&quot;a0000002&quot;, &quot;a0000001&quot;, BigDecimal.valueOf(10000));</span><br><span class="line">&#125;).hasMessage(&quot;Insufficient fund.&quot;);</span><br><span class="line"> </span><br><span class="line">assertThat(accountService.balanceOf(&quot;a0000001&quot;)).isEqualByComparingTo(BigDecimal.valueOf(1000));</span><br><span class="line">assertThat(accountService.balanceOf(&quot;a0000002&quot;)).isEqualByComparingTo(BigDecimal.valueOf(2000));</span><br><span class="line">assertThat(auditServie.lastTransferLog()).isNull();</span><br></pre></td></tr></table></figure>

<h3 id="Programmatic-Transaction-Demarcation"><a href="#Programmatic-Transaction-Demarcation" class="headerlink" title="Programmatic Transaction Demarcation"></a>Programmatic Transaction Demarcation</h3><p>另一种控制JTA事务的方法是通过UserTransaction以编程方式  。</p>
<p>现在让我们修改 executeTransfer() 来手动处理事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userTransaction.begin();</span><br><span class="line"></span><br><span class="line">bankAccountService.transfer(fromAccontId, toAccountId, amount);</span><br><span class="line">auditService.log(fromAccontId, toAccountId, amount);</span><br><span class="line">BigDecimal balance = bankAccountService.balanceOf(fromAccontId);</span><br><span class="line">if(balance.compareTo(BigDecimal.ZERO) &lt; 0) &#123;</span><br><span class="line">    userTransaction.rollback();</span><br><span class="line">    throw new RuntimeException(&quot;Insufficient fund.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    userTransaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的示例中，begin() 方法启动一个新事务。如果余额验证失败，我们调用rollback()，它将回滚两个数据库。否则，对commit()的调用会将更改提交给两个数据库。</p>
<p>重要的是要注意 commit()和  rollback() 都会结束当前事务。</p>
<p>最终，使用程序化划分为我们提供了细粒度事务控制的灵活性。</p>
<h2 id="Distributed-Transaction-JTA-with-Spring"><a href="#Distributed-Transaction-JTA-with-Spring" class="headerlink" title="Distributed Transaction JTA with Spring"></a>Distributed Transaction JTA with Spring</h2><h3 id="Distributed-Transaction-With-JTA"><a href="#Distributed-Transaction-With-JTA" class="headerlink" title="Distributed Transaction With JTA"></a>Distributed Transaction With JTA</h3><p>Spring Boot通过使用<a href="#Java-Transaction-API">Atomikos</a>或<a href="#Java-Transaction-API">Bitronix</a> 嵌入式事务管理器支持跨多个 <a href="#What-is-X/Open-XA-architecture">XA</a> 资源的分布式JTA事务。部署到合适的Java EE Application Server时，也支持JTA事务。</p>
<p>检测到JTA环境时，Spring JtaTransactionManager 用于管理事务。自动配置的JMS，DataSource 和JPA bean 已升级为支持 <a href="#What-is-X/Open-XA-architecture">XA</a> 事务。您可以使用标准的Spring注解，例如 @Transactional，参与分布式事务。如果您在 JTA 环境中并仍希望使用本地事务，则可以将该 spring.jta.enabled 属性设置 false 为禁用 JTA 自动配置。</p>
<h4 id="Using-an-Atomikos-Transaction-Manager"><a href="#Using-an-Atomikos-Transaction-Manager" class="headerlink" title="Using an Atomikos Transaction Manager"></a>Using an Atomikos Transaction Manager</h4><p>Atomikos是一个流行的开源事务管理器，可以嵌入到Spring Boot应用程序中。您可以使用 spring-boot-starter-jta-atomikosStarter 引入相应的Atomikos库。Spring Boot自动配置Atomikos并确保将适当的 depends-on 设置应用于Spring bean以 正确启动和关闭顺序。</p>
<p>默认情况下，Atomikos 事务日志将写入transaction-logs应用程序主目录（应用程序jar文件所在的目录）中的目录。您可以通过spring.jta.log-dir在application.properties文件中设置属性来自定义此目录的位置 。以…开头的属性spring.jta.atomikos.properties也可用于自定义Atomikos UserTransactionServiceImp。</p>
<p>有关完整的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html">Atomikos Javadoc</a>。</p>
<blockquote>
<p>为确保多个事务管理器可以安全地协调相同的资源管理器，必须使用唯一ID配置每个Atomikos实例。默认情况下，此ID是运行Atomikos的计算机的IP地址。要确保生产中的唯一性，应spring.jta.transaction-manager-id 为应用程序的每个实例配置具有不同值的属性。</p>
</blockquote>
<h4 id="Using-a-Bitronix-Transaction-Manager"><a href="#Using-a-Bitronix-Transaction-Manager" class="headerlink" title="Using a Bitronix Transaction Manager"></a>Using a Bitronix Transaction Manager</h4><p>Bitronix是一种流行的开源JTA事务管理器实现。您可以使用spring-boot-starter-jta-bitronixstarter将适当的Bitronix依赖项添加到项目中。与Atomikos一样，Spring Boot会自动配置Bitronix并对bean进行后处理，以确保启动和关闭顺序正确。</p>
<p>默认情况下，Bitronix事务日志文件（part1.btm和part2.btm）将写入transaction-logs应用程序主目录中的目录。您可以通过设置spring.jta.log-dir属性来自定义此目录的位置。以…开头的属性spring.jta.bitronix.properties也绑定到 bitronix.tm.Configurationbean，允许完全自定义。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration">Bitronix Documentation</a>。</p>
<blockquote>
<p>为确保多个事务管理器可以安全地协调相同的资源管理器，必须为每个Bitronix实例配置唯一ID。默认情况下，此ID是运行Bitronix的计算机的IP地址。要确保生产中的唯一性，应spring.jta.transaction-manager-id 为应用程序的每个实例配置具有不同值的属性。</p>
</blockquote>
<h4 id="Using-a-Java-EE-Managed-Transaction-Manager"><a href="#Using-a-Java-EE-Managed-Transaction-Manager" class="headerlink" title="Using a Java EE Managed Transaction Manager"></a>Using a Java EE Managed Transaction Manager</h4><p>如果将Spring Boot应用程序打包为一个war或一个ear文件并将其部署到Java EE应用程序服务器，则可以使用应用程序服务器的内置事务管理器。Spring Boot尝试通过查看常见的JNDI位置（java:comp/UserTransaction，java:comp/TransactionManager等等）来自动配置事务管理器。如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器管理并通过JNDI公开。Spring Boot尝试通过查找ConnectionFactoryJNDI路径（java:/JmsXA或java:/XAConnectionFactory）来自动配置JMS ，您可以使用该 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-connecting-to-a-jndi-datasource">spring.datasource.jndi-name</a> 属性 来配置您的DataSource。</p>
<h4 id="Mixing-XA-and-Non-XA-JMS-Connections"><a href="#Mixing-XA-and-Non-XA-JMS-Connections" class="headerlink" title="Mixing XA and Non-XA JMS Connections"></a>Mixing XA and Non-XA JMS Connections</h4><p>使用JTA时，主JMS ConnectionFactorybean可识别XA并参与分布式事务。在某些情况下，您可能希望使用非XA处理某些JMS消息ConnectionFactory。例如，您的JMS处理逻辑可能需要比XA超时更长的时间。</p>
<p>如果要使用非XA ConnectionFactory，可以注入 nonXaJmsConnectionFactorybean而不是@Primary jmsConnectionFactorybean。为了保持一致性，jmsConnectionFactory还使用bean别名提供bean xaJmsConnectionFactory。</p>
<p>以下示例显示了如何注入ConnectionFactory实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Inject the primary (XA aware) ConnectionFactory</span><br><span class="line">@Autowired</span><br><span class="line">private ConnectionFactory defaultConnectionFactory;</span><br><span class="line"></span><br><span class="line">// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;xaJmsConnectionFactory&quot;)</span><br><span class="line">private ConnectionFactory xaConnectionFactory;</span><br><span class="line"></span><br><span class="line">// Inject the non-XA aware ConnectionFactory</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;nonXaJmsConnectionFactory&quot;)</span><br><span class="line">private ConnectionFactory nonXaConnectionFactory;</span><br></pre></td></tr></table></figure>

<h4 id="Supporting-an-Alternative-Embedded-Transaction-Manager"><a href="#Supporting-an-Alternative-Embedded-Transaction-Manager" class="headerlink" title="Supporting an Alternative Embedded Transaction Manager"></a>Supporting an Alternative Embedded Transaction Manager</h4><p>XAConnectionFactoryWrapper 和 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.5.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java">XADataSourceWrapper</a> 接口可用于支持替代嵌入式事务经理。接口负责包装XAConnectionFactory和XADataSourcebean，并将它们作为常规ConnectionFactory和DataSourcebean 公开，它们透明地注册到分布式事务中。DataSource和JMS自动配置使用JTA变体，前提是您有一个JtaTransactionManagerbean和在您的域中注册的相应XA包装bean ApplicationContext。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.5.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java">BitronixXAConnectionFactoryWrapper</a> 和 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/blob/v2.1.5.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java">BitronixXADataSourceWrapper</a> 提供了如何编写XA包装很好的例子。</p>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>Wikipedia - Transaction Processing : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transaction_processing">https://en.wikipedia.org/wiki/Transaction_processing</a></li>
<li>Wikipedia - Transaction Processing System : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transaction_processing_system">https://en.wikipedia.org/wiki/Transaction_processing_system</a></li>
<li>Wikipedia - Java Transaction API : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_Transaction_API">https://en.wikipedia.org/wiki/Java_Transaction_API</a></li>
<li>baeldung - Guide to Java EE JTA : <a target="_blank" rel="noopener" href="https://www.baeldung.com/jee-jta">https://www.baeldung.com/jee-jta</a></li>
<li>spring.io - Distributed Transactions with JTA : <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-jta.html">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-jta.html</a></li>
<li>IBM Knowledge Center - Transaction Processing : <a target="_blank" rel="noopener" href="https://www.ibm.com/support/knowledgecenter/en/SSGMCP_5.2.0/com.ibm.cics.ts.productoverview.doc/concepts/TransactionProcessing.html">https://www.ibm.com/support/knowledgecenter/en/SSGMCP_5.2.0/com.ibm.cics.ts.productoverview.doc/concepts/TransactionProcessing.html</a></li>
<li>computerbusinessresearch - Transaction processing system : <a target="_blank" rel="noopener" href="http://www.computerbusinessresearch.com/Home/decision-making/transaction-processing-system">http://www.computerbusinessresearch.com/Home/decision-making/transaction-processing-system</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/05/21/TransactionProcessing/" data-id="ckvgcipjt001jplqhgjn2bbz2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/" rel="tag">Database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DatabaseTransaction/" rel="tag">DatabaseTransaction</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Transaction/" rel="tag">Transaction</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HackerLaws" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/20/HackerLaws/" class="article-date">
  <time datetime="2019-05-20T09:40:53.000Z" itemprop="datePublished">2019-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hacker-Laws/">Hacker Laws</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/20/HackerLaws/">HackerLaws</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h1><h2 id="GitHUb-hacker-laws"><a href="#GitHUb-hacker-laws" class="headerlink" title="GitHUb - hacker-laws"></a><a target="_blank" rel="noopener" href="https://github.com/dwmkerr/hacker-laws">GitHUb - hacker-laws</a></h2><h2 id="GitHUb-hacker-laws-zh"><a href="#GitHUb-hacker-laws-zh" class="headerlink" title="GitHUb - hacker-laws-zh"></a><a target="_blank" rel="noopener" href="https://github.com/nusr/hacker-laws-zh">GitHUb - hacker-laws-zh</a></h2><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>当人们谈论开发时，会聊到许多定律。 这个仓库收录了一些最常见的定律。</p>
<p>❗: 这个仓库包含对一些定律、原则以及模式的解释，但不提倡其中任何一个。它们的应用始终存在着争论，并且很大程度上取决于你正在做什么。</p>
<h1 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h1><h2 id="阿姆达尔定律-Amdahl’s-Law"><a href="#阿姆达尔定律-Amdahl’s-Law" class="headerlink" title="阿姆达尔定律 (Amdahl’s Law)"></a>阿姆达尔定律 (Amdahl’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Amdahl%27s_law">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B">中文维基百科</a></li>
</ul>
<blockquote>
<p>阿姆达尔定律是一个显示计算任务潜在加速能力的公式。这种能力可以通过增加系统资源来实现，通常用于并行计算中。它可以预测增加处理器数量的实际好处，然而增加处理器数量会受到程序并行性的限制。</p>
</blockquote>
<p>举例说明：如果程序由两部分组成，部分 A 必须由单个处理器执行，部分 B 可以并行运行。那么向执行程序的系统添加多个处理器只能获得有限的好处。它可以极大地提升部分 B 的运行速度，但部分 A 的运行速度将保持不变。</p>
<p>下图展示了运行速度的潜能：</p>
<p><img src="/img/hacker-laws/amdahls_law.png" alt="gcheap"></p>
<p>(图片来源: By Daniels220 at English Wikipedia, Creative Commons Attribution-Share Alike 3.0 Unported, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File:AmdahlsLaw.svg">https://en.wikipedia.org/wiki/File:AmdahlsLaw.svg</a>)</p>
<p>可以看出，50％ 并行化的程序仅仅受益于 10 个处理单元，而 95％ 并行化的程序可以通过超过一千个处理单元显著提升速度。</p>
<p>随着摩尔定律减慢，单个处理器的速度增加缓慢，并行化是提高性能的关键。图形编程是一个极好的例子，现代着色器可以并行渲染单个像素或片段。这也是为什么现代显卡通常具有数千个处理核心（GPU 或着色器单元）的原因。</p>
<p>参见：</p>
<ul>
<li><a href="#%E5%B8%83%E9%B2%81%E5%85%8B%E6%96%AF%E6%B3%95%E5%88%99-Brooks's-Law">布鲁克斯法则</a></li>
<li><a href="#%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B-Moore's-Law">摩尔定律</a></li>
</ul>
<h2 id="布鲁克斯法则-Brooks’s-Law"><a href="#布鲁克斯法则-Brooks’s-Law" class="headerlink" title="布鲁克斯法则 (Brooks’s Law)"></a>布鲁克斯法则 (Brooks’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.m.wikipedia.org/wiki/Brooks%27s_law">英文维基百科</a></li>
</ul>
<blockquote>
<p>软件开发后期，添加人力只会使项目开发得更慢。</p>
</blockquote>
<p>这个定律表明，在许多情况下，试图通过增加人力来加速延期项目的交付，将会使项目交付得更晚。布鲁克斯也明白，这是一种过度简化。但一般的推理是，新资源的增加时间和通信开销，会使开发速度减慢。而且，许多任务是不可分的，比如更多的资源容易分配，这也意味着潜在的速度增加也更低。</p>
<p>谚语 <strong>九个女人不能在一个月内生一个孩子</strong> 与布鲁克斯法则同出一辙，特别是某些不可分割或者并行的工作。</p>
<p>这是<a href="#%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95">《人月神话》</a>的中心主题。</p>
<p>参见：</p>
<ul>
<li>Death March</li>
<li>《人月神话》</li>
</ul>
<h2 id="康威定律-Conway’s-Law"><a href="#康威定律-Conway’s-Law" class="headerlink" title="康威定律 (Conway’s Law)"></a>康威定律 (Conway’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Conway%27s_law">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B">中文维基百科</a></li>
</ul>
<p>系统的技术边界受制于组织的结构。改进组织时，通常会提到它。康威定律表明，如果一个组织被分散成许多小而无联系的单元，那么它开发的软件也是小而分散的。如果一个组织更多地垂直建立在特性或其服务周围，那么软件系统也会反映这一点。</p>
<p>参见：</p>
<ul>
<li><a href="#">The Spotify Model</a></li>
</ul>
<h2 id="邓巴数字-Dunbar’s-Number"><a href="#邓巴数字-Dunbar’s-Number" class="headerlink" title="邓巴数字 (Dunbar’s Number)"></a>邓巴数字 (Dunbar’s Number)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dunbar%27s_number">英文维基百科</a></li>
</ul>
<p>邓巴数字是对一个人能够保持稳定社会关系的人数的认知极限——在这种关系中，一个人知道每个人是谁，也知道每个人与其他人的关系如何。而对这一数字的确切值则有着一些不同意见。邓巴指出，人仅能轻松地维持 150 个稳定的关系。这样的关系在一个更社会化的背景中，便是当你碰巧在酒吧里碰到这些人时候，你不会因为加入他们而感到尴尬。邓巴数字的估计值一般在 100 至 250 之间。</p>
<p>和人与人之间稳定的关系一样，开发人员与代码库的关系也需要努力维护。当面对大型、复杂的项目，或许多项目的归属权时，我们会依赖于约定、策略和建模过程来进行扩展。邓巴数字不仅在办公室规模的扩大的过程中举足轻重，而且在设置团队工作范围，或决定系统何时应该注重于辅助建模和组织管理开销自动化的工具时，也是非常重要的。将邓巴数字放入工程内容中进行类比，那就是您能加入并有信心随叫随到进行轮换的项目数(亦或是单个项目的规范化复杂性)。</p>
<h2 id="汉隆的剃刀（Hanlon’s-Razor）"><a href="#汉隆的剃刀（Hanlon’s-Razor）" class="headerlink" title="汉隆的剃刀（Hanlon’s Razor）"></a>汉隆的剃刀（Hanlon’s Razor）</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Conway%27s_law">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B">中文维基百科</a></li>
</ul>
<blockquote>
<p>能解释为愚蠢的，就不要解释为恶意的。<br>罗伯特 · 汉隆</p>
</blockquote>
<p>这一原则表明，一个行为所产生的消极结果并不是恶意。相反，消极结果更有可能归咎于这些没有得到充分理解的行动或影响。</p>
<h2 id="侯世达定律-Hofstadter’s-Law"><a href="#侯世达定律-Hofstadter’s-Law" class="headerlink" title="侯世达定律 (Hofstadter’s Law)"></a>侯世达定律 (Hofstadter’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hanlon%27s_razor">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B1%89%E9%9A%86%E7%9A%84%E5%89%83%E5%88%80">中文维基百科</a></li>
</ul>
<blockquote>
<p>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</p>
</blockquote>
<p>在估计需要多长时间开发时，你可能会听到此定律。软件开发似乎不言而喻，我们往往不能准确地估计需要多长时间才能完成。</p>
<p>语出《哥德尔、艾舍尔、巴赫：集异璧之大成》。</p>
<h2 id="技术成熟度曲线-The-Hype-Cycle-amp-Amara’s-Law"><a href="#技术成熟度曲线-The-Hype-Cycle-amp-Amara’s-Law" class="headerlink" title="技术成熟度曲线 (The Hype Cycle &amp; Amara’s Law)"></a>技术成熟度曲线 (The Hype Cycle &amp; Amara’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hype_cycle">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E6%88%90%E7%86%9F%E5%BA%A6%E6%9B%B2%E7%BA%BF">中文维基百科</a></li>
</ul>
<blockquote>
<p>我们倾向于过高估计技术在短期内的影响，并低估长期效应。<br>(罗伊·阿马拉)</p>
</blockquote>
<p>技术成熟度曲线是高德纳咨询公司对技术最初兴起和发展的视觉展现。一图顶千言：</p>
<p><img src="/img/hacker-laws/gartner_hype_cycle.png" alt="gcheap"></p>
<p>(图片来源: By Jeremykemp at English Wikipedia, CC BY-SA 3.0, <a target="_blank" rel="noopener" href="https://commons.wikimedia.org/w/index.php?curid=10547051">https://commons.wikimedia.org/w/index.php?curid=10547051</a>)</p>
<p>简而言之，这个周期表明，新技术及其潜在影响通常会引发一阵浪潮。团队快速使用这些新技术，有时会对结果感到失望。这可能是因为该技术还不够成熟，或者现实应用还没有完全实现。经过一段时间后，技术的能力提高了，使用它的实际机会会增加，最终团队也可以提高工作效率。罗伊·阿马拉简洁地总结了这一点：我们倾向于高估技术短期内的影响，并低估长期效应。</p>
<h2 id="隐式接口定律-Hyrum’s-Law"><a href="#隐式接口定律-Hyrum’s-Law" class="headerlink" title="隐式接口定律 (Hyrum’s Law)"></a>隐式接口定律 (Hyrum’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.hyrumslaw.com/">英文在线地址</a></li>
</ul>
<blockquote>
<p>API 有足够多的用户。 你在合同中的承诺并不重要： 你系统的所有可观察行为将取决于其他人。<br>（Hyrum Wright）</p>
</blockquote>
<p>隐式接口定律表明，当你的 API 有足够多的用户时，API 的所有行为（即使那些未被定义为公共说明的一部分）最终都会被其他人所依赖。 一个简单的例子，例如 API 的响应时间这种非功能性因素。 一个更微妙的例子是：用户使用正则表达式判断错误信息的类型时，即使 API 的公共说明没有说明消息的内容，来指示用户错误的类型。一些用户可能会使用该消息，并且更改该消息。实际上会破坏 API 的使用。</p>
<p>参见：</p>
<ul>
<li>漏洞抽象定律</li>
</ul>
<h2 id="摩尔定律-Moore’s-Law"><a href="#摩尔定律-Moore’s-Law" class="headerlink" title="摩尔定律 (Moore’s Law)"></a>摩尔定律 (Moore’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Moore%27s_law">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B">中文维基百科</a></li>
</ul>
<blockquote>
<p>集成电路中的晶体管数量大约每两年翻一番。</p>
</blockquote>
<p>通常用于说明半导体和芯片技术提高的绝对速度。从 20 世纪 70 年代到 21 世纪后期，摩尔的预测被证明是高度准确的。 近年来，这种趋势略有变化，部分原因受到量子隧穿效应影响。然而，并行化计算的进步以及半导体技术和量子计算潜在的革命性变化，可能意味着摩尔定律在未来几十年内继续保持正确。</p>
<h2 id="帕金森定理-Parkinson’s-Law"><a href="#帕金森定理-Parkinson’s-Law" class="headerlink" title="帕金森定理 (Parkinson’s Law)"></a>帕金森定理 (Parkinson’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Parkinson%27s_law">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B8%95%E9%87%91%E6%A3%AE%E5%AE%9A%E7%90%86">中文维基百科</a></li>
</ul>
<blockquote>
<p>在工作能够完成的时限内，工作量会一直增加，直到所有可用时间都被填满为止。</p>
</blockquote>
<p>基于官僚机构的研究背景，该定律被应用于软件开发中。该理论认为，团队在截止日期之前效率低下，然后在截止日期前赶紧完成工作，从而使实际截止日期变得随意。</p>
<p>将这个定理与侯世达定律相结合，则会获得更加悲观的观点：为了在规定时间内完成工作，工作将增多，花费比预期更长的时间。</p>
<p>参见：</p>
<ul>
<li><a href="#%E4%BE%AF%E4%B8%96%E8%BE%BE%E5%AE%9A%E5%BE%8B-Hofstadter's-Law">侯世达定律</a></li>
</ul>
<h2 id="普特定律-Putt’s-Law"><a href="#普特定律-Putt’s-Law" class="headerlink" title="普特定律 (Putt’s Law)"></a>普特定律 (Putt’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Putt%27s_Law_and_the_Successful_Technocrat">英文维基百科</a></li>
</ul>
<blockquote>
<p>技术由两类人主导，一类是纯粹的管理人员， 一类是纯粹的技术人员。</p>
</blockquote>
<p>普特定律常常遵循普特推论：</p>
<blockquote>
<p>每一个技术层次，假以时日，能力将逆转。</p>
</blockquote>
<p>这些结论表明，由于各种选择标准和群体组织的趋势，技术组织的工作层面将有一些技术人员，以及一些不了解复杂性和挑战的管理人员。这种现象可能是由于 The Peter Principe 或 Dilbert’s Law 造成的。</p>
<p>但是，应该强调的是，诸如此类的定律是一种广泛的概括，可能适用于某些类型的组织，而不适用于其他组织。</p>
<p>参见：</p>
<ul>
<li>The Peter Principe</li>
<li>Dilbert’s Law.</li>
</ul>
<h2 id="复杂性守恒定律-The-Law-of-Conservation-of-Complexity"><a href="#复杂性守恒定律-The-Law-of-Conservation-of-Complexity" class="headerlink" title="复杂性守恒定律 (The Law of Conservation of Complexity)"></a>复杂性守恒定律 (The Law of Conservation of Complexity)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Law_of_conservation_of_complexity">英文维基百科</a></li>
</ul>
<p>该定律表明系统中存在着一定程度的复杂性，并且不能减少。</p>
<p>系统中的某些复杂性是无意的。这是由于结构不良，错误或者糟糕的建模造成的。可以减少以及消除无意的复杂性。然而，由于待解决问题固有的复杂性，某些复杂性是内在的。这种复杂性可以转移，但不能消除。</p>
<p>该定律有趣的一点是，即使简化整个系统，内在的复杂性也不会降低。它会转移到用户，并且用户必须以更复杂的方式行事。</p>
<h2 id="漏洞抽象定律-The-Law-of-Leaky-Abstractions"><a href="#漏洞抽象定律-The-Law-of-Leaky-Abstractions" class="headerlink" title="漏洞抽象定律 (The Law of Leaky Abstractions)"></a>漏洞抽象定律 (The Law of Leaky Abstractions)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">英文维基百科</a></li>
</ul>
<blockquote>
<p>在某种程度上，所有非平凡的抽象都是漏洞。<br>(乔尔斯·波尔斯基)</p>
</blockquote>
<p>该定律指出，通常用于简化复杂系统的抽象，某些情况下将在底层系统爆出漏洞，这使得抽象表现为意外的方式。</p>
<p>例如加载文件并读取其内容。文件系统 API 是较低级别内核系统的抽象，它们本身是与磁盘（或 SSD 的闪存）上的数据更改相关的物理过程抽象。在大多数情况下，处理文件（如二进制数据流）的抽象将起作用。但是，对于磁盘驱动器，顺序读取数据将比随机访问快得多（由于页面错误的开销增加）。但对于 SSD 驱动器，此开销不会出现。需要理解基础细节来处理这种情况（例如，数据库索引文件的良好结构可以减少随机访问的开销），开发人员需要合理的抽象，来处理不同的细节。</p>
<p>当引入的抽象更多时，上面的例子会变得更复杂。Linux 操作系统允许通过网络访问文件，但在本地表示为普通文件。如果存在网络故障，这种抽象将有漏洞。如果开发人员将这些文件视为普通文件，而不考虑它们可能会受到网络延迟和故障的影响，那么解决方案就会出错。</p>
<p>描述该定律的文章表明，过度依赖抽象，加上对底层过程的理解不足，实际上使得问题在某些情况下更加复杂。</p>
<p>参见：</p>
<ul>
<li><a href="#%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%AE%9A%E5%BE%8B-Hyrum's-Law">隐式接口定律</a></li>
</ul>
<p>真实的例子：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/nusr/hacker-laws-zh#TODO">Photoshop 启动缓慢</a>：我过去遇到过一个问题，就是 Photoshop 启动缓慢，有时需要几分钟。问题好像是 Photoshop 启动时，会读取当前默认打印机的一些信息。但是，如果该打印机实际上是一台网络打印机，则可能需要很长的时间。将网络打印机与本地打印机当作同样的抽象，导致连接不良的情况下出现问题。</li>
</ul>
<h2 id="帕金森琐碎定理-The-Law-of-Triviality"><a href="#帕金森琐碎定理-The-Law-of-Triviality" class="headerlink" title="帕金森琐碎定理 (The Law of Triviality)"></a>帕金森琐碎定理 (The Law of Triviality)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Law_of_triviality">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B8%95%E9%87%91%E6%A3%AE%E7%91%A3%E7%A2%8E%E5%AE%9A%E7%90%86">中文维基百科</a></li>
</ul>
<p>该定理显示，群体将给予更多的时间和注意力来处理琐碎的问题，而不是用来处理严肃而实质性的问题。</p>
<p>常见的虚构例子是委员会批准核电站的计划，他们大部分时间都在讨论自行车棚的结构，而不是电厂本身等更为重要的设计。如果没有大量的专业知识或者准备，很难给非常大的复杂主题讨论提供宝贵的意见。但是，人们希望看到更多意见。因此，倾向于将过多的时间集中在小细节上，这很容易推理，但不被看重。</p>
<p>上面的虚构例子导致使用 Bike Shedding 这个词，作为在琐碎细节上浪费时间的表达。</p>
<h2 id="Unix-哲学-The-Unix-Philosophy"><a href="#Unix-哲学-The-Unix-Philosophy" class="headerlink" title="Unix 哲学 (The Unix Philosophy)"></a>Unix 哲学 (The Unix Philosophy)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_philosophy">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6">中文维基百科</a></li>
</ul>
<p>Unix 哲学指软件组件应该很小，并专注于做一件特定的事情。将小而简单以及定义良好的单元组合在一起，而不是使用大而复杂的多用途程序，可以更轻松地构建系统。</p>
<p>像微服务架构这种现代实践可以认为是这种哲学的应用，其中服务很小，集中于做一件特定的事情，由简单的构建块组成复杂的行为。</p>
<h2 id="Spotify-模型-The-Spotify-Model"><a href="#Spotify-模型-The-Spotify-Model" class="headerlink" title="Spotify 模型 (The Spotify Model)"></a>Spotify 模型 (The Spotify Model)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://labs.spotify.com/2014/03/27/spotify-engineering-culture-part-1/">英文在线地址</a></li>
</ul>
<p>Spotify 模型是团队和组织结构的一种方法，已被 Spotify 实验室推广开来。在此模型中，团队围绕功能而非技术进行组织。</p>
<p>Spotify 模型还普及了部落、行会以及章节的概念，这些是组织结构的其他组成部分。</p>
<h2 id="沃德勒定律-Wadler’s-Law"><a href="#沃德勒定律-Wadler’s-Law" class="headerlink" title="沃德勒定律 (Wadler’s Law)"></a>沃德勒定律 (Wadler’s Law)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wiki.haskell.org/Wadler's_Law">英文在线地址</a></li>
</ul>
<blockquote>
<p>任何语言设计中，讨论下面列表中某个要素所花费的总时间与其位置成正比。  </p>
<ol>
<li>语义 (Semantics)</li>
<li>语法 (Syntax)</li>
<li>词法 (Lexical syntax)</li>
<li>注释语法 (Lexical syntax of comments)<br>（简而言之，在语义上花费一个小时，就要在注释语法上花费八个小时）。</li>
</ol>
</blockquote>
<p>与 帕金森琐碎定理 类似, 沃德勒定律指出，在设计语言时，与这些特征的重要性相比，花在语言结构上的时间过多。</p>
<p>参见：</p>
<ul>
<li><a href="#%E5%B8%95%E9%87%91%E6%A3%AE%E7%90%90%E7%A2%8E%E5%AE%9A%E7%90%86-The-Law-of-Triviality">帕金森琐碎定理</a></li>
</ul>
<h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><p>原则通常是与设计相关的准则。</p>
<h2 id="帕累托法则-The-Pareto-Principle-or-The-80-20-Rule"><a href="#帕累托法则-The-Pareto-Principle-or-The-80-20-Rule" class="headerlink" title="帕累托法则 (The Pareto Principle or The 80/20 Rule)"></a>帕累托法则 (The Pareto Principle or The 80/20 Rule)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pareto_principle">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B8%95%E7%B4%AF%E6%89%98%E6%B3%95%E5%88%99">中文维基百科</a></li>
</ul>
<blockquote>
<p>生活中大多数事情不是均匀分布的。</p>
</blockquote>
<p>帕累托法则可以帮你认识到大多数结果来自少数投入：</p>
<ul>
<li>某个软件的 80％ 代码只占了总分配时间的 20％（相反，最难的 20％ 代码部分占用了 80％ 的时间）</li>
<li>20％ 的努力产生了 80％ 的结果</li>
<li>20％ 的工作创造了 80％ 的收入</li>
<li>20％ 的错误导致了 80％ 的崩溃</li>
<li>20％ 的功能导致了 80％ 的使用量</li>
</ul>
<p>在 20 世纪 40 年代，公认为质量控制之父的美国罗马尼亚工程师<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Joseph_M._Juran">约瑟夫·朱兰博士博士</a>,开始将帕累托法则应用于质量问题。</p>
<p>这个原则也被称为二八法则，重要的少数法则和因素稀疏原则。</p>
<p>现实的例子：</p>
<ul>
<li>微软 2002 年的报告表明，修复最常出现的 20％ 错误，将消除 Windows 和 Office 中 80％ 的 错误和崩溃。<a target="_blank" rel="noopener" href="https://www.crn.com/news/security/18821726/microsofts-ceo-80-20-rule-applies-to-bugs-not-just-features.htm">报告地址</a></li>
</ul>
<h2 id="鲁棒性原则-The-Robustness-Principle"><a href="#鲁棒性原则-The-Robustness-Principle" class="headerlink" title="鲁棒性原则 (The Robustness Principle)"></a>鲁棒性原则 (The Robustness Principle)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Robustness_principle">英文维基百科</a></li>
</ul>
<blockquote>
<p>在自己所做的事情上要保守, 在接受别人的事情上要自由。</p>
</blockquote>
<p>通常应用于服务器应用程序开发中，该原则指出，你发送给其他人的内容应尽可能最小且符合要求，并且处理不符合要求的输入。</p>
<p>该原则的目标是构建稳健的系统。如果可以理解意图，它们可以处理不良的输入。但是，接受错误格式的输入可能存在安全隐患，特别是此类的输入未经过充分测试。</p>
<h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><p>这是一个缩写，指的是：</p>
<ul>
<li>S：单一功能原则 (The Single Responsibility Principle)</li>
<li>O：开闭原则 (The Open/Closed Principle)</li>
<li>L：里氏替换原则 (The Liskov Substitution Principle)</li>
<li>I：接口隔离原则 (The Interface Segregation Principle)</li>
<li>D：依赖反转原则 (The Dependency Inversion Principle)</li>
</ul>
<p>这些是 Object-Oriented Programming 的关键原则。诸如此类的设计原则能够帮助开发人员构建更易于维护的系统。</p>
<h3 id="单一功能原则-The-Single-Responsibility-Principle"><a href="#单一功能原则-The-Single-Responsibility-Principle" class="headerlink" title="单一功能原则 (The Single Responsibility Principle)"></a>单一功能原则 (The Single Responsibility Principle)</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">中文维基百科</a></li>
</ul>
<blockquote>
<p>每个模块或者类只应该有一项功能。</p>
</blockquote>
<p>SOLID 的第一个原则。这个原则表明模块或者类只应该做一件事。实际上，这意味着对程序功能的单个小更改，应该只需要更改一个组件。例如，更改密码验证复杂性的方式应该只需要更改程序的一部分。</p>
<p>理论上讲，这使代码更健壮，更容易更改。知道正在更改的组件只有一个功能，这意味着测试更改更容易。使用前面的例子，更改密码复杂性组件应该只影响与密码复杂性相关的功能。变更具有许多功能的组件可能要困难得多。</p>
<h3 id="开闭原则-The-Open-Closed-Principle"><a href="#开闭原则-The-Open-Closed-Principle" class="headerlink" title="开闭原则 (The Open/Closed Principle)"></a>开闭原则 (The Open/Closed Principle)</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">中文维基百科</a></li>
</ul>
<blockquote>
<p>实体应开放扩展并关闭修改。</p>
</blockquote>
<p>SOLID 的第二个原则。这个原则指出实体（可以是类、模块、函数等）应该能够使它们的行为易于扩展，但是它们的扩展行为不应该被修改。</p>
<p>举一个假设的例子，想象一个能够将 Markdown 转换为 HTML 的模块。如果可以扩展模块，而不修改内部模块来处理新的 markdown 特征，而无需修改内部模块，则可以认为是开放扩展。如果用户不能修改处理现有 Markdown 特征的模块，那么它被认为是关闭修改。</p>
<p>这个原则与面向对象编程紧密相关，让我们可以设计对象以便于扩展，但是可以避免以意想不到的方式改变其现有对象的行为。</p>
<h3 id="里氏替换原则-The-Liskov-Substitution-Principle"><a href="#里氏替换原则-The-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 (The Liskov Substitution Principle)"></a>里氏替换原则 (The Liskov Substitution Principle)</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">中文维基百科</a></li>
</ul>
<blockquote>
<p>可以在不破坏系统的情况下，可以用子类型替换类型。</p>
</blockquote>
<p>SOLID 的第三个原则。该原则指出，如果组件依赖于类型，那么它应该能够使用该类型的子类型，而不会导致系统失败或者必须知道该子类型的详细信息。</p>
<p>举个例子，假设我们有一个方法，读取 XML 文档。如果该方法使用基类型 file，则从 file 派生的任何内容，都能用在该方法中。 如果 file 支持反向查找，并且 xml 解析器使用该函数，但是派生类型 network file 尝试反向查找时失败，则 network file 将违反该原则。</p>
<p>该原则与面向对象编程紧密相关，必须仔细建模、层次结构，以避免混淆系统用户。</p>
<h3 id="接口隔离原则-The-Interface-Segregation-Principle"><a href="#接口隔离原则-The-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则 (The Interface Segregation Principle)"></a>接口隔离原则 (The Interface Segregation Principle)</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interface_segregation_principle">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">中文维基百科</a></li>
</ul>
<blockquote>
<p>不应强制任何客户端依赖于它不使用的方法。</p>
</blockquote>
<p>SOLID 的第四个原则。该原则指出组件的消费者不应该依赖于它实际上不使用的组件函数。</p>
<p>举一个例子，假设我们有一个方法，读取 XML 文档。它只需要读取文件中的字节，向前移动或向后移动。如果由于文件结构不相关（例如更新文件安全性的权限模型），需要更新此方法，则该原则已失效。文件最好实现 可查询流 接口，并让 XML 读取器使用该接口。</p>
<p>该原则与面向对象编程紧密相关，其中接口，层次结构和抽象类型用于不同组件的 minimise the coupling。 Duck typing 是一种通过消除显式接口来强制执行该原则的方法。</p>
<p>参见：</p>
<ul>
<li>Duck Typing</li>
<li>Decoupling</li>
</ul>
<h3 id="依赖反转原则-The-Dependency-Inversion-Principle"><a href="#依赖反转原则-The-Dependency-Inversion-Principle" class="headerlink" title="依赖反转原则 (The Dependency Inversion Principle)"></a>依赖反转原则 (The Dependency Inversion Principle)</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99">中文维基百科</a></li>
</ul>
<blockquote>
<p>高级模块不应该依赖于低级实现。</p>
</blockquote>
<p>SOLID 的第五个原则。该原则指出，更高级别的协调组件不应该知道其依赖项的详细信息。</p>
<p>举个例子，假设我们有一个从网站读取元数据的程序。我们假设主要组件必须知道下载网页内容的组件，以及可以读取元数据的组件。如果我们考虑依赖反转，主要组件将仅依赖于可以获取字节数据的抽象组件，然后是一个能够从字节流中读取元数据的抽象组件，主要组件不需要了解 TCP、IP、HTTP、HTML 等。</p>
<p>这个原则很复杂，因为它似乎可以反转系统的预期依赖性（因此得名）。实践中，这也意味着，单独的编排组件必须确保抽象类型的正确实现被使用（例如在前面的例子中，必须提供元数据读取器组件、HTTP 文件下载功能和 HTML 元标签读取器）。然后，这涉及诸如 Inversion of Control 和 Dependency Injection 之类的模式。</p>
<p>参见：</p>
<ul>
<li>Inversion of Control</li>
<li>Dependency Injection</li>
</ul>
<h2 id="不要重复你自己原则-The-DRY-Principle"><a href="#不要重复你自己原则-The-DRY-Principle" class="headerlink" title="不要重复你自己原则 (The DRY Principle)"></a>不要重复你自己原则 (The DRY Principle)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">英文维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1">中文维基百科</a></li>
</ul>
<blockquote>
<p>系统中，每一块知识都必须是单一、明确而权威的。</p>
</blockquote>
<p>DRY 是 <strong>Do not Repeat Yourself</strong> 的缩写。这个原则旨在帮助开发人员减少代码的重复性，并将公共代码保存在一个地方。最初由安德鲁·亨特和戴夫·托马斯在 1999 年出版的《程序员修炼之道》中引用。</p>
<blockquote>
<p> DRY 相反的是 WET（功能实现两次或者喜欢打字 Write Everything Twice or We Enjoy Typing）。</p>
</blockquote>
<p>实际上，如果你在两个或更多的地方有相同的功能，你可以使用 DRY 原则将它们合并为一个，并在任何你需要的地方重复使用。</p>
<p>参见：</p>
<ul>
<li>《程序员修炼之道》<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/The_Pragmatic_Programmer">英文维基百科</a></li>
<li>《程序员修炼之道》<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1417047/">豆瓣</a></li>
</ul>
<h2 id="你不需要它原则-YAGNI"><a href="#你不需要它原则-YAGNI" class="headerlink" title="你不需要它原则 (YAGNI)"></a>你不需要它原则 (YAGNI)</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">英文维基百科</a></li>
</ul>
<p>这是 You Aren’t Gonna Need It 的缩写。</p>
<blockquote>
<p>只有当你需要某些东西的时候，才去实现它们，而不是在你预见的时候。<br>Ron Jeffries 是极限编程的创始人之一以及书籍《Extreme Programming Installed》的作者。</p>
</blockquote>
<p>极限编程原则告诫开发人员，他们应该只实现当前所需的功能，并避免实现未来需要的功能，仅在必要时才实现。</p>
<p>遵守这一原则可以减小代码库大小，同时避免时间和生产力浪费在没有价值的功能上。</p>
<p>参见：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.goodreads.com/en/book/show/67834.Extreme_Programming_Installed">Extreme Programming Installed</a></li>
</ul>
<h1 id="阅读清单"><a href="#阅读清单" class="headerlink" title="阅读清单"></a>阅读清单</h1><p>如果你觉得这些概念很有趣，你可能会喜欢以下书籍。</p>
<ul>
<li>《人月神话》<a target="_blank" rel="noopener" href="https://www.goodreads.com/book/show/13629.The_Mythical_Man_Month">谷歌阅读地址</a>、<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26358448/">豆瓣地址</a> - 软件工程的经典书籍。这本书的中心主题就是<a href="#%E5%B8%83%E9%B2%81%E5%85%8B%E6%96%AF%E6%B3%95%E5%88%99-Brooks's-Law">布鲁克斯法则</a> 。</li>
<li>《哥德尔、艾舍尔、巴赫：集异璧之大成》<a target="_blank" rel="noopener" href="https://www.goodreads.com/book/show/24113.G_del_Escher_Bach">谷歌阅读地址</a>、<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1291204/">豆瓣地址</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/05/20/HackerLaws/" data-id="ckvgcipj50003plqh3eic2r2t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hacker-laws/" rel="tag">hacker laws</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/laws/" rel="tag">laws</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Kubernetes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/15/Kubernetes/" class="article-date">
  <time datetime="2019-05-15T01:17:59.000Z" itemprop="datePublished">2019-05-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Container-Orchestration/">Container Orchestration</a>►<a class="article-category-link" href="/categories/Kubernetes/">Kubernetes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/15/Kubernetes/">Kubernetes</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-Containerized"><a href="#What-is-Containerized" class="headerlink" title="What is Containerized?"></a>What is Containerized?</h1><p>操作系统层虚拟化（英语：Operating system–level virtualization），亦称容器化（英语：Containerization），是一种虚拟化技术，这种技术将操作系统内核虚拟化，可以允许用户空间软件实例（instances）被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。</p>
<p>这个软件实例，也被称为是一个 containers(Solaris, Docker), Zones(Solaris), virtual private servers(OpenVZ), partitions , virutial environments(VEs), virtual kernel(DragonFly BSD) 或是 jails(FreeBSD jail或chroot jail) 。从运行在其中的程序的角度来看，它可能看起来像真正的计算机。在普通操作系统上运行的计算机程序可以看到该计算机的所有资源（连接的设备，文件和文件夹，网络共享，CPU功率，可量化的硬件能力）。但是，在容器内运行的程序只能看到容器的内容和分配给容器的设备。</p>
<p>操作系统层虚拟化之后，可以实现软件的即时迁移（Live migration），使一个软件容器中的实例，即时移动到另一个操作系统下，再重新运行起来。但是在这种技术下，软件即时迁移，只能在同样的操作系统下进行。</p>
<p>在类Unix操作系统中，这个技术最早起源于标准的chroot机制，再进一步演化而成。除了将软件独立化的机制之外，内核通常也提供资源管理功能，使得单一软件容器在运作时，对于其他软件容器的造成的交互影响最小化。</p>
<p>相对于传统的虚拟化（Virtualization），容器化的优势在于占用服务器空间少，通常几秒内即可引导。同时容器的弹性可以在资源需求增加时瞬时复制增容，在资源需求减小时释放空间以供其他用户使用。由于在同一台服务器上的容器实例共享同一个系统内核，因此在运行上不会存在实例与主机操作系统争夺RAM的问题发生，从而能够保证实例的性能。</p>
<p>术语“容器”虽然最普遍地指代OS级虚拟化系统，但有时模糊地用于指代与主机OS不同程度地操作的更全面的虚拟机环境，例如Microsoft的 “Hyper-V容器”。</p>
<h2 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h2><p>在个人计算机的普通操作系统上，计算机程序可以看到（即使它可能无法访问）所有系统的资源。他们包括：</p>
<ul>
<li>可以采用的硬件功能，例如CPU和网络连接</li>
<li>可以读取或写入的数据，例如文件，文件夹和网络共享</li>
<li>它可以与之相互连接的外围设备，例如网络摄像头，打印机，扫描仪或传真机</li>
<li>操作系统可能能够基于哪个程序在其运行的上下文中请求它们和用户帐户来允许或拒绝对这些资源的访问。操作系统还可以隐藏这些资源，以便当计算机程序枚举它们时，它们不会出现在枚举结果中。然而，从编程的角度来看，计算机程序已与这些资源交互，并且操作系统已经管理了交互行为。</li>
</ul>
<p>通过操作系统虚拟化或容器化，可以在容器内运行程序，只分配这些资源的一部分。一个程序希望看到整个计算机，一旦在容器内运行，只能看到分配的资源并认为它们是可用的全部。可以在每个操作系统上创建几个容器，为每个容器分配计算机资源的子集。每个容器可以包含任意数量的计算机程序。这些程序可以同时或分开运行，甚至可以相互交互。</p>
<p>容器化与应用程序虚拟化有相似之处：在后者中，只有一个计算机程序放在隔离的容器中，隔离仅适用于文件系统。</p>
<h1 id="What-is-a-Container"><a href="#What-is-a-Container" class="headerlink" title="What is a Container?"></a>What is a Container?</h1><p>一个容器（Linux容器）的核心是主机（计算机）资源的 allocation， portioning 和 assignment，例如 CPU Shares ，网络 I/O ，带宽， 块 I/O 和 内存（RAM），以便内核级别构造可以监控，隔离或“包含”这些受保护的资源，以便特定的运行服务（进程）和命名空间可以单独使用它们而不会干扰系统的其余部分。这些进程可以是基于Linux镜像的轻量级Linux主机，多个Web服务器和应用程序，单个子系统（如数据库后端），也可以是单个进程，例如 echo “Hello”，几乎没有开销。</p>
<p>通常称为 “OS-level virtualization” 或 “OS Vitual Environments” 的 容器 与 虚拟机管理程序级 的 虚拟化 不同。主要区别在于容器模型消除了通常在VM中运行工作负载所需的虚拟机管理程序层，冗余OS内核，二进制文件和库。</p>
<h1 id="What-is-Kubernetes"><a href="#What-is-Kubernetes" class="headerlink" title="What is Kubernetes?"></a>What is Kubernetes?</h1><p>Kubernetes（常简称为K8s）是用于自动部署、扩展和管理容器化（containerized）应用程序的开源系统，是一个跨主机集群的开源的容器调度平台，它可以自动化应用容器的部署、扩展和操作,提供以容器为中心的基础架构。该系统由Google设计并捐赠给Cloud Native Computing Foundation（今属Linux基金会）来使用。</p>
<p>它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。它支持一系列容器工具, 包括Docker等。CNCF于2017年宣布首批Kubernetes认证服务提供商（KCSPs），包含IBM、华为、MIRANTIS、inwinSTACK迎栈科技等服务商。</p>
<h2 id="Kubernetes-and-Docker"><a href="#Kubernetes-and-Docker" class="headerlink" title="Kubernetes and Docker"></a>Kubernetes and Docker</h2><p>Kubernetes不会取代Docker，但会增加它。但是，Kubernetes 确实取代了Docker中出现的一些更高级别的技术。</p>
<p>其中一种技术是Docker Swarm，一个与Docker捆绑在一起的编排器。仍然可以使用Docker Swarm而不是Kubernetes，但Docker Inc.已经选择让Kubernetes成为Docker社区和Docker Enterprise版本的一部分。</p>
<p>并不是说Kubernetes是Docker Swarm的直接替代品。Kubernetes比Swarm复杂得多，需要更多的工作才能部署。但同样，这项工作旨在从长远来看提供巨大的回报 - 一个更易于管理，更具弹性的应用程序基础架构。对于开发工作和较小的容器集群，Docker Swarm提供了一个更简单的选择。 </p>
<h2 id="Kubernetes-and-Mesos"><a href="#Kubernetes-and-Mesos" class="headerlink" title="Kubernetes and Mesos"></a>Kubernetes and Mesos</h2><p>作为Kubernetes的竞争对手，你可能听说过的另一个项目是Mesos。Mesos是一个Apache项目，最初来自Twitter的开发人员; 它实际上被视为Google Borg项目的答案。</p>
<p>事实上，Mesos确实提供了容器编排服务，但它的雄心远不止于此：它的目标是成为一种可以协调容器化和非容器化组件的云操作系统。为此，许多不同的平台可以在Mesos中运行 - 包括Kubernetes本身。</p>
<h2 id="Why-use-containers"><a href="#Why-use-containers" class="headerlink" title="Why use containers?"></a>Why use containers?</h2><p><img src="/img/kubernetes/why_containers.svg" alt="gcheap"></p>
<p>传统 部署应用程序的方式，一般是使用操作系统自带的包管理器在主机上安装应用依赖，之后再安装应用程序。这无疑将应用程序的可执行文件、应用的配置、应用依赖库和应用的生命周期与宿主机操作系统进行了紧耦合。在此情境下，可以通过构建不可改变的虚拟机镜像版本，通过镜像版本实现可预测的发布和回滚，但是虚拟机实在是太重量级了，且镜像体积太庞大，便捷性差。</p>
<p>新方式 是基于操作系统级虚拟化而不是硬件级虚拟化方法来部署容器。容器之间彼此隔离并与主机隔离：它们具有自己的文件系统，不能看到彼此的进程，并且它们所使用的计算资源是可以被限制的。它们比虚拟机更容易构建，并且因为它们与底层基础架构和主机文件系统隔离，所以它们可以跨云和操作系统快速分发。</p>
<p>由于容器体积小且启动快，因此可以在每个容器镜像中打包一个应用程序。这种一对一的应用镜像关系拥有很多好处。使用容器，不需要与外部的基础架构环境绑定, 因为每一个应用程序都不需要外部依赖，更不需要与外部的基础架构环境依赖。完美解决了从开发到生产环境的一致性问题。</p>
<p>容器同样比虚拟机更加透明，这有助于监测和管理。尤其是容器进程的生命周期由基础设施管理，而不是由容器内的进程对外隐藏时更是如此。最后，每个应用程序用容器封装，管理容器部署就等同于管理应用程序部署。</p>
<p>容器优点摘要:</p>
<ul>
<li>敏捷的应用程序创建和部署: 与虚拟机镜像相比，容器镜像更容易创建，提升了硬件的使用效率。</li>
<li>持续开发、集成和部署: 提供可靠与频繁的容器镜像构建和部署，可以很方便及快速的回滚 (由于镜像不可变性).</li>
<li>关注开发与运维的分离: 在构建/发布时创建应用程序容器镜像，从而将应用程序与基础架构分离。</li>
<li>开发、测试和生产环境的一致性: 在笔记本电脑上运行与云中一样。</li>
<li>云和操作系统的可移植性: 可运行在 Ubuntu, RHEL, CoreOS, 内部部署, Google 容器引擎和其他任何地方。</li>
<li>以应用为中心的管理: 提升了操作系统的抽象级别，以便在使用逻辑资源的操作系统上运行应用程序。</li>
<li>松耦合、分布式、弹性伸缩 微服务: 应用程序被分成更小，更独立的部分，可以动态部署和管理 - 而不是巨型单体应用运行在专用的大型机上。</li>
<li>资源隔离: 通过对应用进行资源隔离，可以很容易的预测应用程序性能。</li>
<li>资源利用: 高效率和高密度。</li>
</ul>
<h2 id="Kubernetes-Feature"><a href="#Kubernetes-Feature" class="headerlink" title="Kubernetes Feature"></a>Kubernetes Feature</h2><p>最基础的，Kubernetes 可以在物理或虚拟机集群上调度和运行应用程序容器。然而，Kubernetes 还允许开发人员从物理和虚拟机’脱离’，从以主机为中心的基础架构转移到以容器为中心的基础架构，这样可以提供容器固有的全部优点和益处。Kubernetes 提供了基础设施来构建一个真正以容器为中心的开发环境。</p>
<p>Kubernetes 满足了生产中运行应用程序的许多常见的需求，例如：</p>
<ul>
<li>Pod 提供复合应用并保留一个应用一个容器的容器模型</li>
<li>挂载外部存储</li>
<li>Secret管理</li>
<li>应用健康检查</li>
<li>副本应用实例</li>
<li>横向自动扩缩容</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>滚动更新</li>
<li>资源监测</li>
<li>日志采集和存储</li>
<li>支持自检和调试</li>
<li>认证和鉴权</li>
</ul>
<p>这提供了平台即服务 (PaaS) 的简单性以及基础架构即服务 (IaaS) 的灵活性，并促进跨基础设施供应商的可移植性。</p>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/">kubernetes docs</a></p>
<p>Kubernetes 提供了很多的功能，总会有新的场景受益于新特性。它可以简化应用程序的工作流，加快开发速度。被大家认可的应用编排通常需要有较强的自动化能力。这就是为什么 Kubernetes 被设计作为构建组件和工具的生态系统平台，以便更轻松地部署、扩展和管理应用程序。</p>
<p>Kubernetes 不是一个传统意义上，包罗万象的 PaaS (平台即服务) 系统。</p>
<ul>
<li>Kubernetes 不限制支持的应用程序类型。 它不插手应用程序框架 (例如 Wildfly), 不限制支持的语言运行时 (例如 Java, Python, Ruby)，只迎合符合 12种因素的应用程序，也不区分”应用程序”与”服务”。Kubernetes 旨在支持极其多样化的工作负载，包括无状态、有状态和数据处理工作负载。如果应用可以在容器中运行，它就可以在 Kubernetes 上运行。</li>
<li>Kubernetes 不提供作为内置服务的中间件 (例如 消息中间件)、数据处理框架 (例如 Spark)、数据库 (例如 mysql)或集群存储系统 (例如 Ceph)。这些应用可以运行在 Kubernetes 上。</li>
<li>Kubernetes 没有提供点击即部署的服务市场</li>
<li>Kubernetes 从源代码到镜像都是非垄断的。 它不部署源代码且不构建您的应用程序。 持续集成 (CI) 工作流是一个不同用户和项目都有自己需求和偏好的领域。 所以支持在 Kubernetes 分层的 CI 工作流，但不指定它应该如何工作。</li>
<li>Kubernetes 允许用户选择其他的日志记录，监控和告警系统 (虽然我们提供一些集成作为概念验证)</li>
<li>Kubernetes 不提供或授权一个全面的应用程序配置语言/系统 (例如 jsonnet).</li>
<li>Kubernetes 不提供也不采用任何全面机器配置、保养、管理或自我修复系统</li>
</ul>
<p>另一方面，许多 PaaS 系统运行 在 Kubernetes 上面，例如 Openshift, Deis, and Eldarion。 您也可以自定义您自己的 PaaS, 与您选择的 CI 系统集成，或与 Kubernetes 一起使用: 将您的容器镜像部署到 Kubernetes。</p>
<p>由于 Kubernetes 在应用级别而不仅仅在硬件级别上运行，因此它提供 PaaS 产品通用的一些功能，例如部署、扩展、负载均衡、日志记录、监控等。但是，Kubernetes 不是单一的，默认解决方案是可选和可插拔的。</p>
<p>此处，Kubernetes 不仅仅是一个 “编排系统”；它消除了编排的需要。 “编排”技术定义的是工作流的执行: 从 A 到 B，然后到 C。相反，Kubernetes 是包括一套独立、可组合的控制过程，通过声明式语法使其连续地朝着期望状态驱动当前状态。 不需要告诉它具体从 A 到 C 的过程，只要告诉到 C 的状态即可。 也不需要集中控制；该方法更类似于”编舞”。这使得系统更容易使用并且更强大、更可靠、更具弹性和可扩展性。</p>
<h1 id="How-Kubernetes-works"><a href="#How-Kubernetes-works" class="headerlink" title="How Kubernetes works"></a>How Kubernetes works</h1><p>Kubernetes的架构利用了各种概念和抽象。其中一些是现有的，熟悉的概念的变体，但其他一些是Kubernetes特有的。</p>
<h2 id="Kubnernetes-clusters"><a href="#Kubnernetes-clusters" class="headerlink" title="Kubnernetes clusters"></a>Kubnernetes clusters</h2><p>最高级别的Kubernetes抽象即集群，指的是运行Kubernetes（本身是集群应用程序）的计算机组以及由它管理的容器。Kubernetes集群必须具有主服务器，该系统可以命令和控制集群中的所有其他Kubernetes计算机。一个高可用性集群Kubernetes复制到多台机器主人的设施。但是，一次只有一个主服务器运行作业调度程序和控制器管理器。</p>
<h2 id="Kubernetes-node-and-pods"><a href="#Kubernetes-node-and-pods" class="headerlink" title="Kubernetes node and pods"></a>Kubernetes node and pods</h2><p>每个群集都包含 Kubernetes 节点。节点可能是物理机器或VM。同样，这个想法是抽象的：无论运行什么应用程序，Kubernetes都会处理该基板上的部署。Kubernetes甚至可以确保某些容器仅在VM上运行或仅在裸机上运行。</p>
<p>节点运行 pod ，这是可以创建或管理的最基本的Kubernetes对象。每个pod代表Kubernetes中的应用程序或运行进程的单个实例，由一个或多个容器组成。Kubernetes作为一个组启动，停止和复制pod中的所有容器。Pod将用户的注意力集中在应用程序上，而不是容器本身上。有关如何配置Kubernetes的详细信息，从pod的状态开始，保存在Etcd（一个分布式键值存储）中。</p>
<p>根据需要在节点上创建和销毁Pod，以符合用户在pod定义中指定的所需状态。Kubernetes提供了一个称为控制器的抽象概念，用于处理pod的组织管理，Spun up，rolled out 和 spun down。控制器有几种不同的风格，具体取决于所管理的应用程序的类型。例如，最近引入的“StatefulSet”控制器用于处理需要持久状态的应用程序。另一种控制器，即部署，用于向上或向下扩展应用程序，将应用程序更新为新版本，或者在出现问题时将应用程序回滚到已知良好版本。</p>
<h2 id="Kubernetes-Service"><a href="#Kubernetes-Service" class="headerlink" title="Kubernetes Service"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">Kubernetes Service</a></h2><p>因为 pods 根据需要会有出生和死亡，我们需要一个不同的抽象来处理应用程序生命周期。应用程序应该是一个持久化实体，即使运行构成应用程序的容器的pod本身不是持久的。为此，Kubernetes提供了一种称为服务的抽象。</p>
<p>Kubernetes中的服务描述了如何通过网络访问给定的pod组（或其他Kubernetes对象）。正如Kubernetes文档所说，构成应用程序后端的pod可能会发生变化，但前端不需要知道或跟踪它。服务使这样成为可能。</p>
<p>Kubernetes的调度程序将工作负载分配给节点，以便在资源之间实现平衡，从而使部署满足应用程序定义的要求。controller manager 确保系统应用程序、工作负载等的状态匹配Etcd配置设置中定义的所需状态。</p>
<p>重要的是要记住，容器使用的任何底层机制（如Docker本身）都不会被 Kubernetes 取代。相反，为了保持应用程序大规模运行，Kubernetes为使用这些机制提供了更多的抽象化。</p>
<h2 id="Kubernetes-Ingress"><a href="#Kubernetes-Ingress" class="headerlink" title="Kubernetes Ingress"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Kubernetes Ingress</a></h2><p>Kubernetes服务被认为是在集群中运行。但是您希望能够从外部世界访问这些服务。Kubernetes有几个组件可以通过不同程度的简化并具有健壮性的来实现这一点，包括NodePort和LoadBalancer，但具有最大灵活性的组件是Ingress。Ingress是一种API，通常通过HTTP管理对集群服务的外部访问。</p>
<p>Ingress确实需要一些配置来正确设置 - 马修帕尔默写了一本关于Kubernetes开发的书，在他的网站上会引导你完成整个过程。<a target="_blank" rel="noopener" href="https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ingress-guide-nginx-example.html">Kubernetes Ingress with Nginx Example</a></p>
<h2 id="Kubernetes-Dashboard"><a href="#Kubernetes-Dashboard" class="headerlink" title="Kubernetes Dashboard"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Kubernetes Dashboard</a></h2><p>一个帮助您掌握所有其他组件的Kubernetes组件是Dashboard，这是一个基于Web的UI，您可以使用它来部署和排除应用程序故障并管理群集资源。默认情况下不安装仪表板，但<a target="_blank" rel="noopener" href="https://dzone.com/articles/how-to-install-the-kubernetes-dashboard">添加它</a>并不是太麻烦。</p>
<h2 id="Kubernets-Advantages"><a href="#Kubernets-Advantages" class="headerlink" title="Kubernets Advantages"></a>Kubernets Advantages</h2><p>因为Kubernetes引入了新的抽象和概念，并且因为Kubernetes的学习曲线很高，所以询问使用Kubernetes的长期收益是正常的。以下是在Kubernetes中运行应用程序的一些具体方法的简要说明。</p>
<h2 id="Manages-app-health-replication-load-balancing-and-hardware-resource-allocation"><a href="#Manages-app-health-replication-load-balancing-and-hardware-resource-allocation" class="headerlink" title="Manages app health, replication, load balancing, and hardware resource allocation"></a>Manages app health, replication, load balancing, and hardware resource allocation</h2><p>Kubernetes最基本的职责之一就是保持应用程序的正常运行和响应用户的需求。那些变得“不健康”，或者不符合你描述的健康定义的应用程序，可以自动修复。</p>
<p>Kubernetes提供的另一个好处是最大限度地利用硬件资源，包括内存，存储I/O和网络带宽。应用程序可以对其资源使用设置软限制和硬限制。许多使用最少资源的应用程序可以在同一硬件上一起打包;需要延伸的应用程序可以放置在有增长空间的系统上。同样，在集群中推出更新，或者如果更新中断，则可以自动回滚。</p>
<h2 id="Eases-the-deployment-of-preconfigured-applications-with-Helm-charts"><a href="#Eases-the-deployment-of-preconfigured-applications-with-Helm-charts" class="headerlink" title="Eases the deployment of preconfigured applications with Helm charts"></a>Eases the deployment of preconfigured applications with <a target="_blank" rel="noopener" href="https://helm.sh/">Helm</a> charts</h2><p>不同版本Linux的软件包管理器和Python的Pip等软件包管理器为用户省去了手动安装和配置应用程序的麻烦。当应用程序具有多个外部依赖项时，这尤其方便。</p>
<p>Helm 本质上是Kubernetes的包管理器。许多流行的软件应用程序必须作为一组相互依赖的容器在Kubernetes中运行。 Helm提供了一个定义机制，a “chart,” 描述了如何在Kubernetes中将应用程序或服务作为一组容器运行。</p>
<p>您可以从头开始创建自己的 Helm charts，如果您要构建要在内部部署的自定义应用程序，则可能需要这样做。但是，如果您使用的是具有通用部署模式的流行应用程序，则很有可能有人已经为其创建了 Helm chart 并将其发布到官方 Helm charts 存储库中。另一个寻找官方 Helm charts 的地方是 <a target="_blank" rel="noopener" href="https://kubeapps.com/">Kubeapps.com directory</a></p>
<h2 id="Simplifies-management-of-storage-secrets-and-other-application-related-resources"><a href="#Simplifies-management-of-storage-secrets-and-other-application-related-resources" class="headerlink" title="Simplifies management of storage, secrets, and other application-related resources"></a>Simplifies management of storage, secrets, and other application-related resources</h2><p>容器意味着不可改变;你放入的任何东西都不应该改变。但是应用程序需要状态，这意味着它们需要一种可靠的方式来处理外部存储卷。容器在应用程序的生命周期中生存，死亡和重生的方式变得更加复杂。</p>
<p>Kubernetes提供抽象化，允许容器和应用程序以与其他资源相同的分离方式处理存储。从 Amazon EBS volumes 到 plain old NFS shares, 可以通过 Kubernetes storage drivers(volumes.Normally) 访问 。通常， volumes 被绑定到特定的 pod ，但称为 “Persisten Volume” 的 volume 子类型可用于需要独立于任何 pod 进行生存的数据。</p>
<p>容器通常需要处理 “secrets”-诸如是API密钥或服务密码一样的凭证，您不希望凭证硬编码到容器中或公开存储在磁盘卷中。虽然可以使用第三方解决方案，例如 Docker secrets 和 HashiCorp Vault ，但Kubernetes有自己的秘密处理机制，尽管它确实需要谨慎配置。例如，**必须将 Etcd 配置为在节点之间而不是纯文本中发送秘密时使用 SSL/TLS 。</p>
<h2 id="Applications-can-run-in-hybrid-and-muti-cloud-environments"><a href="#Applications-can-run-in-hybrid-and-muti-cloud-environments" class="headerlink" title="Applications can run in hybrid and muti-cloud environments"></a>Applications can run in hybrid and muti-cloud environments</h2><p>云计算的长期梦想之一是能够在任何云中运行任何应用程序，或者在公共或私有云的任何组合中运行。这不仅可以避免供应商锁定，还可以利用特定于各个云的功能。</p>
<p>Kubernetes提供了一组基本类型，统称为 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/cluster-administration/federation/">federation</a>，用于使多个集群在多个区域和云中保持同步。例如，给定的应用程序部署可以在多个集群之间保持一致，并且不同的集群可以共享服务发现，以便可以从任何集群访问后端资源。无论您是否跨越多个云环境， federation 还可用于创建高可用性或容错Kubernetes部署。</p>
<p>Federation 对 Kubernetes 来说还是比较新的。并非所有 federation 实例都支持所有API资源，并且可以升级还没有自动测试基础结构。但是这些缺点将在未来版本的Kubernetes中得到解决。</p>
<h2 id="Usage-scenario"><a href="#Usage-scenario" class="headerlink" title="Usage scenario"></a>Usage scenario</h2><p>Kubernetes有多种形式 - 从开源位到商业支持的分发到公共云服务 - 最好的方法来确定从哪里获得它是用例。</p>
<ul>
<li>如果您想自己完成这些工作：可以从 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes">GitHub repository for Kubernetes</a> 下载源代码和大多数常见平台的预构建二进制文件。</li>
<li>如果您正在使用 Docker Community 或 Docker Enterprise：Docker的最新版本附带Kubernetes作为打包。这显然是容器专家最容易与Kubernetes合作的方式，因为它是通过几乎肯定已经熟悉的产品来实现的。</li>
<li>如果您正在部署或在私有云中部署：私有云选择的任何基础架构都可能都内置了Kubernetes。标准问题，认证，支持的Kubernetes发行版可从许多供应商处获得，包括Canonical，IBM，Mesosphere，Mirantis，Oracle，Pivotal，Red Hat，Suse，VMware等等。</li>
<li>如果您在公共云中部署：三大公共云供应商都提供Kubernetes即服务。 Google Cloud Platform提供Google Kubernetes Engine。 Microsoft Azure提供Azure Kubernetes服务。亚马逊已将Kubernetes添加到其现有的弹性容器服务中。管理型Kubernetes服务也可从IBM，Nutanix，Oracle，Pivotal，Platform9，Rancher Labs，Red Hat，VMware和许多其他供应商处获得。</li>
</ul>
<h2 id="Kubernetes-Toturials"><a href="#Kubernetes-Toturials" class="headerlink" title="Kubernetes Toturials"></a>Kubernetes Toturials</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/">https://kubernetes.io/docs/tutorials/</a> – Kubernetes offical toturials</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/quick-code/top-tutorials-to-learn-kubernetes-e9507e76d9a4">https://medium.com/quick-code/top-tutorials-to-learn-kubernetes-e9507e76d9a4</a> – Top Tutorials To Learn Kubernetes</p>
<p><a target="_blank" rel="noopener" href="https://www.infoworld.com/article/3207686/how-to-get-started-with-kubernetes.html">https://www.infoworld.com/article/3207686/how-to-get-started-with-kubernetes.html</a> – How to get started with Kubernetes</p>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>Wikipedia - OS-level virtualisation : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OS-level_virtualisation">https://en.wikipedia.org/wiki/OS-level_virtualisation</a></li>
<li>kubernetes.io - what is kubernetes : <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></li>
<li>kubernetes.io - Tasks : <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/">https://kubernetes.io/docs/tasks/</a></li>
<li>kubernetes.io - Tutorials : <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/">https://kubernetes.io/docs/tutorials/</a></li>
<li>Kubeapps.com directory : <a target="_blank" rel="noopener" href="https://kubeapps.com/">https://kubeapps.com/</a></li>
<li>helm official webside : <a target="_blank" rel="noopener" href="https://helm.sh/">https://helm.sh/</a></li>
<li>infoworld - What is Kubernetes? Container orchestration explained : <a target="_blank" rel="noopener" href="https://www.infoworld.com/article/3268073/what-is-kubernetes-container-orchestration-explained.html">https://www.infoworld.com/article/3268073/what-is-kubernetes-container-orchestration-explained.html</a></li>
<li>Linux Containers: Parallels, LXC, OpenVZ, Docker and More : <a target="_blank" rel="noopener" href="https://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/">https://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/</a></li>
<li>Kubernetes Ingress with Nginx Example : <a target="_blank" rel="noopener" href="https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ingress-guide-nginx-example.html">https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ingress-guide-nginx-example.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/05/15/Kubernetes/" data-id="ckvgcipjj000rplqh55xfe3wq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cloud-platform/" rel="tag">cloud platform</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/container/" rel="tag">container</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/microservice/" rel="tag">microservice</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SpringSecurity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/14/SpringSecurity/" class="article-date">
  <time datetime="2019-05-14T09:14:39.000Z" itemprop="datePublished">2019-05-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/14/SpringSecurity/">Spring Security</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-Spring-Security"><a href="#What-is-Spring-Security" class="headerlink" title="What is Spring Security?"></a>What is Spring Security?</h1><p>Spring Security是一个 Java/Java EE 框架，为企业应用程序提供身份验证，授权和其他安全功能。该项目于2003年底开始作为’Acegi Security’（发音为Ah-see-gee，其字母为英文字母中的第1,3,5,7和9个字符，以防止名称冲突） Alex，于2004年3月在Apache License下公开发布。随后，Acegi被纳入Spring组合作为Spring Security，一个官方的Spring子项目。新名称下的第一个公开发布是2008年4月的Spring Security 2.0.0，SpringSource提供了商业支持和培训。</p>
<blockquote>
<p>Spring Security是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实标准。<br>Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。与所有Spring项目一样，Spring Security的真正强大之处在于它可以轻松扩展以满足自定义要求</p>
</blockquote>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>对身份验证和授权的全面和可扩展的支持</li>
<li>防止会话固定，点击劫持，跨站点请求伪造等攻击</li>
<li>Servlet API集成</li>
<li>可选与Spring Web MVC集成</li>
</ul>
<h3 id="Key-authentication-features"><a href="#Key-authentication-features" class="headerlink" title="Key authentication features"></a>Key authentication features</h3><ul>
<li>LDAP（使用基于绑定和密码比较策略）用于集中身份验证信息。</li>
<li>使用流行的中央身份验证服务的单点登录功能。</li>
<li>Java身份验证和授权服务（JAAS）LoginModule，一种在Java中使用的基于标准的身份验证方法。请注意，此功能仅是对JAAS Loginmodule的委派。</li>
<li>通过 IETF Request for Comments 1945 标准定义的基本访问认证。</li>
<li>通过 IETF Request for Comments 2617 和 RFC 2069 标准定义的摘要访问认证。</li>
<li>通过 Secure Sockets Layer(SSL,又叫Transport Layer Security,TLS) 标准的 X.509 客户端证书表示。</li>
<li>CA，Inc SiteMinder用于身份验证（一种流行的商业访问管理产品）。</li>
<li>类似于Su（Unix）支持通过HTTP或HTTPS连接切换主体身份。</li>
<li>Run-as replacement，使操作能够采用不同的安全标识。</li>
<li>匿名身份验证，这意味着即使是未经身份验证的主体也会分配安全身份。</li>
<li>容器适配器（自定义领域）支持Apache Tomcat，Resin，JBoss和Jetty（Web服务器）。</li>
<li>Windows NTLM启用浏览器集成（实验性）。</li>
<li>Web表单身份验证，类似于Servlet容器规范。</li>
<li>通过HTTP Cookie “Remember-me”支持。</li>
<li>并发会话支持，限制委托人允许的同时登录次数。</li>
<li>完全支持自定义和插入自定义身份验证实现。</li>
</ul>
<h3 id="Instance-based-security-features"><a href="#Instance-based-security-features" class="headerlink" title="Instance-based security features"></a>Instance-based security features</h3><ul>
<li>AspectJ方法调用授权。</li>
<li>使用Apache Ant路径或正则表达式选择Web请求URL的HTTP授权。</li>
</ul>
<h3 id="Other-features"><a href="#Other-features" class="headerlink" title="Other features"></a>Other features</h3><ul>
<li>软件本地化，因此用户界面消息可以使用任何语言。</li>
<li>通道安全性，在满足特定规则时自动在HTTP和HTTPS之间切换。</li>
<li>在框架的所有数据库触摸区域中进行缓存。</li>
<li>发布消息以促进事件驱动的编程。</li>
<li>支持通过JUnit执行集成测试。</li>
<li>Spring Security本身具有全面的JUnit隔离测试。</li>
<li>几个示例应用程序，详细的JavaDocs和参考指南。</li>
<li>Web框架独立性。</li>
</ul>
<h1 id="Registration"><a href="#Registration" class="headerlink" title="Registration"></a>Registration</h1><h2 id="Basic-Registration-Process"><a href="#Basic-Registration-Process" class="headerlink" title="Basic Registration Process"></a>Basic Registration Process</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/05/14/SpringSecurity/" data-id="ckvgcipjp0019plqh6ndpb5gr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-security/" rel="tag">spring security</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MessageQueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/13/MessageQueue/" class="article-date">
  <time datetime="2019-05-13T07:39:38.000Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Message-Queue/">Message Queue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/13/MessageQueue/">Message Queue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-Message-Queue"><a href="#What-is-Message-Queue" class="headerlink" title="What is Message Queue?"></a>What is Message Queue?</h1><p>在计算机科学中，<strong>消息队列(Message queue)</strong> 是一种 **进程间通信或同一进程的不同线程间的通信方式(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inter-process_communication">inter-process communication,IPC</a>)**，软件的贮列用来处理一系列的输入，输入通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。</p>
<p>消息队列范例是发布者(publibsher)/订阅者(subscriber)模式，通常是较大面向消息的中间件系统的一部分。大多数消息传递系统在其API中支持发布者/订阅者和消息队列模型，例如Java消息服务（JMS）。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>消息队列提供 <strong>异步</strong> 通信协议，这意味着消息的发送方和接收方不需要同时与消息队列交互。放置在队列中的消息将被存储，直到收件人检索它们。消息队列对可以在单个消息中传输的数据大小以及可能在队列中保持未完成的消息数具有隐式或显式限制。</p>
<p>消息队列的许多实现在内部起作用：在操作系统内或在应用程序内。这些队列仅用于该系统的目的。</p>
<p>其他实现允许在不同计算机系统之间传递消息，可能连接多个应用程序和多个操作系统。这些消息排队系统通常提供增强的弹性功能，以确保在系统发生故障时消息不会“丢失”。这种消息排队软件（也称为面向消息的中间件）的商业实现的示例包括IBM MQ（以前称为MQ Series）和Oracle Advanced Queuing（AQ）。有一个名为Java Message Service的Java标准，它有几个专有的和自由软件实现。</p>
<p>有的实现作为专有软件存在，作为服务，开源软件或基于硬件的解决方案提供。</p>
<p>专有软件具有最长的历史记录，包括消息队列开始时的产品（如IBM MQ）以及与特定操作系统（如Microsoft Message Queue）相关的产品。</p>
<p>还有基于云的消息队列服务选项，例如Amazon Simple Queue Service（SQS），StormMQ，IronMQ，以及IBM MQ具有基于云的托管排队服务。</p>
<p>消息中间件系统有很多开源选择，包括Apache ActiveMQ, Apache Kafka, Apache Qpid, Apache RocketMQ, Beanstalkd, Enduro/X, HTTPSQS, JBoss Messaging, JORAM, RabbitMQ, Sun Open Message Queue和 Tarantool。</p>
<p>除了开源软件之外，Solace，Apigee和Tervela 等供应商还提供基于硬件的消息传递中间件，可通过芯片或硅/软件数据路径进行排队。IBM还在设备上提供其MQ软件。</p>
<p>大多数实时操作系统（real-time operating systems,RTOSes），例如VxWorks和QNX，都鼓励使用消息队列作为主要的进程间或线程间通信机制。由此产生的消息传递和CPU调度之间的紧密集成被认为是RTOSes中实时应用程序可用性的主要原因。商业RTOSes的早期例子鼓励消息队列基础进行线程间通信，也包括 VRTX 和 pSOS+，两者都可以追溯到20世纪80年代早期。在Erlang编程语言的使用过程中提供的并发性; 这些进程使用消息队列异步通信。</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>一般来说，系统间如果需要通信，除了正常情况下的消息传递外，还要考虑下游系统处理异常，上游系统如何处理？系统宕机的情况下会不会导致数据丢失？当有业务数据异常时，如何去定位是上游系统发送出了问题还是下游系统的问题？如果需要同时将信息发送给多个下游系统，其中一个处理有问题会不会导致其它系统受影响？而 MQ 可以让这些问题变得简单。</p>
<p>在典型的消息队列实现中，系统管理员安装和配置消息队列软件（队列管理器或代理服务器），并定义命名消息队列。或者他们注册消息排队服务。</p>
<p>然后，应用程序注册一个软件实例，该实例”监听”放置在队列中的消息。</p>
<p>第二个和后续应用程序可以连接到队列并将消息传送到队列。</p>
<p>队列管理器软件存储消息，直到接收应用程序连接，然后调用注册的软件实例。接收应用程序然后以适当的方式处理该消息。</p>
<p>关于消息传递的确切语义，通常有很多选项，包括：</p>
<ul>
<li>持久性 - 如果对可靠性的需求表明资源密集型解决方案，则消息可以保留在内存中，写入磁盘，甚至可以提交给DBMS(Database)。</li>
<li>安全策略 - 哪些应用程序应该可以访问这些消息？</li>
<li>消息清除策略 - 队列或消息可能有“ 生存时间 ”</li>
<li>消息过滤 - 某些系统支持过滤数据，以便订阅者只能看到符合某些预先指定的感兴趣标准的消息</li>
<li>交付策略 - 我们是否需要保证邮件至少发送一次或不超过一次？</li>
<li>路由策略 - 在具有许多队列服务器的系统中，哪些服务器应该接收消息或队列的消息？</li>
<li>批处理策略 - 是否应立即发送消息？或者系统应该稍微等一下并尝试一次发送许多消息？</li>
<li>排队标准 - 何时应将消息“排队”？只有一个队列吗？或者当它被转发到至少一个远程队列？或者对所有队列？</li>
<li>收据通知 - 发布者可能需要知道某些或所有订阅者何时收到消息。</li>
</ul>
<p>这些都是可能对事务语义，系统可靠性和系统效率产生重大影响的因素。</p>
<p>在使用中，一般有推消息和拉消息两种模式。推模式即服务端收到消息后，主动将消息推送给消费者，消费者进行处理，这种模式具有更高的实时性，但是由于服务端不能准确评估消费端的消费性能，所以有可能造成消息推送过多使客户端来不及处理收到的消息； 拉模式则是服务端收到消息后将消息保存在服务端，被动的等待客户端来拉取消息，这种模式下客户端可以根据自己的处理能力来决定拉消息的频率，但是缺点就是消息处理可能有延迟，不过可以通过长轮询的方式来提高实时性。</p>
<p>消息传递过程中，会有各种异常导致消息不能正常发送，这时候，会有三种选择，一下是三种选择及其实现：</p>
<ul>
<li><p>下游允许部分消息丢失，不进行处理，这种方式一般适用于监控信息和 log 的传递，少一两条影响不大，称为至多一次（Qos=0）</p>
<p>  要实现至多一次并不难，生产者只需要异步发送，在发送失败或者消费失败的时候不做任何处理即可。MQ 在消费者拉走消息后，就直接将消息标记为已经消费或者删除消息。在监控系统和日志系统中，丢失部分信息是可以接受的，但显然，电商系统，金融系统等大部分业务，是不允许出现消息丢失这种情况的，需要保证消息一定会送达到消费者。</p>
</li>
<li><p>一种是消息必须全部送达，不允许任何消息丢失，但是可以接受部分消息重复，这种我们称为至少一次（Qos=1），此种方式一般适用于订单，支付等场景（当然，这要求下游系统实现去重或幂等）；</p>
<p>  至少一次的实现一般如下：生产者发消息到 MQ，MQ 收到消息后返回确认信息（ACK）给生产者，生产者收到确认信息后生产过程完成，如果在一定时间内，生产者没有收到确认信息，生产者重新发送消息。 重新发送的过程可以是立即发送，也可以将处理异常的消息持久化，比如保存到数据库中，然后定时重试知道成功。同样，消费者从 MQ 获取到消息后，当业务逻辑处理完成，向 MQ 返回 ACK 信息。 但是存在下面一种情况，当 MQ 收到消息并发送 ACK，或者消费者消费完成发送 ACK 信息之后，由于网络，系统故障等问题，ACK 信息没有成功送达，就会导致消息重复发送。 对于大部分消息队列的实现来说（如 kafka，RocketMQ）对于消息重复的处理方式，就是不处理，交由消费者根据业务逻辑自己实现去重或幂等。消费者根据业务逻辑自己实现去重或幂等。消费者根据业务逻辑自己实现去重或幂等。 重要的事情说三遍。有些人或许会觉得这是常识和基本素养，但也有部分同学过于相信 MQ 系统和网络环境的稳定性，不做去重导致业务出现问题，比如优惠卷系统没有做去重处理，本来只能领取一张的优惠卷，结果给用户发了多张。</p>
</li>
<li><p>还有一种最严格的要求，就是消息只能送达一次，不能多也不能少，这种我们称为正好一次（Qos=2）。</p>
<p>  如果要实现正好一次的消息级别，每次消息传递过程正需要四次通信，过程如下： 发送端发消息给接收端，接收端收到消息后持久化保存消息 ID 并返回 REC 信息给发送端，通知生产端我已经收到这个消息了。 这时消息是一种中间态，接受端不会进行业务逻辑的处理。这个过程中，如果 REC 消息丢失，服务端重传了消息， 接受端接受到消息后会和本地保存到消息 ID 做对比，如果重复，就丢弃消息不做处理，避免消息被处理多次，而且消息 ID 会持久化到硬盘，防止因为断电内存中数据丢失倒是消息被重复处理。 发送端收到接收端返回的 rec 消息后，发送一个 rel 请求给消费端，告诉消费端我确认收到了你的确认消息，接收端收到 rel 请求后才会进行具体的业务逻辑处理，并返回 comp 信息给发送端，同时在本地删除保存的消息 ID。如果发送端没有收到 comp 信息，会重发 rel 请求而不会重发消息。</p>
</li>
</ul>
<p>生产者将消息发到消息队列的 Broker 之后，如果 Broker 只将消息保存在内存中，那当服务器断电或各种原因导致宕机时， 还没有被消费的消息将会丢失。为了解决这个问题，可以选择将数据持久化到硬盘，这样当机器故障恢复后数据还在，消费者可以继续消费之前没有消费完的数据。但是，如果仅仅持久化到硬盘，当服务器发生磁盘故障，Raid 卡故障时，数据依然存在丢失的风险。为了解决这个问题，绝大多数消息队列的实现都引入了复制 / 多副本的概念，将每份数据都保存在多台服务器上，而且一般这些服务器还要尽可能多实现跨机架甚至跨数据中心。 复制可以是同步的也可以是异步的，可以是一主一从，也可以是一主多从，也可以基于 Raft，Paxos 等算法实现多副本。</p>
<p>不管是持久化还是复制，在保证数据可靠性的同时，都必然会带来一部分性能的损耗，所以不同的消息队列实现根据自己的定位，会选择不同的复制的实现方式以及持久化时的文件结构。</p>
<h2 id="Standards-and-protocols"><a href="#Standards-and-protocols" class="headerlink" title="Standards and protocols"></a>Standards and protocols</h2><p>从历史上看，消息队列使用专有的封闭协议，限制了不同操作系统或编程语言在异构环境中进行交互的能力。</p>
<p>Sun Microsystems的JMS规范早期尝试使消息排队更加普遍，它提供了一个 Java-only 客户端的API抽象。这允许Java开发人员以类似于使用SQL数据库的开发人员的方式在消息队列提供者之间切换。实际上，考虑到消息排队技术和场景的多样性，这并不总是尽可能的实用各种场景。</p>
<p>下面是几种在开源消息队列实现中使用的标准：</p>
<ol>
<li><p>Java Messgae Service(JMS) - JMS 本质上是 JAVA API。</p>
<p> 在 JMS 中定义了 Producer，Consumer，Provider 三种角色，Producer 作为消息的发送方，Consumer 作为消息的接收方，Provider 作为服务的提供者，Producer 和 Consumer 统称为 Client。JMS 定义了点对点和发布订阅两种消息模型，发布订阅模型中，通过 topic 对消息进行路由，生产者可以将消息发到指定的 topic，消费者订阅这个 topic 即可收到生产者发送的消息。一个生产者可以向一个或多个 topic 中发送消息，一个消费者也可以消费一个或多个 topic 中的消息，一个 topic 也可以有多个生产者或消费者，生产者和消费者只需要关联 topic，而不用关心这消息由谁发送或者消费。 Provider 为每一个 topic 维护一个或多个 queue 来保存消息，消息在 queue 中是有序的，遵循先进先出的原则，不同 queue 间的消息是无序的。点对点模式中没有 topic 的概念，生产者直接将消息发送到指定 queue，消费者也指定 queue 进行消费，消息只能被一个消费者消费，不可以被多个消费者消费。Kafka 和 RocketMQ 都实现了或部分实现了 JMS 协议。</p>
</li>
<li><p>Advanced Message Queuing Protocol(AMQP) - 功能丰富的消息队列协议，自2014年4月起被批准为 ISO/IEC 19464</p>
<p> AMQP 是一个应用层的网络传输协议，对报文格式进行定义，与开发语言无关。在 AMQP 中同样有生产者，消费者两种角色，消息也是保存在 queue 中的。 但不同于 JMS 用 topic 对消息进行路由，AMQP 的路由方式由 exchange 和 binding 决定。 client 可以创建 queue，并在创建 queue 的同时通知 exchange 这个 queue 接受符合什么条件的消息，这个条件即为 Bingding key。生产者发送消息到 exchange 的时候会指定一个 router key，exchange 收到消息后会与自己所维护的 Bingding key 做比较，发送到符合条件的 queue 中。消费者在消费时指定 queue 进行消费。RabbitMQ 实现了 AMQP 协议。</p>
</li>
<li><p>Steaming Text Oriented Messaging Protocol(STOMP) - 简单的，面向文本的消息协议</p>
<p> STOMP 以前称为TTMP，是一种简单的基于文本的协议，设计用于处理面向消息的中间件（MOM）。它提供了可互操作的有线格式，允许STOMP客户端与支持该协议的任何消息代理进行通信。STOMP 是 WebSocket 通信标准。在通常的发布订阅语义之上，它通过 begin/publish/commit 序列以及 acknowledgement 机制来提供消息可靠投递。强调（协议）简单性。它对消息传递语义的定义很少，但易于实现并且非常容易部分实现（它是唯一可以通过telnet手动使用的协议）。</p>
</li>
<li><p>Message Queuing Telemetry Transoport(MQTT，以前称为 MQ Telemetry Transport) - 轻量级消息队列协议，尤其适用于嵌入式设备</p>
<p> MQTT 协议是一种基于发布订阅的轻量级协议，支持 TCP 和 UDP 两种连接方式，主要应用于即时通讯，小型设备，移动应用等领域。 MQTT 中有发布者（Publish），订阅者（Subscribe）和代理服务器（Broker）三种角色。Broker 是服务的提供者，发布者和前两种协议中的生产者相同，将消息（Message）发送到 Broker，Subscribe 从 Broker 中获取消息并做业务处理。MQTT 的 Message 中固定消息头（Fixed header）仅有 2 字节，开销极小，除此之外分为可变头（Variable header）和消息体（payload）两部分。固定头中包含消息类型，消息级别，变长头的大小以及消息体的总长度等信息。 变长头则根据消息类别，含有不同的标识信息。 MQTT 允许客户端动态的创建主题，发布者与服务端建立会话（session）后，可以通过 Publish 方法发送数据到服务端的对应主题，订阅者通过 Subscribe 订阅主题后，服务端就会将主题中的消息推送给对应的订阅者。</p>
</li>
</ol>
<p>这些协议处于标准化和采用的不同阶段。前三个在 HTTP 同一级别上运行，MQTT在 TCP/IP 同一级别上运行。</p>
<p>一些专有实现还使用HTTP来通过某些实现来提供消息排队，例如亚马逊的SQS。这是因为始终可以使用 请求 - 响应 的语义对同步协议进行分层异步行为（这是消息排队所需的行为）。然而，在这种情况下，这样的实现受到底层协议的约束，并且可能无法提供上面的消息传递所需的完全保真度或一组选项。</p>
<h2 id="Synchronous-and-asynchronous"><a href="#Synchronous-and-asynchronous" class="headerlink" title="Synchronous and asynchronous"></a>Synchronous and asynchronous</h2><p>许多使用较广泛的通信协议同步运行。 HTTP协议 - 在万维网和Web服务中使用 - 一个明显的例子，用户发送网页请求然后等待回复。</p>
<p>但是，存在同步行为不合适的情况。例如，AJAX（异步 JavaScript和XML）可用于异步发送文本，JSON或XML消息，以更新具有更多相关信息的网页的一部分。 Google将这种方法用于他们的 Google Suggest，这是一种搜索功能，可将用户的部分类型查询发送到Google的服务器，并返回用户可能对输入过程感兴趣的完整查询列表。此列表根据用户类型进行异步更新。</p>
<p>事件通知系统(notification systems) 和 发布/订阅系统(publish/subscribe system) 中存在其他异步示例。</p>
<ul>
<li>应用程序可能需要通知另一个事件已发生，但不需要等待响应。</li>
<li>在发布/订阅系统中，应用程序“发布”任意数量的客户端要读取的信息。</li>
</ul>
<p>在上述两个例子中，如果例如其中一个接收者崩溃，则信息发送者的必须等待是没有意义的。</p>
<p>应用程序不必是完全同步或异步的。交互式应用程序可能需要立即响应请求的某些部分（例如告诉客户已接受销售请求，并处理提取库存的承诺），但可能将其他部分排队（例如完成计费计算，将数据转发到中央会计系统，并调用各种其他服务）以后一段时间再做。</p>
<p>在所有这些情况下，具有执行消息排队的子系统（或者说，Broadcast messaging systen,广播消息系统）可以帮助改善整个系统的行为。</p>
<p><strong>以上部分内容来自wikipedia(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Message_queue">https://en.wikipedia.org/wiki/Message_queue</a>)</strong></p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="What-is-RabbitMQ"><a href="#What-is-RabbitMQ" class="headerlink" title="What is RabbitMQ?"></a>What is RabbitMQ?</h2><p>RabbitMQ是一个开源的消息代理软件（有时称为面向消息的中间件），它最初实现了Advanced Message Queuing Protocol（AMQP），并且已经通过插件架构进行了扩展，以支持Steaming Text Oriented Messaging Protocol（STOMP）。 ，Message Queuing Telemetry Transport（MQTT）和其他协议。</p>
<p>RabbitMQ服务器程序是用Erlang编程语言编写的，构建在Open Telecom Platform框架上，用于集群和故障转移。与代理接口的客户端库可用于所有主要编程语言。</p>
<blockquote>
<p>高级消息队列协议（AMQP）是用于异步消息传递的应用层协议规范。构建为线级协议而不是API（例如JMS）AMQP客户端应该能够发送和接收消息，而不管它们各自的供应商。截至目前，已有多种服务器3和客户端4在多个平台上可用。<br>虽然AMQP的原始用例是为金融行业提供可互操作的消息传递协议，但当前的标准旨在为通用消息队列体系结构提供通用构造工具包。从这个意义上讲，面向消息的中间件（MOM）系统（如发布/订阅队列）的概念不是直接作为首要实现的。相反，通过将相对简单的AMQ实体连接在一起，给予用户建立这种概念的手段。这些实体也是规范的一部分，并在线级协议之上形成一个层：AMQP模型。此模型统一了消息传递模式，例如前面提到的发布/订阅，队列，事务和流，同时添加了额外的功能，例如易于扩展的基于内容的路由。<br>在此上下文中发布/订阅意味着生产者和消费者的脱钩：生产者不需要根据消费者将接收消息的标准来了解。队列是以先进先出的方式保存消息的结构。路由封装了决定哪条消息最终会出现在异步消息系统中的消息队列中。</p>
</blockquote>
<p>更多详情可看<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/"><strong>RabbitMQ 官网</strong></a></p>
<h1 id="RabbitMQ-和-Apache-Kafka"><a href="#RabbitMQ-和-Apache-Kafka" class="headerlink" title="RabbitMQ 和 Apache Kafka"></a>RabbitMQ 和 Apache Kafka</h1><h2 id="Origins"><a href="#Origins" class="headerlink" title="Origins"></a>Origins</h2><p>RabbitMQ是一个“传统”消息代理，它实现了各种消息传递协议。它是首批实现合理级别功能，客户端库，开发工具和质量文档的开源消息代理之一。RabbitMQ最初是为实现AMQP而开发的，AMQP是一种开放式线路协议，具有强大的路由功能。虽然Java具有像JMS这样的消息传递标准，但它对于需要分布式消息传递的非Java应用程序没有帮助，因为它严重限制了任何集成场景，微服务或单片机。随着AMQP的出现，跨语言的灵活性成为开源消息代理的真实存在。</p>
<p>Apache Kafka是在Scala中开发的，最初是在LinkedIn上作为连接不同内部系统的一种方式。当时，LinkedIn正在转向更加分散的架构，需要重新构想数据集成和实时流处理等功能，从而摆脱以前单一的方法来解决这些问题。今天，Kafka在Apache Software Foundation产品生态系统中得到了很好的采用，在事件驱动架构中特别有用。 </p>
<h2 id="Architecture-and-Design"><a href="#Architecture-and-Design" class="headerlink" title="Architecture and Design"></a>Architecture and Design</h2><p>RabbitMQ被设计为通用消息代理，采用 point to point (点对点)，request/reply(请求/回复)和  pub-sub(发布者-订阅者) 通信风格模式的多种变体。它使用 smart broker / dumb consumer(智能代理/消费者) 模型，专注于向消费者提供持续一致的消息传递，消费者的消费速度与代理跟踪消费者状态的速度大致相似。它是成熟的，在正确配置时表现良好，得到很好的支持（客户端库Java，.NET，node.js，Ruby，PHP和更多语言），并且有许多可用的插件可以将它扩展到更多的用例和集成场景。</p>
<p>RabbitMQ中的通信可以根据需要选择 synchronous(同步) 或 asynchronous(异步)。Publisher(发布者) 向 Exchanges(交换) 发送消息， Consumers(消费者) 从 Queue(队列) 中检索消息。通过 Exchanges 将 producers(生产者) 与  queue 分离可确保 producers 不会受到硬编码路由决策的影响。RabbitMQ 还提供了许多分布式部署方案（并且确实要求所有节点都能够解析主机名）。可以将多节点设置为集群，并且不依赖于外部服务（但某些群集形成插件可以使用AWS API，DNS，Consul等）。  </p>
<p>Apache Kafka 专为高流量的 publish-subscriber(发布-订阅) 消息和流而设计，旨在持久，快速和可扩展。从本质上讲，Kafka提供了一个持久的消息存储，类似于在服务器集群中运行的日志，它的存储称为 topic (存储流的类型)。</p>
<p>每条消息都包含一个键，一个值和一个时间戳。几乎与RabbitMQ相反，Kafka雇用了一个 dumb broker，并使用 smart consumers 来读取它的缓冲区。Kafka不会尝试跟踪每个消费者读取的消息，只保留未读消息; 相反，Kafka会在一段时间内保留所有消息， Consumers 有责任在每个日志（consumer state）中跟踪他们的位置。因此，通过合适的开发人员创建消费者代码，Kafka可以支持大量消费者并以极少的开销保留大量数据。如上图所示，Kafka确实需要运行外部服务 - 在这种情况下是Apache Zookeeper，这通常被认为是非常容易理解，设置和操作的。    </p>
<h2 id="Requirements-and-Use-Cases"><a href="#Requirements-and-Use-Cases" class="headerlink" title="Requirements and Use Cases"></a>Requirements and Use Cases</h2><p>Apache Kafka包括 broker 本身，它实际上是最着名和最受欢迎的部分，并且已经设计并突出地推向流处理场景。除此之外，Apache Kafka最近还添加了Kafka Streams，它将自己定位为Apache Spark，Apache Flink，Apache Beam/Google Cloud Data Flow和Spring Cloud Data Flow等流媒体平台的替代品。该文档很好地讨论了网站活动跟踪，度量标准，日志聚合，流处理，事件采购和提交日志等常见用例。它描述的其中一个用例是消息传递，它可能会产生一些混乱。因此，让我们稍微解压一下，并清楚了解哪些消息传递方案最适合Kafka，例如：</p>
<ul>
<li>从A到B的流，没有复杂的路由，最大吞吐量（100k / sec +），按分区顺序至少传送一次。</li>
<li>当您的应用程序需要访问流历史记录时，至少按分区顺序提供一次。Kafka是一个持久的消息存储，客户可以根据需要“重播”事件流，而不是更传统的消息代理，一旦消息传递，它就会从队列中删除。</li>
<li>流处理</li>
<li>活动采购</li>
</ul>
<p>RabbitMQ是一种通用消息传递解决方案，通常用于允许Web服务器快速响应请求，而不是在用户等待结果时强制执行资源繁重的过程。它还可以将消息分发给多个接收者以供消费，或者在高负载（20k+/sec）下平衡负载之间的负载。当您的需求超出吞吐量时，RabbitMQ可提供许多功能：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/confirms.html">features for reliable delivery</a>，routing，federation，HA，Security，管理工具和其他功能。让我们来看看RabbitMQ的最佳场景，例如：</p>
<ul>
<li>您的应用程序需要使用现有协议的任意组合，如AMQP 0-9-1，STOMP，MQTT，AMQP 1.0。</li>
<li>您需要基于每个消息（死信队列等）进行更精细的一致性控制/保证。 </li>
<li>您的应用程序需要 point to point，request/reply以及 publish/subscriber 消息传递的多样性</li>
<li>复杂的路由到 consumers，使用复杂的路由逻辑集成多个服务/应用程序</li>
</ul>
<p>RabbitMQ还可以有效地解决上面几个Kafka强大的用例，但是在其他软件的帮助下。当应用程序需要访问流历史时，RabbitMQ通常与Apache Cassandra一起使用，对于需要“无限”队列的应用程序，RabbitMQ通常与LevelDB插件一起使用，但这两种功能都不附带RabbitMQ本身。</p>
<p>有关Kafka和RabbitMQ的微服务特定用例的深入研究，请阅读<a target="_blank" rel="noopener" href="https://content.pivotal.io/blog/messaging-patterns-for-event-driven-microservices">Fred Melo的这篇简短的帖子</a>。</p>
<h2 id="Security-and-Operations"><a href="#Security-and-Operations" class="headerlink" title="Security and Operations"></a>Security and Operations</h2><p>安全和运维两者都是RabbitMQ的优势。RabbitMQ管理插件提供HTTP API，基于浏览器的管理和监控UI，以及运营商的CLI工具。长期监控数据存储需要外部工具，如CollectD，Datadog或New Relic。RabbitMQ还提供用于监控，审计和应用程序故障排除的API和工具。除了支持TLS之外，RabbitMQ还附带了由内置数据存储，LDAP或基于HTTPS的外部提供程序支持的RBAC，并支持使用x509证书而不是用户名/密码对进行身份验证。使用插件可以相当简单地开发其他身份验证方法。</p>
<p>这些域对Apache Kafka构成了挑战。在安全方面，最近的Kafka 0.9版本添加了TLS，基于JAAS角色的访问控制和kerberos / plain / scram auth，使用CLI管理安全策略。这对早期版本进行了实质性改进，您只能锁定网络级别的访问权限。</p>
<p>Kafka使用由shell脚本，属性文件和特定格式的JSON文件组成的管理CLI。Kafka Brokers，producers 和 consumers 通过 Yammer/JMX 发布指标但不保留任何历史记录，这实际上意味着使用第三方监控系统。使用这些工具，操作可以管理分区和主题，检查消费者偏移位置，并使用Apache Zookeeper为Kafka提供的HA和FT功能。虽然许多人对Zookeeper的要求持高度怀疑态度，但它确实为Kafka用户带来了集群效益。</p>
<p>例如，3节点Kafka集群即使在2次故障后系统也能正常运行。但是，如果要在Zookeeper中支持尽可能多的故障，则需要额外的5个Zookeeper节点，因为Zookeeper是基于仲裁的系统，并且只能容忍 N/2+1 故障。这些显然不应该与Kafka节点共存 - 所以要建立一个3节点的Kafka系统，你需要~8台服务器。在推断任何Kafka系统的可用性时，运营商必须考虑ZK集群的属性，无论是在资源消耗还是设计方面。</p>
<h2 id="Proformance"><a href="#Proformance" class="headerlink" title="Proformance"></a>Proformance</h2><p>Kafka在设计上闪耀着光芒：100k/sec 的性能通常是人们选择 Apache Kafka 的关键驱动因素。  </p>
<p>当然，每秒消息的速率很难说明和量化，因为它们依赖于很多，包括你的环境和硬件，你的工作负载的性质，使用哪些交付保证（例如持久性成本高，镜像甚至更多）等等。</p>
<p>每秒20K消息很容易通过单个Rabbit队列推送，实际上并不比这更难，对保证方式的要求不高。该队列由一个Erlang轻量级线程支持，该线程在本机操作系统线程池上进行协作调度 - 因此它成为一个自然的瓶颈或瓶颈，因为单个队列永远不会做更多的工作，而不是让CPU周期工作在。</p>
<p>每秒增加消息通常归结为通过巧妙的路由（例如，可以同时运行不同的队列）来执行诸如跨多个队列中断流量之类的事情来正确利用一个环境中可用的并行性。当RabbitMQ 每秒获得100万条消息时，这个用例基本上完全是为了明智地做到这一点 - 但是使用了大量资源，大约30个RabbitMQ节点实现了这个用例。大多数RabbitMQ用户都享有出色的性能，集群由3到7个RabbitMQ节点组成。</p>
<h1 id="Apache-Kafka-和-RocketMQ"><a href="#Apache-Kafka-和-RocketMQ" class="headerlink" title="Apache Kafka 和 RocketMQ"></a>Apache Kafka 和 RocketMQ</h1><h2 id="Kafka-和-RocketMQ-的文件结构对比"><a href="#Kafka-和-RocketMQ-的文件结构对比" class="headerlink" title="Kafka 和 RocketMQ 的文件结构对比"></a>Kafka 和 RocketMQ 的文件结构对比</h2><p>实消息队列的持久化，除了本地写文件外，还可以持久化到 K-V 存储或者关系型数据库中，但是性能会比较差，我们就不做讨论了，我们只聊聊持久化到本地文件系统中。而最常见的两种文件结构，一种是 Kafka 所使用的，一种是 RocketMQ 所使用的。</p>
<p>Kafka 会在 Broker 上为每一个 topic 创建一个独立的 partiton 文件，Broker 接受到消息后，会按主题在对应的 partition 文件中顺序的追加消息内容。而 RocketMQ 则会创建一个 commitlog 的文件来保存分片上所有主题的消息。</p>
<p>Broker 接收到任意主题的消息后，都会将消息的 topic 信息，消息大小，校验和等信息以及消息体的内容顺序追加到 Commitlog 文件中，Commitlog 文件一般为固定大小，当前文件达到限定大小时，会创建一个新的文件，文件以起始便宜位置命名。同时，Broker 会为每一个主题维护各自的 ConsumerQueue 文件，文件中记录了该主题消息的索引，包括在 Commitlog 中的偏移位置，消息大小及校验和，以便于在消费时快速的定位到消息位置。ConsumerQueue 的维护是异步进行的，不影响消息生产的主流程，即使 ConsumerQueue 没有及时更新的 情况下，服务异常终止，下次启动时也可以根据 Commitlog 文件中的内容对 ConsumerQueue 进行恢复。</p>
<p>这样的文件结构也就决定了，在同步刷盘的场景下，RocketMQ 是顺序写，而 Kafka 是随机写。通常情况下，我们认为顺序写的性能远高于随机写，尤其时对于传统的机械硬盘来讲更是如此。 且当 Broker 上的 topic 数量增多时，RocketMQ 在写消息的性能上几乎不会受到影响，而对 Kafka 的影响则会较大。</p>
<p>而在消费时，因为可以根据一定的缓存策略将热数据提前缓存到内存中，所以不管哪种方式对于磁盘的要求都不是太高。不过对于 RocketMQ 来说，内存加载时会加载一整个 Commitlog 文件，如果同一个 Broker 上的两个主题，一个主题的消息积压了很长时间开始才开始消费，而另一个主题在及时消费新发送的消息时，Broker 可能会频发的读取文件更新到缓存中，造成磁盘性能损耗，进而影响到生产时的发送性能。所以虽然 RocketMQ 支持海量消息积压，但如果是在共享的集群中，还是建议用户最好能做到及时消费，保证集群中所有主题都在消费相近时间段的消息，这样命中内存缓存的概率会比较高，消费时不会带来额外的磁盘开销。</p>
<p>需要补充说明的是，在做技术选型时，还需要考虑到硬件的发展。现今固态硬盘虽然价格较机械硬盘还是高出很多，但普及度越来越高。而固态硬盘在乱序写时，性能表现比机械硬盘会好很多，特别是多线程同时进行写操作时，性能也会比单线程顺序写强。对于需要同步刷盘保证数据可靠性的应用，磁盘读写性能的重要性一般来讲也会远高于磁盘的空间大小。 成本上来讲，如果可以显著的提高单机性能，虽然单价来看固态硬盘更加昂贵，但是如果可以节省部分 CPU，内存和机架位置，还是很划算的。</p>
<h2 id="服务可用性保障——复制与-failover-机制"><a href="#服务可用性保障——复制与-failover-机制" class="headerlink" title="服务可用性保障——复制与 failover 机制"></a>服务可用性保障——复制与 failover 机制</h2><p>制的实现，最简单的方式就是一主一从的结构，开源版本的 RocketMQ 即使用了这种模式。由两个 Broker 实例组成一组服务，一个作为主节点，提供读写服务，一个作为从节点，在正常情况下只从主节点同步数据不提供读写服务，且每个 topic 都会分配到多个 Broker 分组上。当某个从节点发生故障时，可以禁止主节点的写入，依然允许消费者继续消费该节点中未处理完成的消息。而生产者有新消息过来时，由其它主从都健康的分组提供服务， 直到故障机器恢复后主节点重新提供读写服务。如果故障机器无法恢复，只需等积压消息全部消费完，替换故障机器即可。 如果主节点故障，则可以在从节点进行消费，其它处理方式与从节点故障处理方式一致。 这种方式的优点是逻辑简单，实现也简单，简单意味着稳定，隐藏的 bug 少。且数据只需要一份冗余，对磁盘空间的开销相对较少，可以保证大多数情况下的数据可靠性和服务可用性。</p>
<p>Kafka 的复制策略，使用的是 ISR（可用服务列表）的方式，可以把他看成主从结构的升级版。对于每一个 partiton，可以分配一个或多个 Broker。 其中一个作为主节点，剩余的作为跟随者，跟随者会保存一个 partition 副本。生产者将消息发送到主节点后，主节点会广播给所有跟随者，跟随者收到后返回确认信息给主节点。 用户可以自由的配置副本数及当有几个副本写成功后，则认为消息成功保存。且同时，会在 ZooKeeper 上维护一个可用跟随者列表，列表中记录所有数据和主节点完全同步的跟随者列表。当主节点发生故障时，在列表中选择一个跟随者作为新的主节点提供服务。在这种策略下，假设总共有 m 个副本，要求至少有 n 个（0&lt;n&lt;m+1）副本写成功，则系统可以在最多 m-n 个机器故障的情况下保证可用性。</p>
<p>还有一种实现是基于 Raft 算法实现的多副本机制，具体细节可以参考官方的 paper。Raft 集群一般由奇数节点构成，如果要保证集群在 n 个节点故障的情况下可用，则至少需要有 2n+1 个节点。 与 ISR 方式相比，Raft 需要耗费更多的资源，但是整个复制和选举过程都是集群中的节点自主完成，不需要依赖 ZooKeeper 等第三者。 理论上 Raft 集群规模可以无限扩展而 ISR 模式下集群规模会受限于 ZooKeeper 集群的处理能力。</p>
<h2 id="两种消息队列实现的高级特性"><a href="#两种消息队列实现的高级特性" class="headerlink" title="两种消息队列实现的高级特性"></a>两种消息队列实现的高级特性</h2><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>一般情况下，因为消息分布在不同的 Broker 上，且有多个客户端同时消费，各实例间的网络状态和处理能力都是不一定的，所以分布式消息系统是没有办法保证消息的处理顺序的。但如果你了解了一般消息队列的文件结构，你就会发现不管是 Kafka 的 partition 那种方式，还是 RocketMQ 的方式，都可以保证同一个 partition 或者同一个 ConsumerQueue 内的消息是可以保证顺序的。剩下的，我们需要做的就是将需要保证顺序的消息放入到同一个 partiton 或者 queue 中就好了， 最简单的方式是我们只为主题分配一个 partition 或者 queue，这样就可以保证严格的顺序，但是这样就不能体现分布式系统的性能优势了，集群的处理能力没有办法横向扩展。</p>
<p>在实际的生产中，大多数情况下我们其实并不需要所有的消息都顺序处理，更多时候只要求具有相同特征的消息保证顺序，如电商系统中，一般要求具有相同订单号的消息需要保证顺序，不同的订单之间可以乱序，也就是说我们只要保证有办法将具有相同订单编号的消息放入到同一个队列或者 partition 中即可。</p>
<p>Kafka 提供了指定 partition 发送的功能，使用者可以在客户端根据业务逻辑自行处理，还有的消息队列支持根据某个字段的值，将消息 hash 到消息指定消息队列中。 指定 partition 和 hash 两种方式的主要区别，就是当有某个分片故障时，指定 partition 的方式会导致部分消息发送失败，而 hash 的方式有可能造成少量消息的乱序</p>
<h3 id="事物消息"><a href="#事物消息" class="headerlink" title="事物消息"></a>事物消息</h3><p>事务消息主要指消息生产过程中，需要确保发送操作和其它业务逻辑处理结果的一致性，要么都成功要么都失败。 比如要同时执行写入 MySQL 数据库和发送消息两种操作，要保证写库成功同时发送消息也成功，如果写库失败，消息也要取消发送。事务消息的实现一般是依赖两步提交策略。 已写库并发消息为例，首先客户端将消息发送到 Broker，Broker 收到消息后，给客户端返回一个确认信息。 这时消息在服务端是处于一种中间状态，消费者不可以消费这种状态的消息。 客户端收到确认消息后，执行写数据库的操作，写库成功后，向 Broker 再发送一个提交信息。 服务端收到提交信息后将消息更改就绪状态，允许消费者正常消费。 同时，生产者客户端还要提供一个回调方法，当 Broker 收到消息后，长时间没有收到确认信息时，调用客户端提供的回调方法进行回滚，如重置数据库。</p>
<h3 id="消息回放"><a href="#消息回放" class="headerlink" title="消息回放"></a>消息回放</h3><p>有时，消费者可能会因为系统问题或其它原因，需要重新消费已经消费完的消息。大部分消息队列都可以实现这个功能，一般将次功能称为消息回放。要实现消息回放的功能，需要保证消息不会在消费成功之后立刻删除，而是保存一段时间后，根据一定策略，如一周后删除。同时，还需要对消费者当前消费的消费位置进行记录，RocketMQ 和 Kafka 都会通过一个 Offset 文件来记录消费者的消费位置，当消费者消费完成功，更新并提交 Offset。一般来说，Offset 文件中还需要记录最大消费位置，即已经入队的最新一条消息所在的位置和最小消费位置，即还没删除的最老的消息所在的位置。Offset 文件可以保存在服务端，也可以保存在客户端，也可以保存在 ZooKeeper 中，或者其它如 Redis 之类的第三方存储。 早期版本（0.9.0 之前）的 Kafka 是将消息保存在 ZooKeeper 中，之后为了减轻 ZooKeeper 的负担，将 Offset 保存到 Broker 对应的 topic 中。 RocketMQ 则支持有两种模式，默认是集群模式，topic 中的每条消息只会集群中的一个实例消费，这种模式由服务端管理 Offset，还有一种是广播模式，集群中的所有实例都会消费一份全量消息，这种模式由客户端管理 Offset。</p>
<h2 id="影响单机性能的因素"><a href="#影响单机性能的因素" class="headerlink" title="影响单机性能的因素"></a>影响单机性能的因素</h2><p>afka 和 RocketMQ 都是优秀的分布式消息系统，当需要服务于有较高高吞吐量要求的服务时，都可以通过扩容来解决需求。虽然如此，我们也不应放弃对单机吞吐量的追求，毕竟单机处理能力越高，意味着可以节省更多资源。而决定单机性能的因素，我能想到的主要有下面几个方面：</p>
<h3 id="硬件层面"><a href="#硬件层面" class="headerlink" title="硬件层面"></a>硬件层面</h3><ul>
<li>硬盘：一般来说消息队列的瓶颈主要在磁盘 IO，更好的硬盘会带来更高的性能，正常情况性能由高到低排序为 NVMe &gt; 传统 SSD（Non-Volatile Memory express） &gt;SAS &gt;SATA。 对于 SAS 盘和 SATA 盘这种机械硬盘来说，还要看具体硬盘的转速。</li>
<li>Raid 卡: Raid 卡的型号和性能，以及是否带有 Raid 卡缓存，Raid 卡的鞋策略是 WriteThough 还是 WriteBack 也会影响到服务的 I/O 性能进而影响到吞吐量。</li>
</ul>
<h3 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a>系统层面</h3><ul>
<li>Raid 级别：当有 4 块盘时，Raid0，Raid5 和 Raid10 三种形式的 Raid 会对 I/O 性能造成不同的影响。Raid0 因为不需要任何其它操作，速度是最快的，几乎等于单盘写速度的四倍。Raid10 需要写一份数据和一份镜像，写性能是略小于单盘写速度的两倍的；Raid5 可以有三个盘提供写服务，另一个盘来存放校验和，由于计算校验和存在一定的性能损耗，写速度略小于单盘写速度的三倍，而且随着硬盘数量的增多，Raid5 计算校验和造成的开销会随之增大，如果没有 Raid 卡缓存支撑的话，在磁盘数量超过一定值后，性能是低于 Raid10 的。</li>
<li>Linux I/O 调度算法：Linux 内核包含 Noop，Deadline，CFG, Anticipatory 四种 I/O 调度算法，需要结合应用特性和硬件选择合适的调度算法。 据说 SSD 硬盘更适合使用 Noop 算法。</li>
<li>文件系统的 block size：调整合适的文件系统的 block size 也会提高吞吐量。</li>
<li>SWAP 的使用： SWAP 空间使用过程中会造成一定的 I/O 开销，如果内存充足的情况下，可以关闭 SWAP 功能。</li>
</ul>
<h3 id="应用层面"><a href="#应用层面" class="headerlink" title="应用层面"></a>应用层面</h3><ul>
<li>文件读写的方式：一般来说，顺序读写速度远高于随机读写，且一次性读写的文件越大相对来说效率越高。应用可以据此来对文件结构和读写方式做一定优化。</li>
<li>缓存策略： 应用可以通过一定的缓存策略，提前将可能用到的数据读到内存中，当收到请求时，如果能命中缓存中的数据，在缓存中直接读取效率远高于读写磁盘。同样，写操作时也可以通过缓存将零散的写操作进行汇集，提高写操作的效率。 所有适合的缓存策略将显著提高 Broker 的处理能力。</li>
</ul>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>Wikipedia - Message Queue : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Message_queue">https://en.wikipedia.org/wiki/Message_queue</a></li>
<li>infoQ - 漫谈消息队列：以 Kafka 和 RocketMQ 为例 : <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/s*RvY8D1jrNIsfOJylPE">https://www.infoq.cn/article/s*RvY8D1jrNIsfOJylPE</a></li>
<li>Pivotal bolg - Understanding When to use RabbitMQ or Apache Kafka : <a target="_blank" rel="noopener" href="https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka">https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/05/13/MessageQueue/" data-id="ckvgcipjl000yplqh3du00rq7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apache-Kafka/" rel="tag">Apache Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/message-queue/" rel="tag">message queue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaAnnotation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/11/JavaAnnotation/" class="article-date">
  <time datetime="2019-04-11T01:51:41.000Z" itemprop="datePublished">2019-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/11/JavaAnnotation/">Java Annotation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h1><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><h3 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h3><h3 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h3><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.html">@Transactional</a></h2><h3 id="Introduce-1"><a href="#Introduce-1" class="headerlink" title="Introduce"></a>Introduce</h3><p>javax.transaction.Transactional 注解提供了应用程序以声明式的方式控制事务的边界。此注解可以应用于Java EE规范定义为托管bean（包括CDI托管bean）的任何类。</p>
<p>javax.transaction.Transactional注释为应用程序提供了声明性地控制CDI托管bean上的事务边界的能力，以及Java EE规范定义为托管bean的类，在类和方法级别，方法级别注释覆盖了班级。</p>
<p>有关将@Transactional与EJB一起使用的限制，请参阅EJB规范。</p>
<p>这种支持是通过执行必要的挂起，恢复等的CDI拦截器实现的。事务拦截器仅插入业务方法调用而不插入生命周期事件。生命周期方法在未指定的事务上下文中调用。</p>
<p>如果尝试从使用@Transactional和NOT_SUPPORTED或NEVER以外的Transactional.TxType注释的bean或方法范​​围内调用UserTransaction接口的任何方法，则必须抛出IllegalStateException。在生命周期事件中允许使用UserTransaction。无论是否有任何@Transactional注释，都允许使用TransactionSynchronizationRegistry。</p>
<p>Transactional拦截器的优先级必须为Interceptor.Priority.PLATFORM_BEFORE + 200。有关更多详细信息，请参阅Interceptor规范。</p>
<p>注释的TxType元素指示是否要在事务上下文中执行bean方法。TxType.REQUIRED是默认值。</p>
<p>默认情况下，检查的异常不会导致事务拦截器标记事务以进行回滚以及RuntimeException及其子类的实例。可以通过指定导致拦截器标记事务以进行回滚的异常和/或不会导致回滚的异常来修改此默认行为。</p>
<p>可以设置rollbackOn元素以指示必须使拦截器将事务标记为回滚的异常。</p>
<p>相反，可以设置dontRollbackOn元素以指示异常，这些异常不得导致拦截器将事务标记为回滚。</p>
<p>为这些元素中的任何一个指定类时，指定的行为也适用于该类的子类。如果指定了两个元素，则dontRollbackOn优先。</p>
<h3 id="Source-Code-1"><a href="#Source-Code-1" class="headerlink" title="Source Code"></a>Source Code</h3><h3 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h3><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="EnableWebSecurity"><a href="#EnableWebSecurity" class="headerlink" title="@EnableWebSecurity"></a>@EnableWebSecurity</h2><h3 id="Introduce-2"><a href="#Introduce-2" class="headerlink" title="Introduce"></a>Introduce</h3><p>将此注解添加到@Configuration类中，以使Spring Security configuration在任何WebSecurityConfigurer定义，或者更可能通过扩展WebSecurityConfigurerAdapter基类和重写单个方法。<br>@EnableWebSecurity。它允许Spring查找（它是一个@Configuration，因此@Component）并自动将类应用于全局WebSecurity。</p>
<h3 id="Source-Code-2"><a href="#Source-Code-2" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class&#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableWebSecurity &#123;</span><br><span class="line">    boolean debug() default false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h3><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><h3 id="Introduce-3"><a href="#Introduce-3" class="headerlink" title="Introduce"></a>Introduce</h3><h3 id="Source-Code-3"><a href="#Source-Code-3" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line">    boolean required() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Usage-3"><a href="#Usage-3" class="headerlink" title="Usage"></a>Usage</h3><p><strong>Enabling @Autowired Annotations</strong></p>
<p>如果您在应用程序中使用基于Java的配置，则可以通过使用AnnotationConfigApplicationContext加载Spring Configuration来启用注解驱动的注入，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.baeldung.autowire.sample&quot;)</span><br><span class="line">public class AppConfig &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Spring XML中，则可以通过在Spring XML文件中声明它来启用它：&lt;context：annotation-config /&gt;</p>
<p><strong>Using @Autowired</strong></p>
<p>启用注释注入后，可以在属性，setter和构造函数上使用自动装配。</p>
<p><strong>@Autowired on Properties</strong></p>
<p>注释可以直接用于属性，因此不需要getter和setter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;fooFormatter&quot;)</span><br><span class="line">public class FooFormatter &#123;</span><br><span class="line"> </span><br><span class="line">    public String format() &#123;</span><br><span class="line">        return &quot;foo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class FooService &#123;</span><br><span class="line">     </span><br><span class="line">    @Autowired</span><br><span class="line">    private FooFormatter fooFormatter;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，春季查找并注入fooFormatter时FooService接口被创建。</p>
<p><strong>@Autowired on Setters</strong></p>
<p>该@Autowired注解可以在setter方法中使用。在下面的示例中，当在setter方法上使用注释时，在创建FooService时使用FooFormatter实例调用setter方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FooService &#123;</span><br><span class="line"> </span><br><span class="line">    private FooFormatter fooFormatter;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    public void setFooFormatter(FooFormatter fooFormatter) &#123;</span><br><span class="line">            this.fooFormatter = fooFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Autowired on Constructors</strong></p>
<p>该@Autowired注释也可以在构造函数中使用。在下面的示例中，当注释上的构造使用时，实例FooFormatter注入作为参数给构造时FooService接口创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FooService &#123;</span><br><span class="line"> </span><br><span class="line">    private FooFormatter fooFormatter;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    public FooService(FooFormatter fooFormatter) &#123;</span><br><span class="line">        this.fooFormatter = fooFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Autowired和Optional Dependencies</strong></p>
<p>Spring期望在构造依赖bean时可以使用@Autowired依赖项。如果框架无法解析bean进行连接，它将抛出下面引用的异常并阻止Spring容器成功启动：</p>
<blockquote>
<p>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException:<br>No qualifying bean of type [com.autowire.sample.FooDAO] found for dependency:<br>expected at least 1 bean which qualifies as autowire candidate for this dependency.<br>Dependency annotations:<br>{@org.springframework.beans.factory.annotation.Autowired(required=true)}</p>
</blockquote>
<p>为了避免这种情况发生，可以选择如下指定bean：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FooService &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private FooDAO dataAccessor; </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自动消除歧义</strong></p>
<p>默认情况下，Spring 按类型解析@Autowired条目。如果容器中有多个相同类型的bean，框架将抛出​​一个致命异常，表明有多个bean可用于自动装配。</p>
<p><strong>@Qualifier自动装配</strong></p>
<p>该@Qualifier注解可用于在暗示和缩小所需的bean：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;fooFormatter&quot;)</span><br><span class="line">public class FooFormatter implements Formatter &#123;</span><br><span class="line"> </span><br><span class="line">    public String format() &#123;</span><br><span class="line">        return &quot;foo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component(&quot;barFormatter&quot;)</span><br><span class="line">public class BarFormatter implements Formatter &#123;</span><br><span class="line"> </span><br><span class="line">    public String format() &#123;</span><br><span class="line">        return &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FooService &#123;</span><br><span class="line">     </span><br><span class="line">    @Autowired</span><br><span class="line">    private Formatter formatter;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于可以为Spring容器注入两个具体的Formatter实现，因此Spring 在构造FooService时会抛出NoUniqueBeanDefinitionException异常：</p>
<blockquote>
<p>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException:<br>No qualifying bean of type [com.autowire.sample.Formatter] is defined:<br>expected single matching bean but found 2: barFormatter,fooFormatter  </p>
</blockquote>
<p>通过使用@Qualifier注释缩小实现可以避免这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FooService &#123;</span><br><span class="line">     </span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;fooFormatter&quot;)</span><br><span class="line">    private Formatter formatter;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用特定实现的名称指定@Qualifier，在本例中为fooFormatter，当Spring找到多个相同类型的bean时，我们可以避免歧义。</p>
<p>请注意，价值@Qualifier注解与声明的名称相匹配@Component我们的注解FooFormatter实施。</p>
<p><strong>自定义限定符自动装配</strong></p>
<p>Spring允许我们创建自己的@Qualifier注释。要创建自定义限定符，请定义注释并在定义中提供@Qualifier注释，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Target(&#123;</span><br><span class="line">  ElementType.FIELD, ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface FormatterType &#123;</span><br><span class="line">     </span><br><span class="line">    String value();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义，FormatterType可以在各种实现中用于指定自定义值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@FormatterType(&quot;Foo&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class FooFormatter implements Formatter &#123;</span><br><span class="line"> </span><br><span class="line">    public String format() &#123;</span><br><span class="line">        return &quot;foo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FormatterType(&quot;Bar&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class BarFormatter implements Formatter &#123;</span><br><span class="line"> </span><br><span class="line">    public String format() &#123;</span><br><span class="line">        return &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释实现后，可以使用自定义限定符注释，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FooService &#123;</span><br><span class="line">     </span><br><span class="line">    @Autowired</span><br><span class="line">    @FormatterType(&quot;Foo&quot;)</span><br><span class="line">    private Formatter formatter;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Target注释中指定的值限制限定符可用于标记注入点的位置。</p>
<p>在上面的代码片段中，限定符可用于消除Spring可以将bean注入字段，方法，类型和参数的点的歧义。</p>
<p><strong>按名称自动装配</strong></p>
<p>作为回退，Spring使用bean名称作为默认限定符值。</p>
<p>因此，通过定义bean属性的名称，在这种情况下fooFormatter，spring 匹配的FooFormatter执行以及何时注入的具体实施FooService接口的构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FooService &#123;</span><br><span class="line">     </span><br><span class="line">    @Autowired</span><br><span class="line">    private Formatter fooFormatter;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<p>尽管@Qualifier和bean名称后备匹配都可以用于缩小到特定的bean，但是自动装配实际上是关于按类型注入的，这就是使用此容器功能的最佳方式。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><h3 id="Introduce-4"><a href="#Introduce-4" class="headerlink" title="Introduce"></a>Introduce</h3><p>Spring @Configuration注解有助于基于Spring注解的配置。@Configuration注解指示一个类声明一个或多个@Bean方法，并且可以由Spring容器处理，以在运行时为这些bean生成bean定义和服务请求。</p>
<h3 id="Source-Code-4"><a href="#Source-Code-4" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;</span><br><span class="line">    @AliasFor(</span><br><span class="line">        annotation = Component.class</span><br><span class="line">    )</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Usage-4"><a href="#Usage-4" class="headerlink" title="Usage"></a>Usage</h3><p>@Configuration在任何类的顶部使用注解来声明此类提供一个或多个@Bean方法，并且Spring容器可以处理它以在运行时为这些bean生成bean定义和服务请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.tutorialspoint;</span><br><span class="line">import org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class HelloWorldConfig &#123;</span><br><span class="line">   @Bean </span><br><span class="line">   public HelloWorld helloWorld()&#123;</span><br><span class="line">      return new HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将等同于以下XML配置 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id = &quot;helloWorld&quot; class = &quot;com.tutorialspoint.HelloWorld&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p><strong>创造Spring</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface DemoManager &#123;</span><br><span class="line">    public String getServiceName();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class DemoManagerImpl implements DemoManager</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getServiceName()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;My first service with Spring 3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带有@Configuration注解的Spring配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line">import com.howtodoinjava.core.beans.DemoManager;</span><br><span class="line">import com.howtodoinjava.core.beans.DemoManagerImpl;</span><br><span class="line"> </span><br><span class="line">@Configuration</span><br><span class="line">public class ApplicationConfiguration &#123;</span><br><span class="line"> </span><br><span class="line">    @Bean(name=&quot;demoService&quot;)</span><br><span class="line">    public DemoManager helloWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        return new DemoManagerImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Demo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.howtodoinjava.core.verify;</span><br><span class="line"> </span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"> </span><br><span class="line">import com.howtodoinjava.core.beans.DemoManager;</span><br><span class="line">import com.howtodoinjava.core.config.ApplicationConfiguration;</span><br><span class="line"> </span><br><span class="line">public class VerifySpringCoreFeature</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfiguration.class);</span><br><span class="line"> </span><br><span class="line">        DemoManager obj = (DemoManager) context.getBean(&quot;demoService&quot;);</span><br><span class="line"> </span><br><span class="line">        System.out.println( obj.getServiceName() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h2><p><em>Spring Boot 2.1.4 API : <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/condition/ConditionalOnProperty.html">https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/condition/ConditionalOnProperty.html</a></em></p>
<h3 id="Introduce-5"><a href="#Introduce-5" class="headerlink" title="Introduce"></a>Introduce</h3><blockquote>
<p>Spring Boot通过@ConditionalOnProperty来控制Configuration是否生效</p>
</blockquote>
<h3 id="Source-Code-5"><a href="#Source-Code-5" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Conditional(OnPropertyCondition.class)</span><br><span class="line">public @interface ConditionalOnProperty &#123;</span><br><span class="line"></span><br><span class="line">    String[] value() default &#123;&#125;; //数组，获取对应property名称的值，与name不可同时使用  </span><br><span class="line">  </span><br><span class="line">    String prefix() default &quot;&quot;;//property名称的前缀，可有可无  </span><br><span class="line">  </span><br><span class="line">    String[] name() default &#123;&#125;;//数组，property完整名称或部分名称（可与prefix组合使用，组成完整的property名称），与value不可同时使用  </span><br><span class="line">  </span><br><span class="line">    String havingValue() default &quot;&quot;;//可与name组合使用，比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置  </span><br><span class="line">  </span><br><span class="line">    boolean matchIfMissing() default false;//缺少该property时是否可以加载。如果为true，没有该property也会正常加载；反之报错  </span><br><span class="line">  </span><br><span class="line">    boolean relaxedNames() default true;//是否可以松散匹配，至今不知道怎么使用的  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Usage-5"><a href="#Usage-5" class="headerlink" title="Usage"></a>Usage</h3><blockquote>
<p>通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。<br>如果该值为空，则返回false;<br>如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。<br>如果返回值为false，则该configuration不生效；为true则生效。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">//在application.properties配置&quot;mf.assert&quot;，对应的值为true, 也可以不写prefix，全写在name里(name=&quot;mf.assert&quot;)</span><br><span class="line">@ConditionalOnProperty(prefix=&quot;mf&quot;,name = &quot;assert&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">public class AssertConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloServiceProperties helloServiceProperties;</span><br><span class="line">    @Bean</span><br><span class="line">    public HelloService helloService()&#123;</span><br><span class="line">        HelloService helloService = new HelloService();</span><br><span class="line">        helloService.setMsg(helloServiceProperties.getMsg());</span><br><span class="line">        return helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EnableEurekaServer"><a href="#EnableEurekaServer" class="headerlink" title="@EnableEurekaServer"></a>@EnableEurekaServer</h2><h3 id="Introduce-6"><a href="#Introduce-6" class="headerlink" title="Introduce"></a>Introduce</h3><p>标明该类是Eureka服务注册中心。</p>
<h2 id="EnableEurekaClient"><a href="#EnableEurekaClient" class="headerlink" title="@EnableEurekaClient"></a>@EnableEurekaClient</h2><h3 id="Introduce-7"><a href="#Introduce-7" class="headerlink" title="Introduce"></a>Introduce</h3><p>表明该服务Eureka的一个服务提供方。</p>
<h2 id="EnableDiscoverClient"><a href="#EnableDiscoverClient" class="headerlink" title="@EnableDiscoverClient"></a>@EnableDiscoverClient</h2><h3 id="Introduce-8"><a href="#Introduce-8" class="headerlink" title="Introduce"></a>Introduce</h3><p>声明该服务为Eureka中服务消费方</p>
<h2 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h2><h3 id="Introduce-9"><a href="#Introduce-9" class="headerlink" title="Introduce"></a>Introduce</h3><p>开启Feign声明式服务间通信（配合@FeignClient注解使用）。</p>
<blockquote>
<p>Feign是一个声明式的HTTP客户端，仅需要一个@FeignClient注解就能实现远程调用。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p>
</blockquote>
<h2 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h2><h3 id="Introduce-10"><a href="#Introduce-10" class="headerlink" title="Introduce"></a>Introduce</h3><p>实现远程调用,需要填写<strong>value</strong>值，value属性值必须等于一个已在Eureka中注册的服务名称。</p>
<h3 id="Source-Code-6"><a href="#Source-Code-6" class="headerlink" title="Source Code"></a>Source Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FeignClient &#123;</span><br><span class="line">    @AliasFor(&quot;name&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    String serviceId() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String contextId() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String qualifier() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String url() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean decode404() default false;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] configuration() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; fallback() default void.class;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; fallbackFactory() default void.class;</span><br><span class="line"></span><br><span class="line">    String path() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean primary() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Target(ElementType.TYPE)修饰，表示FeignClient的作用目标在接口上。<br>@Retention(RetentionPolicy.RUNTIME)注解表明该注解会在Class字节码中存在，在运行时可以通过反射获取到。<br>@Documented表明该注解被包含在javadoc中。</p>
<p>@FeignClient用于创建声明是API接口，该接口是RESTful风格的。Feign被设计成插拔式的，可注入其他组件和Feign一起使用。最典型的是如果Ribbon可用，Feign会和Ribbon相结合进行负载均衡。</p>
<p>在代码中，value()和name()一样，是被调用的服务的ServiceId。url()直接填写硬编码URL地址。decode404（）即404是被解码，还是抛异常。configuration（）指明FeignClient的配置类，默认的配置类为FeignClientsConfiguration类，在缺省情况下，这个类注入了默认的Decoder、Encoder和Constant等配置的bean。fallback()为配置熔断器的处理类。</p>
<h2 id="EnableHystrixDashboard"><a href="#EnableHystrixDashboard" class="headerlink" title="@EnableHystrixDashboard"></a>@EnableHystrixDashboard</h2><h3 id="Introduce-11"><a href="#Introduce-11" class="headerlink" title="Introduce"></a>Introduce</h3><p>开启对熔断器Hystrix的实时监控仪表盘</p>
<h2 id="EnableZuulProxy"><a href="#EnableZuulProxy" class="headerlink" title="@EnableZuulProxy"></a>@EnableZuulProxy</h2><h3 id="Introduce-12"><a href="#Introduce-12" class="headerlink" title="Introduce"></a>Introduce</h3><p>开启Zuul网关的支持。</p>
<h2 id="EnableConfigServer"><a href="#EnableConfigServer" class="headerlink" title="@EnableConfigServer"></a>@EnableConfigServer</h2><h3 id="Introduce-13"><a href="#Introduce-13" class="headerlink" title="Introduce"></a>Introduce</h3><p>开启配置文件服务支持</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/04/11/JavaAnnotation/" data-id="ckvgcipj80006plqh9jsb4925" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-annotation/" rel="tag">java annotation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jwt" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/09/jwt/" class="article-date">
  <time datetime="2019-04-09T02:06:15.000Z" itemprop="datePublished">2019-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/09/jwt/">JWT</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-JSON-Web-Token"><a href="#What-is-JSON-Web-Token" class="headerlink" title="What is JSON Web Token?"></a>What is JSON Web Token?</h1><p>JSON Web Token（JWT）是一个开放标准（<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>），它定义了一种简洁且独立的方式，用于在各方之间作为JSON对象安全地传输信息。此信息可以通过数字签名进行验证和信任。JWT可以使用安全算法（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名。</p>
<p>虽然JWT可以加密以在各方之间提供保密，但我们将专注于签名令牌。签名令牌可以验证其中包含的声明的完整性，而加密令牌则隐藏其他方的声明。当使用公钥/私钥对签名令牌时，签名还证明只有持有私钥的一方是签署它的一方。</p>
<p><strong>JWT特点</strong></p>
<ul>
<li>简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</li>
<li>自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库</li>
</ul>
<h1 id="When-should-you-use-JSON-Web-Tokens"><a href="#When-should-you-use-JSON-Web-Tokens" class="headerlink" title="When should you use JSON Web Tokens?"></a>When should you use JSON Web Tokens?</h1><p>以下是JSON Web令牌有用的一些场景：</p>
<ul>
<li>授权(Authorization)：这是使用JWT的最常见方案。一旦用户登录，每个后续请求都将包括JWT，允许用户访问该令牌允许的路由，服务和资源。Single Sign On(单点登录)是一种现在广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。</li>
<li>信息交换(Infomation Exchange)：JSON Web令牌是在各方之间安全传输信息的好方法。因为JWT可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。</li>
</ul>
<h1 id="What-is-the-JSON-Web-Token-structure"><a href="#What-is-the-JSON-Web-Token-structure" class="headerlink" title="What is the JSON Web Token structure?"></a>What is the JSON Web Token structure?</h1><p>在简洁的形式中，JSON Web Tokens由英语句号（.）分隔的三个部分组成，它们是：</p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<p>因此，JWT通常如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure>

<p>让我们分解不同的部分。</p>
<h2 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h2><p>标头(Head)通常由两部分组成：令牌的类型，即JWT，以及正在使用的签名算法，例如HMAC SHA256或RSA。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过Base64编码后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9ICA=</span><br></pre></td></tr></table></figure>

<h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>token(令牌)的第二部分是Payload，其中包含claims(声明)。Claims是关于实体（通常是用户）和其他数据的声明。Claims有三种类型：Registered，public和private claims。</p>
<ul>
<li>Registered Claims: 这些是一组预定义声明，不是强制性的，但建议使用，以提供一组有用的，可互操作的声明。其中一些是： <ul>
<li>iss（issuer） - 该JWT的签发者</li>
<li>exp（expiration time） - 什么时候过期，这里是一个Unix时间戳</li>
<li>sub（subject） - 该JWT所面向的用户</li>
<li>aud（audience） - 接收该JWT的一方</li>
<li>iat(issued at) - 在什么时候签发的</li>
<li>…</li>
</ul>
</li>
</ul>
<p>Notice that the claim names are only three characters long as JWT is meant to be compact</p>
<ul>
<li>Public Claims: 这些可以由使用JWT的人随意定义。但为避免冲突，应在 <a target="_blank" rel="noopener" href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web Token Registy</a> 中定义它们，或者将其定义为包含防冲突命名空间的URI。</li>
<li>Private Claims: These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims.</li>
</ul>
<p>An example payload could be:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;iss&quot;: &quot;Lefto.com&quot;,</span><br><span class="line">    &quot;iat&quot;: 1500218077,</span><br><span class="line">    &quot;exp&quot;: 1500218077,</span><br><span class="line">    &quot;aud&quot;: &quot;www.leftso.com&quot;,</span><br><span class="line">    &quot;sub&quot;: &quot;leftso@qq.com&quot;,</span><br><span class="line">    &quot;user_id&quot;: &quot;dc2c4eefe2d141490b6ca612e252f92e&quot;,</span><br><span class="line">    &quot;user_token&quot;: &quot;09f7f25cdb003699cee05759e7934fb2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，Payload经过Base64编码，形成JSON Web token的第二部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ewogICAgImlzcyI6ICJMZWZ0by5jb20iLAogICAgImlhdCI6IDE1MDAyMTgwNzcsCiAgICAiZXhwIjogMTUwMDIxODA3NywKICAgICJhdWQiOiAid3d3LmxlZnRzby5jb20iLAogICAgInN1YiI6ICJsZWZ0c29AcXEuY29tIiwKICAgICJ1c2VyX2lkIjogImRjMmM0ZWVmZTJkMTQxNDkwYjZjYTYxMmUyNTJmOTJlIiwKICAgICJ1c2VyX3Rva2VuIjogIjA5ZjdmMjVjZGIwMDM2OTljZWUwNTc1OWU3OTM0ZmIyIgp9</span><br></pre></td></tr></table></figure>

<p>请注意，对于 signed tokens(签名令牌) ，此信息虽然可以防止被篡改，但任何人都可以读取。除非加密，否则不要将秘密信息放在 JWT 的 Payload 或 Head 中。</p>
<h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p>签名其实是对JWT的头部和负载整合的一个签名验证<br>首先需要将头部和负载通过.链接起来就像这样:header.Payload,上述的例子链接起来之后就是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9ICA=.ewogICAgImlzcyI6ICJMZWZ0by5jb20iLAogICAgImlhdCI6IDE1MDAyMTgwNzcsCiAgICAiZXhwIjogMTUwMDIxODA3NywKICAgICJhdWQiOiAid3d3LmxlZnRzby5jb20iLAogICAgInN1YiI6ICJsZWZ0c29AcXEuY29tIiwKICAgICJ1c2VyX2lkIjogImRjMmM0ZWVmZTJkMTQxNDkwYjZjYTYxMmUyNTJmOTJlIiwKICAgICJ1c2VyX3Rva2VuIjogIjA5ZjdmMjVjZGIwMDM2OTljZWUwNTc1OWU3OTM0ZmIyIgp9</span><br></pre></td></tr></table></figure>

<p>例如，如果要使用HMAC SHA256算法，将按以下方式创建签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<p>由于HMAC SHA256加密算法需要一个key,我们这里key暂时用leftso吧,加密后的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">686855c578362e762248f22e2cc1213dc7a6aff8ebda52247780eb6b5ae91877</span><br></pre></td></tr></table></figure>

<p>其实加密的内容也就是JWT的签名,类似我们对某个文件进行MD5加密然后接收到文件进行md5对比一样.只是这里的HMAC SHA256算法需要一个key,当然这个key应该是使用者和接收者都知道的。</p>
<p>对上面的签名内容进行base64编码得到最终的签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Njg2ODU1YzU3ODM2MmU3NjIyNDhmMjJlMmNjMTIxM2RjN2E2YWZmOGViZGE1MjI0Nzc4MGViNmI1YWU5MTg3Nw==</span><br></pre></td></tr></table></figure>

<p>签名用于验证消息在此过程中未被更改，并且，在使用私钥签名的token的情况下，它还可以验证JWT的发行人是否是它所声称的人。</p>
<h2 id="Putting-all-together"><a href="#Putting-all-together" class="headerlink" title="Putting all together"></a>Putting all together</h2><p>输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，而与基于XML的标准（如SAML）相比更加简洁。</p>
<p>下面显示了一个JWT,它具有先前的 header 和 payload encoded, 并使用加密签名. </p>
<p><img src="/img/jwt/encoded-jwt3.png" alt="gcheap"></p>
<p>根据上面例子最终整合在一起的jwt:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9ICA=.ewogICAgImlzcyI6ICJMZWZ0by5jb20iLAogICAgImlhdCI6IDE1MDAyMTgwNzcsCiAgICAiZXhwIjogMTUwMDIxODA3NywKICAgICJhdWQiOiAid3d3LmxlZnRzby5jb20iLAogICAgInN1YiI6ICJsZWZ0c29AcXEuY29tIiwKICAgICJ1c2VyX2lkIjogImRjMmM0ZWVmZTJkMTQxNDkwYjZjYTYxMmUyNTJmOTJlIiwKICAgICJ1c2VyX3Rva2VuIjogIjA5ZjdmMjVjZGIwMDM2OTljZWUwNTc1OWU3OTM0ZmIyIgp9.</span><br><span class="line">Njg2ODU1YzU3ODM2MmU3NjIyNDhmMjJlMmNjMTIxM2RjN2E2YWZmOGViZGE1MjI0Nzc4MGViNmI1YWU5MTg3Nw==</span><br></pre></td></tr></table></figure>

<p>如果您想使用JWT并将这些概念付诸实践，您可以使用 <a target="_blank" rel="noopener" href="https://jwt.io/">jwt.io Debugger</a> 来解码，验证和生成JWT。</p>
<h1 id="How-do-JSON-Web-Tokens-work"><a href="#How-do-JSON-Web-Tokens-work" class="headerlink" title="How do JSON Web Tokens work?"></a>How do JSON Web Tokens work?</h1><p>在身份验证中，当用户使用其凭据成功登录时，将返回 JSON Web token 。由于 token 是 credentials(凭证) ，因此必须非常小心以防止出现安全问题。一般情况下，您不应该将 token 保留的时间超过要求。</p>
<p>当用户希望访问受保护的路由或资源时，用户代理应该发送JWT，通常在 Authorization header（授权头） 中使用 Bearer 模式。标题的内容应该如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，这可能是一种无状态授权机制。服务器的受保护路由将在授权头中检查有效的JWT，如果它存在，则允许用户访问受保护的资源。如果JWT包含必要的数据，就可以减少对数据库查询某些操作的需求，尽管情况并非总是如此。</p>
<p>如果令牌是在授权头中发送的，那么跨源资源共享(Cross-Origin Resource Sharing, CORS)就不是问题，因为它不使用cookie。</p>
<p>下图显示了JWT是如何获得并用于访问api或资源的:</p>
<p><img src="/img/jwt/client-credentials-grant.png" alt="gcheap"></p>
<ol>
<li>应用程序或客户端向授权服务器请求授权。这是通过不同的授权流之一执行的。例如，一个典型的符合<a target="_blank" rel="noopener" href="https://openid.net/connect/">OpenID Connect</a>的web应用程序将使用 <a target="_blank" rel="noopener" href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">authorization code flow</a> 通过/oauth/authorize端点。</li>
<li>当 authorization(授权) 被 grant(授予) 时，授权服务器将向应用程序返回一个access token(访问令牌)。</li>
<li>应用程序使用访问令牌访问受保护的资源(如API)。</li>
</ol>
<p>请注意，对于已签名的令牌，令牌中包含的所有信息都公开给用户或其他方，即使他们无法更改这些信息。这意味着您不应该将机密信息放在令牌中。</p>
<h1 id="Why-should-we-use-JSON-Web-Tokens"><a href="#Why-should-we-use-JSON-Web-Tokens" class="headerlink" title="Why should we use JSON Web Tokens?"></a>Why should we use JSON Web Tokens?</h1><p>让我们讨论一下与 Simple Web Tokens(SWT)和 Security Assertion Markup Language Tokens(SAML)相比，JSON Web Tokens(JWT)的好处。</p>
<p>由于JSON比XML更简洁，当它被编码时，它的大小也更小，这使得JWT比SAML更简洁。这使得JWT成为在HTML和HTTP环境中传递消息的一个很好的选择。</p>
<p>在安全方面，SWT只能由使用HMAC算法的共享秘密对称签名。但是，JWT和SAML令牌可以使用X.509证书形式的公钥/私钥对进行签名。与JSON签名的简单性相比，使用XML数字签名签名而不引入模糊的安全漏洞是非常困难的。</p>
<p>JSON解析器在大多数编程语言中都很常见，因为它们直接映射到对象。相反，XML没有一个自然的文档到对象的映射。这使得使用JWT比使用SAML assertions更容易。</p>
<p>在使用方面，JWT 用于互联网规模。这突出了 JSON Web token 在多个平台(尤其是移动平台)上的客户端处理的易用性。</p>
<p>如果您想了解更多关于JSON Web令牌的信息，甚至开始使用它们在您自己的应用程序中执行身份验证，请浏览到 <a target="_blank" rel="noopener" href="https://auth0.com/learn/json-web-tokens/">JSON Web Token landing page</a> 查看 Auth0。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/04/09/jwt/" data-id="ckvgcipjs001gplqh9ii6a7x5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Authentication/" rel="tag">Authentication</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSON/" rel="tag">JSON</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Token/" rel="tag">Token</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/protocol/" rel="tag">protocol</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Command-Line/">Command Line</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Network/">Computer Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Container-Orchestration/">Container Orchestration</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DatabaseTransaction/">DatabaseTransaction</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hacker-Laws/">Hacker Laws</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Internet-Protocol-Suite/">Internet Protocol Suite</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Script/">Java Script</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kubernetes/">Kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Message-Queue/">Message Queue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OSI-Model/">OSI Model</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-Paradigms/">Programming Paradigms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Software-Design-Patterns/">Software Design Patterns</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Transaction/">Transaction</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache-Kafka/" rel="tag">Apache Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Authentication/" rel="tag">Authentication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Authorization/" rel="tag">Authorization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/" rel="tag">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DatabaseTransaction/" rel="tag">DatabaseTransaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OAuth/" rel="tag">OAuth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OAuth-2-0/" rel="tag">OAuth 2.0</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Token/" rel="tag">Token</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transaction/" rel="tag">Transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cloud-platform/" rel="tag">cloud platform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/command/" rel="tag">command</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/command-line/" rel="tag">command-line</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compuer-network/" rel="tag">compuer network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/container/" rel="tag">container</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/creational/" rel="tag">creational</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/" rel="tag">data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design-patterns/" rel="tag">design patterns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hacker-laws/" rel="tag">hacker laws</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/internet/" rel="tag">internet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-annotation/" rel="tag">java annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-script/" rel="tag">java script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java10/" rel="tag">java10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java8/" rel="tag">java8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java9/" rel="tag">java9</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/" rel="tag">lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laws/" rel="tag">laws</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/message-queue/" rel="tag">message queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/" rel="tag">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oop/" rel="tag">oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/osi/" rel="tag">osi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/protocol/" rel="tag">protocol</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/protocol-suite/" rel="tag">protocol suite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-security/" rel="tag">spring security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/structural/" rel="tag">structural</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Apache-Kafka/" style="font-size: 10px;">Apache Kafka</a> <a href="/tags/Authentication/" style="font-size: 10px;">Authentication</a> <a href="/tags/Authorization/" style="font-size: 10px;">Authorization</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/DatabaseTransaction/" style="font-size: 10px;">DatabaseTransaction</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/OAuth/" style="font-size: 10px;">OAuth</a> <a href="/tags/OAuth-2-0/" style="font-size: 10px;">OAuth 2.0</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/RocketMQ/" style="font-size: 10px;">RocketMQ</a> <a href="/tags/Token/" style="font-size: 10px;">Token</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/cloud-platform/" style="font-size: 10px;">cloud platform</a> <a href="/tags/command/" style="font-size: 10px;">command</a> <a href="/tags/command-line/" style="font-size: 10px;">command-line</a> <a href="/tags/compuer-network/" style="font-size: 10px;">compuer network</a> <a href="/tags/container/" style="font-size: 10px;">container</a> <a href="/tags/creational/" style="font-size: 10px;">creational</a> <a href="/tags/data-structure/" style="font-size: 10px;">data structure</a> <a href="/tags/design-patterns/" style="font-size: 16.67px;">design patterns</a> <a href="/tags/hacker-laws/" style="font-size: 10px;">hacker laws</a> <a href="/tags/internet/" style="font-size: 10px;">internet</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java-annotation/" style="font-size: 10px;">java annotation</a> <a href="/tags/java-script/" style="font-size: 10px;">java script</a> <a href="/tags/java10/" style="font-size: 10px;">java10</a> <a href="/tags/java8/" style="font-size: 10px;">java8</a> <a href="/tags/java9/" style="font-size: 10px;">java9</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/laws/" style="font-size: 10px;">laws</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/message-queue/" style="font-size: 10px;">message queue</a> <a href="/tags/microservice/" style="font-size: 10px;">microservice</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/osi/" style="font-size: 10px;">osi</a> <a href="/tags/protocol/" style="font-size: 16.67px;">protocol</a> <a href="/tags/protocol-suite/" style="font-size: 10px;">protocol suite</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/spring-security/" style="font-size: 10px;">spring security</a> <a href="/tags/structural/" style="font-size: 10px;">structural</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.33px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/20/ECMAScript6/">ECMAScript6</a>
          </li>
        
          <li>
            <a href="/2019/05/30/LinuxCommandLine/">Linux Command-Line</a>
          </li>
        
          <li>
            <a href="/2019/05/24/OSIApplicationLayer/">Application Layer</a>
          </li>
        
          <li>
            <a href="/2019/05/21/TransactionProcessing/">Transaction</a>
          </li>
        
          <li>
            <a href="/2019/05/20/HackerLaws/">HackerLaws</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Paul Gao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>