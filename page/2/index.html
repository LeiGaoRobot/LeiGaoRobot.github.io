<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>PaulGao Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="PaulGao Blog">
<meta property="og:url" content="https://leigaorobot.github.io/page/2/index.html">
<meta property="og:site_name" content="PaulGao Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Paul Gao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="PaulGao Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PaulGao Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://leigaorobot.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-OAuth2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/OAuth2/" class="article-date">
  <time datetime="2019-04-08T09:44:59.000Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Security/">Security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/OAuth2/">OAuth2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-OAuth"><a href="#What-is-OAuth" class="headerlink" title="What is OAuth"></a>What is OAuth</h1><p>OAuth 即 Open standard for Authorization</p>
<p>OAuth是一个网络开放协议。为保证用户资源的安全授权提供了简易的标准</p>
<p>oAuth的好处：</p>
<ul>
<li>允许用户授权第三方网站或应用，访问用户存储在其它网站上的资源，而不需要将用户名和密码提供给第三方网站或分享他们数据的内容</li>
<li>对于用户:免去了繁琐的注册过程,降低了注册成本,提高了用户体验 </li>
<li>对于消费方:简化自身会员系统的同时又能够带来更多的用户和流量。</li>
<li>对于服务提供者:围绕自身进行开发,增加用户粘性 </li>
</ul>
<h1 id="OAuth2-0协议流程"><a href="#OAuth2-0协议流程" class="headerlink" title="OAuth2.0协议流程"></a>OAuth2.0协议流程</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>在介绍协议流程之前先要说明一下oauth2.0定义的几个角色：</p>
<ul>
<li>resource owner：资源所有者，这里可以理解为用户。</li>
<li>client：客户端，可以理解为一个第三方的应用程序。</li>
<li>resource server：资源服务器，它存储用户或其它资源。</li>
<li>authorization server：授权服务器，它认证resource owner的身份，为  resource owner提供授权审批流程，并最终颁发授权令牌(Access Token)。</li>
<li>user-agent：用户代理，这里可以理解为“浏览器”。</li>
</ul>
<p>这里面有个需要注意的地方，这里只是在逻辑上把authorization server与resource server区分开来；在物理上，authorization server与resource server的功能可以由同一个服务器来提供服务。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>用户打开客户端以后，客户端要求用户给予授权。</li>
<li>用户同意给予客户端授权。</li>
<li>客户端使用上一步获得的授权，向认证服务器申请令牌。</li>
<li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</li>
<li>客户端使用令牌，向资源服务器申请获取资源。</li>
<li>资源服务器确认令牌无误，同意向客户端开放资源。</li>
</ol>
<p>上面六个步骤之中，2是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<p>下面就介绍一下oauth2.0获取授权的几种方式。</p>
<h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><p>oauth2.0提供了四种授权模式，开发者可以根据自己的业务情况自由选择。</p>
<h3 id="应用程序注册-Application-Registration"><a href="#应用程序注册-Application-Registration" class="headerlink" title="应用程序注册(Application Registration)"></a>应用程序注册(Application Registration)</h3><p>对于一个应用程序来说，如果它想要使用OAuth，那么首先它要在服务提供商那里注册。</p>
<p>应用程序要提供：</p>
<ul>
<li>应用程序名称(Application Name)</li>
<li>应用程序网站(Application Website)</li>
<li>回调URL(Redirect URI or Callback URL)</li>
</ul>
<p>在用户同意授权(或者拒绝)之后，服务提供商会将用户重新导向这个Callback URL，这个Callback URL要来负责处理授权码或者访问令牌。</p>
<p>应用程序注册完成之后，服务提供商会颁发给应用程序一个“客户端认证信息(client credentials)”。Client Credential包括：</p>
<ul>
<li>Client ID<ul>
<li>提供给服务提供商，用于识别应用程序</li>
<li>用于构建提供给用户请求授权的URL</li>
</ul>
</li>
<li>Client Secret<ul>
<li>提供给服务提供商，用于验证应用程序</li>
<li>只有应用程序和服务提供商两者可知</li>
</ul>
</li>
</ul>
<h3 id="授权码授权模式（Authorization-Code-Grant）"><a href="#授权码授权模式（Authorization-Code-Grant）" class="headerlink" title="授权码授权模式（Authorization Code Grant）"></a>授权码授权模式（Authorization Code Grant）</h3><ol>
<li>用户访问客户端，客户端将用户引导向认证服务器。</li>
<li>用户选择是否给予客户端授权。</li>
<li>如用户给予授权，认证服务器将用户引导向客户端指定的redirection uri，同时加上授权码code。</li>
<li>客户端收到code后，通过后台的服务器向认证服务器发送code和redirection uri。</li>
<li>认证服务器验证code和redirection uri，确认无误后，响应客户端访问令牌（access token）和刷新令牌（refresh token）。</li>
</ol>
<h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><p>（1）步骤：客户端申请认证的URI</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/v1/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read&amp;state=xxx</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>response_type：授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：客户端的ID，必选项</li>
<li>redirect_uri：重定向URI，必选项</li>
<li>scope：申请的权限范围，可选项</li>
<li>state：任意值，认证服务器会原样返回,用于抵制CSRF(跨站请求伪造)攻击。</li>
</ul>
<p>（3）步骤：服务器回应客户端的URI</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xxx</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>code：授权码，必选项。授权码有效期通常设为10分钟，一次性使用。该码与客户端ID、重定向URI以及用户，是一一对应关系。</li>
<li>state：原样返回客户端传的该参数的值。</li>
</ul>
<p>（4）步骤：客户端向认证服务器申请令牌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/v1/oauth/token?client_id=CLIENT_ID&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>client_id：表示客户端ID，必选项。</li>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
</ul>
<p>注意：协议里没有提及client_secret参数，建议可以使用此参数进行客户端的二次验证。</p>
<p>（5）步骤：响应（4）步骤的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">   &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">   &quot;expires_in&quot;:3600,</span><br><span class="line">   &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">   &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>access_token：访问令牌，必选项。</li>
<li>token_type：令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>使用场景</p>
<ul>
<li>授权码模式是最常见的一种授权模式，在OAuth2.0内是最安全和最完善的。</li>
<li>适用于所有有Server端的应用，如Web站点、有Server端的手机客户端。 </li>
<li>可以得到较长期限授权。</li>
</ul>
<h3 id="隐式授权模式（Implicit-Grant）"><a href="#隐式授权模式（Implicit-Grant）" class="headerlink" title="隐式授权模式（Implicit Grant）"></a>隐式授权模式（Implicit Grant）</h3><ol>
<li>客户端将用户引导向认证服务器。</li>
<li>用户决定是否给于客户端授权。</li>
<li>假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</li>
<li>浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</li>
<li>资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</li>
<li>浏览器执行上一步获得的脚本，提取出令牌。</li>
<li>浏览器将令牌发给客户端。</li>
</ol>
<h4 id="请求示例-1"><a href="#请求示例-1" class="headerlink" title="请求示例"></a>请求示例</h4><p>（1）步骤：客户端发出请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/authorize?response_type=token&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read&amp;state=xxx</span><br></pre></td></tr></table></figure>

<p>参数说明 </p>
<ul>
<li>response_type：授权类型，此处的值固定为”token”，必选项。</li>
<li>client_id：客户端的ID，必选项。</li>
<li>redirect_uri：重定向的URI，必选项。</li>
<li>scope：权限范围，可选项。</li>
<li>state: 任意值，认证服务器会原样返回,用于抵制CSRF(跨站请求伪造)攻击。</li>
</ul>
<p>（3）步骤：认证服务器响应客户端的请求url</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/callback#access_token=ACCESS_TOKEN&amp;state=xyz&amp;token_type=example&amp;expires_in=3600&amp;state=xxx</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li>access_token：访问令牌，必选项。</li>
<li>token_type：令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>使用场景</p>
<ul>
<li>适用于所有无Server端配合的应用</li>
<li>如手机/桌面客户端程序、浏览器插件。</li>
<li>基于JavaScript等脚本客户端脚本语言实现的应用。</li>
</ul>
<p>注意：因为Access token是附着在 redirect_uri 上面被返回的，所以这个 Access token就可能会暴露给资源所有者或者设置内的其它方（对资源所有者来说，可以看到redirect_uri，对其它方来说，可以通过监测浏览器的地址变化来得到 Access token）。</p>
<h3 id="密码模式（Resource-Owner-Password-Credentials-Grant）"><a href="#密码模式（Resource-Owner-Password-Credentials-Grant）" class="headerlink" title="密码模式（Resource Owner Password Credentials Grant）"></a>密码模式（Resource Owner Password Credentials Grant）</h3><ol>
<li>用户向客户端提供用户名和密码。</li>
<li>客户端将用户名和密码发给认证服务器，向后者请求令牌。</li>
<li>认证服务器确认无误后，向客户端提供访问令牌</li>
</ol>
<h4 id="请求示例-2"><a href="#请求示例-2" class="headerlink" title="请求示例"></a>请求示例</h4><p>（2）步骤：客户端发出https请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li>grant_type：授权类型，此处的值固定为”password”，必选项。</li>
<li>username：用户名，必选项。</li>
<li>password：用户的密码，必选项。</li>
<li>scope：权限范围，可选项。</li>
</ul>
<p>（3）步骤：向客户端响应（2）步骤的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">       &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">       &quot;expires_in&quot;:3600,</span><br><span class="line">       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li>access_token：访问令牌，必选项。</li>
<li>token_type：令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：更新令牌，用来获取下一次的访问令牌，可选项。</li>
</ul>
<p>使用场景</p>
<ul>
<li>这种模式适用于用户对应用程序高度信任的情况。比如是用户操作系统的一部分。</li>
<li>认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</li>
</ul>
<h3 id="客户端凭证模式（Client-Credentials-Grant）"><a href="#客户端凭证模式（Client-Credentials-Grant）" class="headerlink" title="客户端凭证模式（Client Credentials Grant）"></a>客户端凭证模式（Client Credentials Grant）</h3><ol>
<li>客户端向认证服务器进行身份认证，并要求一个访问令牌。</li>
<li>认证服务器确认无误后，向客户端提供访问令牌。</li>
</ol>
<h4 id="请求示例-3"><a href="#请求示例-3" class="headerlink" title="请求示例"></a>请求示例</h4><p>（1）步骤：客户端发送https请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/token?grant_type=client_credentials&amp;client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。</li>
<li>client_id：客户端的ID，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>（2）步骤：向客户端响应（1）步骤的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>access_token：访问令牌，必选项。</li>
<li>token_type：令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>example_parameter：其它参数，可选项。 </li>
</ul>
<p>使用场景</p>
<ul>
<li>客户端模式应用于应用程序想要以自己的名义与授权服务器以及资源服务器进行互动。</li>
<li>例如使用了第三方的静态文件服务</li>
</ul>
<h2 id="刷新TOKEN"><a href="#刷新TOKEN" class="headerlink" title="刷新TOKEN"></a>刷新TOKEN</h2><p>从上面的四种授权流程可以看出，最终的目的是要获取用户的授权令牌（access_token）。而且授权令牌（access_token）的权限也非常之大，</p>
<p>所以在协议中明确表示要设置授权令牌（access_token）的有效期。那么当授权令牌（access_token）过期要怎么办呢，协议里提出了一个刷新token的流程。</p>
<p><img src="/img/oauth2.0/oauth2_refreshToken.png" alt="gcheap"></p>
<p>（A）–（D）通过授权流程获取access_token，并调用业务api接口。</p>
<p>（F）当调用业务api接口时响应“Invalid Token Error”时。</p>
<p>（G）调用刷新access_token接口，使用参数refresh_token（如果平台方提供，否则需要用户重新进行授权流程）。</p>
<p>（H）响应最新的access_token及refresh_token。</p>
<h3 id="请求示例-4"><a href="#请求示例-4" class="headerlink" title="请求示例"></a>请求示例</h3><p>（G）步骤：客户端调用刷新token接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/v1/oauth/token?grant_type=refresh_token&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<ul>
<li>client_id：客户端的ID，必选项。</li>
<li>client_secret：客户端的密钥，必选项。</li>
<li>grant_type：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
</ul>
<p>（H）步骤：响应客户端数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<ul>
<li>access_token：访问令牌，必选项。</li>
<li>token_type：令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>说明：建议将access_token和refresh_token的过期时间保存下来，每次调用平台方的业务api前先对access_token和refresh_token进行一下时间判断，如果过期则执行刷新access_token或重新授权操作。refersh_token如果过期就只能让用户重新授权。</p>
<p>好，到此oauth2.0的四种授权流程及令牌的刷新流程已经介绍完了，下面来从oauth2.0的安全性上来介绍一下。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="漏洞安全回顾"><a href="#漏洞安全回顾" class="headerlink" title="漏洞安全回顾"></a>漏洞安全回顾</h2><p>OAuth2.0协议本身设计是安全的，但是不同的开放平台开发者能力参差不齐，在开发过程中没有严格按照协议进行开发，或对流程中的参数校验不完整，造成了一些流程上的漏洞。</p>
<h3 id="安全漏洞回顾之授权码授权模式（授权流程参照前面的介绍）"><a href="#安全漏洞回顾之授权码授权模式（授权流程参照前面的介绍）" class="headerlink" title="安全漏洞回顾之授权码授权模式（授权流程参照前面的介绍）"></a>安全漏洞回顾之授权码授权模式（授权流程参照前面的介绍）</h3><p>漏洞：针对应用方csrf劫持第三方账号</p>
<p>wooyun案例：</p>
<p>2012-11-10 WooYun: <a target="_blank" rel="noopener" href="http://www.wooyun.org/bugs/wooyun-2012-014571">优酷网存在账号被劫持风险</a></p>
<p>2013-01-07 WooYun: <a target="_blank" rel="noopener" href="http://www.wooyun.org/bugs/wooyun-2013-017051">大麦网存在帐号被劫持风险</a></p>
<p>2013-03-01 WooYun: <a target="_blank" rel="noopener" href="http://www.wooyun.org/bugs/wooyun-2013-019367">美丽说oauth漏洞可劫持账号</a></p>
<p><img src="/img/oauth2.0/AuthorizationCodeGrantBug.jpg" alt="gcheap"><br>　针对code参数的Authorization Code Grant攻击；以及和rfc6749的流程图关系</p>
<p>漏洞成因：</p>
<p>主要的漏洞原因是redirect_uri中的code参数没有和当前客户端的状态绑定，攻击者可以通过发送预先获取好的code参数到受害者电脑，导致导致受害者当前登录的应用方账号被绑定到攻击者指定的平台方（如微博）帐号上。</p>
<p>解决方案：</p>
<p>应用方要预防这种csrf劫持账号，加入state参数是比较简单的通行方法。根据rfc6749 章节10.12，该值既不可预测，又必须可以证明应用（client）和和当前第三方网站的登录认证状态存在关联（如果存在过期时间更好）。一种简单的方法是：随机算一个字符串，然后保存在session，回调时检查state参数和session里面的值。<br>而平台方也要在回调时，支持应用方的state参数（当然如果允许redirect_uri参数中带应用方自己的防csrf参数，其实也可以）。<br>同时在使用code获取access_token成功后，进行access_token与授权用户绑定时，尽量不要直接与当前登录用户进行绑定。<br>但严格来讲，仅有state参数，其实还不够，还需要结合rfc6749 章节3.3（发放有业务接口仅限范围的令牌）提到的防御手段</p>
<h3 id="安全漏洞回顾之隐式授权模式（授权流程参照前面的介绍）"><a href="#安全漏洞回顾之隐式授权模式（授权流程参照前面的介绍）" class="headerlink" title="安全漏洞回顾之隐式授权模式（授权流程参照前面的介绍）"></a>安全漏洞回顾之隐式授权模式（授权流程参照前面的介绍）</h3><p>漏洞：针对存储型xss劫持用户的access_token</p>
<p>wooyun案例：</p>
<p>2012-04-15 WooYun: 人人网Oauth 2.0授权可导致用户access_token泄露</p>
<p>2012-09-25 WooYun: QQ互联开放平台QQ登陆oauth授权接口可以劫持access_token</p>
<p>2012-09-25 WooYun: 百度开放平台oauth授权接口可以劫持access_token</p>
<p><img src="/img/oauth2.0/ImplicitGrantBug.png" alt="gcheap"></p>
<p>漏洞成因：</p>
<p>隐式授权模式场景的特点是授权验证时只需要client_id和redirect_uri这两个参数作应用标识，返回的时候也就直接在uri片段中返回access token。那就是只要合作方网站、平台方网站甚至是浏览器三者之一有任何一个xss，就很容易通过xss获取到access token，然后以此攻击受害者的平台方账号。</p>
<p>解决方案：</p>
<p>解决这个问题，rfc6749第10.16小节就只是语焉不详的说需要额外的安全措施，这也反映了这种场景的防御难处。</p>
<p>有一种方案，平台方必须对应用方的应用强制进行分类，即应用方在申请client_id（即应用appkey）时，需要选择属于哪类应用；平台方再根据分类开放对应权限，并且进行特定的防御和监控措施。</p>
<h3 id="安全漏洞回顾之密码模式（授权流程参照前面的介绍）"><a href="#安全漏洞回顾之密码模式（授权流程参照前面的介绍）" class="headerlink" title="安全漏洞回顾之密码模式（授权流程参照前面的介绍）"></a>安全漏洞回顾之密码模式（授权流程参照前面的介绍）</h3><p>wooyun案例：</p>
<p>2012-11-05 WooYun: <a target="_blank" rel="noopener" href="http://www.wooyun.org/bugs/wooyun-2012-014408">开心网android客户端暴力破解漏洞，测试2000帐号，成功132个</a></p>
<p><img src="/img/oauth2.0/RourceOwnerPasswordCredentialsGrantBug.png" alt="gcheap"></p>
<p>解决方案：</p>
<p>（1）对于外部合作方，最大限度取消且不使用密码授权的授权。对于因为合同原因而导致无法取消的情况，需要加强监控。</p>
<p>（2）内部应用一样要划分等级，无必要的应用一律禁止使用密码授权模式。</p>
<h2 id="安全性建议"><a href="#安全性建议" class="headerlink" title="安全性建议"></a>安全性建议</h2><p><strong>资源提供方</strong></p>
<ul>
<li>对client_id和回调地址做严格校验 </li>
<li>获取access token的code仅能使用一次，且与授权用户关联</li>
<li>尽量避免直接读取当前用户session进行绑定</li>
<li>有效使用client_secret参数</li>
</ul>
<p><strong>资源使用方</strong></p>
<ul>
<li>使用Authorization Code方式进行授权</li>
<li>授权过程使用state随机哈希,并在服务端进行判断</li>
<li>尽量使用HTTPS保证授权过程的安全性</li>
</ul>
<p>最后，对oauth2.0有详细的了解，严格按照流程进行开发。</p>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>官方文档 : <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></li>
<li>说说oauth那点事 : <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/b06944c92228">http://www.jianshu.com/p/b06944c92228</a></li>
<li>OAuth 2.0安全案例回顾 : <a target="_blank" rel="noopener" href="http://www.cnblogs.com/maoxiaolv/p/5832996.html">http://www.cnblogs.com/maoxiaolv/p/5832996.html</a></li>
<li>Oauth2.0详解及安全使用 : <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoxiaolv/p/5838680.html">https://www.cnblogs.com/maoxiaolv/p/5838680.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/04/08/OAuth2/" data-id="ckvgcipjk000vplqh2104bacx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Authorization/" rel="tag">Authorization</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OAuth/" rel="tag">OAuth</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OAuth-2-0/" rel="tag">OAuth 2.0</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/protocol/" rel="tag">protocol</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaDataStructure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/12/javaDataStructure/" class="article-date">
  <time datetime="2019-02-12T05:47:29.000Z" itemprop="datePublished">2019-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/12/javaDataStructure/">Java 数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-Data-Structures"><a href="#Java-Data-Structures" class="headerlink" title="Java Data Structures"></a>Java Data Structures</h1><ul>
<li>Queue(队列)</li>
<li>Set(无序集合)</li>
<li>List(有序集合)</li>
<li>Map(键值对集合)</li>
<li>Tree(树)</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="What-is-Queue"><a href="#What-is-Queue" class="headerlink" title="What is Queue ?"></a>What is Queue ?</h2><p>Queue 是一种线性结构，遵循执行操作的特定顺序。顺序是先进先出（First In Fiest Out,FIFO）,尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p>
<h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><p>队列主要有以下四个操作:</p>
<ul>
<li>Enqueue(入队) - 添加一项到队列中。如果队列已满，则称其为溢出条件。</li>
<li>Dequeue(出队) - 从队列中删除一项。剩余的这些项按顺序排列。如果队列为空，则称其为下溢条件。</li>
<li>Front - 从队列中获取最前面的项。</li>
<li>Rear - 从队列中获取最后一项。</li>
</ul>
<h3 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h3><h3 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/52860924">Java 集合深入理解（9）：Queue 队列</a></p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 继承于 Collection 接口，是一个不允许出现重复元素，并且无序的集合，主要 HashSet 和 TreeSet 两大实现类。</p>
<p>在判断重复元素的时候，Set 集合会调用 hashCode()和 equal()方法来实现。</p>
<p>补充：有序集合与无序集合说明</p>
<p>有序集合：集合里的元素可以根据 key 或 index 访问 (Map、List)</p>
<p>无序集合：集合里的元素只能遍历。（Set）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/02/12/javaDataStructure/" data-id="ckvgcipjq001bplqh2f12as5t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-structure/" rel="tag">data structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Object-orientedProgramming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/03/Object-orientedProgramming/" class="article-date">
  <time datetime="2019-02-03T00:52:09.000Z" itemprop="datePublished">2019-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming-Paradigms/">Programming Paradigms</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/03/Object-orientedProgramming/">面向对象编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象编程-Object-oriented-programming-OOP"><a href="#面向对象编程-Object-oriented-programming-OOP" class="headerlink" title="面向对象编程(Object-oriented programming,OOP)"></a>面向对象编程(Object-oriented programming,OOP)</h1><p>面向对象编程(Object-oriented programming)是一种基于“对象”概念的编程范式，其中可能包含数据的字段,通常称为属性;和一段代码,以程序过程的形式,通常被称为方法。对象的一个​​特性是对象的过程可以访问并经常修改与之关联的对象的数据字段（对象具有“this”或“self”的概念）。在OOP中，计算机程序的设计是通过彼此交互的对象来实现的。OOP的语言有很多种，但最流行的是基于类的，这意味着对象是类的实例，通常也会确定它们的类型。</p>
<p>许多最广泛使用的编程语言（如C++, Object Pascal, Java, Python等）都是多范式编程语言，或多或少都支持面向对象编程，通常与命令式程序编程相结合。重要的面向对象语言包括Java，C ++，C＃，Python，PHP，JavaScript，Ruby，Perl，Object Pascal，Objective-C，Dart，Swift，Scala，Common Lisp和Smalltalk。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_programming">wikipedia</a></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><h3 id="Object-and-Class"><a href="#Object-and-Class" class="headerlink" title="Object and Class"></a>Object and Class</h3><p>支持面向对象的语言通常使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/02/03/Object-orientedProgramming/" data-id="ckvgcipjm0011plqhax506110" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oop/" rel="tag">oop</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaBasicKnowledga" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/01/JavaBasicKnowledga/" class="article-date">
  <time datetime="2019-02-01T12:42:21.000Z" itemprop="datePublished">2019-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/JavaBasicKnowledga/">Java 基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h1><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><ul>
<li><strong>优点</strong> ： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
<li><strong>缺点</strong> ： 没有面向对象易维护、易复用、易扩展</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li><strong>优点</strong> ： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
<li><strong>缺点</strong> ： 性能比面向过程低</li>
</ul>
<hr>
<h1 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h1><h2 id="简单易学-Simple"><a href="#简单易学-Simple" class="headerlink" title="简单易学(Simple)"></a>简单易学(Simple)</h2><p>Java非常容易学习，其语法简单，干净且易于理解。根据Sun的说法，Java语言是一种简单的编程语言，因为：</p>
<ul>
<li>Java语法基于 C++（程序员在 C++ 之后学习它更容易）。</li>
<li>Java已经删除了许多复杂且很少使用的功能，例如，显式指针，运算符重载等。</li>
<li>由于Java中存在自动垃圾收集，因此无需删除未引用的对象。</li>
</ul>
<h2 id="面向对象-Object-oriented"><a href="#面向对象-Object-oriented" class="headerlink" title="面向对象(Object-oriented)"></a>面向对象(Object-oriented)</h2><p>Java是一种面向对象的编程语言。 Java中的所有东西都是一个对象。面向对象意味着我们将软件组织为包含数据和行为的不同类型对象的组合。</p>
<p>面向对象编程（OOP）是一种通过提供一些规则来简化软件开发和维护的方法。</p>
<p>OOP的基本概念：</p>
<ul>
<li>Object(对象)</li>
<li>Class(类)</li>
<li>Inheritance(继承)</li>
<li>Polymorphism(多态)</li>
<li>Abstraction(抽象)</li>
<li>Encapsulation(封装)</li>
</ul>
<h2 id="平台无关性-Platform-Independent"><a href="#平台无关性-Platform-Independent" class="headerlink" title="平台无关性(Platform Independent)"></a>平台无关性(Platform Independent)</h2><p>Java是独立于平台的，因为它不同于其他语言，如C，C ++等，它们被编译成平台特定的机器，而Java是 write once,run anywhere(一次编写，随处运行) 的语言。平台指的是程序运行的硬件或软件环境。</p>
<p>平台主要有两种类型，一种是基于软件和另一种基于硬件。 Java提供了一个基于软件的平台。</p>
<p>Java平台与大多数其他平台的不同之处在于它是基于软件的平台，可以运行在其他基于硬件的平台之上。它有两个组成部分：</p>
<ul>
<li>Runtime Environment(运行环境)</li>
<li>Application Programming Interface(API)</li>
</ul>
<p>Java代码可以在多个平台上运行，例如，Windows，Linux，Sun Solaris，Mac/OS等.Java代码由编译器编译并转换为字节码。此字节码是与平台无关的代码，因为它可以在多个平台上运行，即一次写入和随处运行（WORA）。</p>
<h2 id="健壮性-Robust"><a href="#健壮性-Robust" class="headerlink" title="健壮性(Robust)"></a>健壮性(Robust)</h2><p>健壮只是意味着强壮。Java非常强壮，因为：</p>
<ul>
<li>它使用强大的内存管理。</li>
<li>缺乏指针可以避免安全问题。</li>
<li>java中有自动垃圾收集，它在Java虚拟机上运行，​​以摆脱Java应用程序不再使用的对象。</li>
<li>Java中有异常处理和类型检查机制。</li>
</ul>
<p>所有这些要点使Java变得健壮。</p>
<h2 id="安全性-Secured"><a href="#安全性-Secured" class="headerlink" title="安全性(Secured)"></a>安全性(Secured)</h2><p>Java以其安全性而闻名。使用Java，我们可以开发无病毒系统。 Java是安全的，因为：</p>
<ul>
<li>没有明确的指针</li>
<li>Java程序在虚拟机沙箱中运行</li>
<li>Classloader(类加载器): Java中的lassloader是Java运行时环境（JRE）的一部分，用于动态地将Java类加载到Java虚拟机中。它通过将本地文件系统的类的包与从网络源导入的包分开来增加安全性。</li>
<li>Bytecode Verifier(字节码验证器): 检查代码片段中是否存在违反对象访问权限的非法代码。</li>
<li>Security Manager(安全管理器): 它确定类可以访问哪些资源，例如读取和写入本地磁盘。</li>
</ul>
<p>Java语言默认提供这些保障。应用程序开发人员还可以通过SSL，JAAS，Cryptography等明确提供某些安全性。</p>
<h2 id="体系结构中立-Architecture-neutral"><a href="#体系结构中立-Architecture-neutral" class="headerlink" title="体系结构中立(Architecture-neutral)"></a>体系结构中立(Architecture-neutral)</h2><p>Java是体系结构中立的，因为没有依赖于实现的特性，例如，原始类型的大小是固定的。</p>
<p>在C编程中，int数据类型占用32位架构的2字节内存和64位架构的4字节内存。但是，对于Java中的32位和64位体系结构，它都是占用4个字节的内存。</p>
<h2 id="轻便-POrtable"><a href="#轻便-POrtable" class="headerlink" title="轻便(POrtable)"></a>轻便(POrtable)</h2><p>Java是可移植的，因为它便于您将Java字节码传送到任何平台。它不需要任何实现。</p>
<h2 id="高性能-High-performance"><a href="#高性能-High-performance" class="headerlink" title="高性能(High-performance)"></a>高性能(High-performance)</h2><p>Java比其他传统的解释型编程语言更快，因为Java字节码与本机代码“接近”。它仍然比编译语言（例如，C++）慢一点。Java是一种解释型语言，这就是它比编译语言慢的原因，例如C，C ++等。</p>
<h2 id="分布式-Distributed"><a href="#分布式-Distributed" class="headerlink" title="分布式(Distributed)"></a>分布式(Distributed)</h2><p>Java是分布式的，因为它有助于用户使用Java创建分布式应用程序。RMI和EJB用于创建分布式应用程序。Java的这一特性使我们能够通过从互联网上的任何机器调用方法来访问文件。</p>
<h2 id="多线程-Multi-threaded"><a href="#多线程-Multi-threaded" class="headerlink" title="多线程(Multi-threaded)"></a>多线程(Multi-threaded)</h2><p>线程就像一个单独的程序，并发执行。我们可以编写通过定义多个线程来同时处理许多任务的Java程序。多线程的主要优点是它不占用每个线程的内存。它共享一个共同的内存区域。线程对于多媒体，Web应用程序等很重要。</p>
<h2 id="动态-Dynamic"><a href="#动态-Dynamic" class="headerlink" title="动态(Dynamic)"></a>动态(Dynamic)</h2><p>Java是一种动态语言。它支持动态加载类。这意味着按需加载类。它还支持来自其本机语言的函数，即C和C++。</p>
<p>Java支持动态编译和自动内存管理(垃圾回收，gatbage collection)。</p>
<hr>
<h1 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM,JDK,JRE"></a>JVM,JDK,JRE</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</p>
<p>JDK有以下三种版本： </p>
<ul>
<li>J2SE，standard edition，标准版，是我们通常用的一个版本</li>
<li>J2EE，enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序</li>
<li>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</li>
</ul>
<p>我们常常用JDK来代指Java API，Java API是Java的应用程序接口，其实就是前辈们写好的一些java Class，包括一些重要的语言结构以及基本图形，网络和文件I/O等等，我们在自己的程序中，调用前辈们写好的这些Class，来作为我们自己开发的一个基础。当然，现在已经有越来越多的性能更好或者功能更强大的第三方类库供我们使用。</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</p>
<p><strong>字节码</strong></p>
<blockquote>
<p>在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
</blockquote>
<p>.java文件(源代码) [JDK中javac编译]-&gt; .class文件(JVM可理解的java字节) [JVM]-&gt; 机器可执行二进制机器码</p>
<p>需要格外注意的是 .class-&gt;机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<p><strong>JIT</strong></p>
<blockquote>
<p>即时编译（英语：Just-in-time compilation），又译及时编译、实时编译，JIT编译器，在计算中，即时编译（也是动态转换或运行时编译）是一种执行计算机代码的方法，涉及程序执行期间的 编译 - 运行 期间而不是在执行之前。大多数情况下，这包括源代码或更常见的字节码转换为机器代码，然后直接执行。实现JIT编译器的系统通常连续分析正在执行的代码，并识别代码的一部分，其中从编译或重新编译获得的加速比将超过编译该代码的开销。JIT编译是两种传统的机器代码转换方法的组合 - <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">Ahead-of-time compilation(提前编译)</a>和 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpretation(解释器)</a>,并结合了两者的优点和缺点。粗略地说，JIT编译结合了编译代码的速度和解释的灵活性，以及​​解释器的开销和编译的额外开销（而不仅仅是解释）。JIT编译是动态编译的一种形式，允许自适应优化，如动态重新编译和微体系结构特定的加速。因此，理论上，JIT编译可以比静态编译产生更快的执行速度。解释和JIT编译特别适用于动态编程语言，因为运行时系统可以处理后期绑定数据类型并实施安全保证。</p>
<blockquote>
<p>更多资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Just-in-time_compilation">Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html">IBM Developer</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.vm.80.doc/docs/jit_overview.html">IBM Knowledge Cente</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html">Josh Haberman</a></li>
</ul>
</blockquote>
</blockquote>
<h1 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h1><h2 id="java内存组成-堆-Heap-和-非堆-Non-heap-内存"><a href="#java内存组成-堆-Heap-和-非堆-Non-heap-内存" class="headerlink" title="java内存组成 : 堆(Heap) 和 非堆(Non-heap) 内存"></a>java内存组成 : 堆(Heap) 和 非堆(Non-heap) 内存</h2><p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。</p>
<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。<br>这些组成部分一些是线程私有的，其他的则是线程共享的。</p>
<p><strong>线程私有的</strong>：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的</strong>:</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存</li>
</ul>
<h2 id="JVM内存区域模型"><a href="#JVM内存区域模型" class="headerlink" title="JVM内存区域模型"></a>JVM内存区域模型</h2><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区(Method Area)也称”永久代” 、“Non-Heap(非堆)”，是被线程共享的区域。它用于存储虚拟机加载的类信息（包括类的名称、方法信息、字段信息）、常量、静态变量以及即时编译器编译后的代码等数据。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。</p>
<p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非只有Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>
<p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>
<p>《Java 中几种常量池的区分》： <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26222859/article/details/73135660">https://blog.csdn.net/qq_26222859/article/details/73135660</a></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>堆(Heap) 也叫做java堆、GC堆，是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象),几乎所有的对象实例以及数组都在这里分配内存</strong>。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<p><img src="/img/article/gcheap.jpeg" alt="gcheap"></p>
<p>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</p>
<p>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。</p>
<blockquote>
<p>新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。</p>
</blockquote>
<blockquote>
<p>老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p>
</blockquote>
<p>总结 </p>
<ol>
<li>存储的全部是对象，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。 </li>
<li>jvm只有一个堆区（heap）被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身。 </li>
<li>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。 </li>
<li>缺点是，由于要在运行时动态分配内存，存取速度较慢。</li>
</ol>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p>
<p>虚拟机栈(Java Virtual Machine Stacks)描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p>JVM栈只对栈帧进行存储，压栈和出栈操作。Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。</p>
<blockquote>
<p>栈帧：一个栈帧随着一个方法的调用开始而创建，这个方法调用完成而销毁。栈帧内存放者方法中的局部变量，操作数栈等数据。</p>
</blockquote>
<p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p>
<p>栈内存的大小可以有两种设置，固定值和根据线程需要动态增长。<br>在JVM栈这个数据区可能会发生抛出两种错误。 </p>
<ol>
<li>StackOverflowError 出现在栈内存设置成固定值的时候，当程序执行需要的栈内存超过设定的固定值会抛出这个错误。 </li>
<li>OutOfMemoryError 出现在栈内存设置成动态增长的时候，当JVM尝试申请的内存大小超过了其可用内存时会抛出这个错误</li>
</ol>
<p>总结 </p>
<ol>
<li>每个线程包含一个栈区,栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。对象都存放在堆区中。 </li>
<li>每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。 </li>
<li>栈分为3个部分：基本类型变量，执行环境上下文，操作指令区(存放操作指令). </li>
<li>在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。 </li>
<li>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>一个支持native方法调用的JVM实现，需要有这样一个数据区，就是本地方法栈，Java官方对于本地方法的定义为methods written in a language other than the Java programming language，就是使用非Java语言实现的方法，但是通常我们指的一般为C或者C++，因此这个栈也有着C栈这一称号。一个不支持本地方法执行的JVM没有必要实现这个数据区域。本地方法栈基本和JVM栈一样，其大小也是可以设置为固定值或者动态增加。</p>
<p>和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>在通用的计算机体系中，程序计数器用来记录当前正在执行的指令，在JVM中也是如此。程序计数器是线程私有，所以当一个新的线程创建时，程序计数器也会创建。由于Java是支持多线程，Java中的程序计数器用来记录当前线程中正在执行的指令。如果当前正在执行的方法是本地方法，那么此刻程序计数器的值为undefined。</p>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</p>
<p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>从上面的介绍中我们知道程序计数器主要有两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</p>
<p>JDK1.4中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</p>
<p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="JVM-内存总结"><a href="#JVM-内存总结" class="headerlink" title="JVM 内存总结"></a>JVM 内存总结</h2><ul>
<li>Java堆内存是操作系统分配给JVM的内存的一部分。</li>
<li>当我们创建对象时，它们存储在Java堆内存中。</li>
<li>为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。</li>
<li>你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。</li>
<li>你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。</li>
<li>你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。</li>
<li>Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。</li>
<li>当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。</li>
<li>请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。</li>
<li>Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。</li>
</ul>
<h1 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h1><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java 对象的创建过程。</p>
<ol>
<li>类加载检查 - 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>分配内存 - 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>
</ol>
<p><strong>内存分配的两种方式</strong>：</p>
<p><img src="/img/article/creationObject.jpeg" alt="memAllocation"></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>
<p><strong>内存分配并发问题</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<p>CAS+失败重试 - CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</p>
<p>TLAB - 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配</p>
<ol start="3">
<li><p>初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p>设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
</li>
<li><p>执行 init 方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/02/01/JavaBasicKnowledga/" data-id="ckvgcipj90009plqh0bskaxkk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaDesignPatterns-Structural" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/15/JavaDesignPatterns-Structural/" class="article-date">
  <time datetime="2019-01-15T02:52:18.000Z" itemprop="datePublished">2019-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Software-Design-Patterns/">Software Design Patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/15/JavaDesignPatterns-Structural/">Java 设计模式 - Structural</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h1><p>在软件工程中，结构设计模式是借由一以贯之的方式来了解元件间的关系，以简化设计。</p>
<p>结构模式的示例包括：</p>
<ul>
<li>Adapter pattern (适配器模式) -将一个物件的界面’转接’成当事人预期的样子<ul>
<li>Adapter pipeline (适配器管道) : 同时使用多个类别的界面的适配器</li>
<li>Retroft Interface Pattern (改造接口模式) : 因除错目的而使用多个适配器</li>
</ul>
</li>
<li>Aggregate pattern (聚集模式) - 一种组合模式的版本，包含用于聚集子成员的成员函式</li>
<li>Bridge pattern (桥接模式) - 将抽象与其实现解耦，这样两者就可以独立地变化<ul>
<li>Tombstone (墓碑模式) : 一种中介的查询物件，包含物件的实际位址</li>
</ul>
</li>
<li>Composite pattern (组合模式) - 对象的树结构，其中每个对象都有相同的接口</li>
<li>Decorator pattern (装饰模式) - 对一个执行的类别，若使用继承方式加上新功能可能会新类别的数量呈指数型地增加，可使用此模式来解决</li>
<li>Extensibility pattern (扩展模式) - 亦即框架，将复杂的程式码隐藏在简单的界面后</li>
<li>Facade pattern (外观模式) - 为现有接口创建简化的接口，以简化对常见任务的使用</li>
<li>Flyweight pattern (享元模式) - 大量对象共享一个公共属性对象以节省空间</li>
<li>Marker pattern (标记模式)- 将元数据与类关联的空接口。</li>
<li>Pipes and filter (导线及过滤器模式) - 一个进程链，其中每个进程的输出是下一个进程的输入</li>
<li>Opaque pointer (不透明指针) - 指向未声明或私有类型的指针，以隐藏其实现细节</li>
<li>Proxy pattern (代理模式) - 类的作用是作为另一个对象的接口</li>
</ul>
<h2 id="External-Polymorphism"><a href="#External-Polymorphism" class="headerlink" title="External Polymorphism"></a>External Polymorphism</h2><p>External Polymorphism (外部多态性)，用于实现多态性的任何机制，该多态性在显示多态行为的对象的定义之外。基于类型代码的switch语句可能是最简单的这种机制。<a target="_blank" rel="noopener" href="http://wiki.c2.com/?ExternalPolymorphism">more</a></p>
<h1 id="Adapter-Pattern-in-Java"><a href="#Adapter-Pattern-in-Java" class="headerlink" title="Adapter Pattern in Java"></a>Adapter Pattern in Java</h1><h2 id="What-is-Adapter-Pattern"><a href="#What-is-Adapter-Pattern" class="headerlink" title="What is Adapter Pattern?"></a>What is Adapter Pattern?</h2><p>在软件工程中，适配器模式是一种软件设计模式(也称为包装器，与装饰器模式共享的另一种命名)，它允许将现有类的接口用作另一个接口。它通常用于使现有的类在不修改源代码的情况下与其他类一起工作。</p>
<p>适配器设计模式是23种著名的GoF设计模式之一，这些设计模式描述了如何解决重复出现的设计问题，从而设计灵活且可重用的面向对象软件，即更容易实现、更改、测试和重用的对象。</p>
<p>适配器设计模式解决了以下问题:</p>
<ul>
<li>如何重用不具有客户端所需接口的类？</li>
<li>具有不兼容接口的类如何协同工作？</li>
<li>如何为类提供替代接口？</li>
</ul>
<p>通常一个(已经存在的)类不能被重用，仅仅因为它的接口不符合客户端需要的接口。</p>
<p>适配器设计模式描述了如何解决这些问题:</p>
<ul>
<li>定义一个单独的适配器类，将类(adaptee)的(不兼容的)接口转换为另一个客户端所需的接口(目标)。</li>
<li>通过适配器处理(重用)不具有所需接口的类。</li>
</ul>
<p>这种模式的关键思想是通过一个单独的适配器来适应（已经存在的）类的接口而不改变它。</p>
<p>客户端不知道它们是直接使用目标类，还是通过具有没有目标接口的类的适配器使用。</p>
<p>适配器允许两个不兼容的接口一起工作。这是适配器的真实定义。接口可能不兼容，但内部功能应该满足需求。适配器设计模式允许不兼容的类通过将一个类的接口转换为客户机期望的接口一起工作。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Adapter_pattern">more</a></p>
<h3 id="Adapter-pipeline"><a href="#Adapter-pipeline" class="headerlink" title="Adapter pipeline"></a>Adapter pipeline</h3><p>从结构上讲，适配器模式是通过(一个小的转换)委托给另一个类来实现接口的类。但是，这个类结构不仅适用于将两个稍微不兼容的接口连接在一起。</p>
<p>适配器管道有时是分解计算的一种很好的方法。例如，它是编译器的合理设计。</p>
<p>这种模式有利于可测试性。在单元测试中，可以单独测试管道的每个部分。在调试集成问题时，可以通过为边界的接口编写修饰符来监听任何边界。如果某些接口是相同的，则可能允许以不同的顺序排列管道的各个部分。</p>
<h3 id="Retoft-Interface-Pattern"><a href="#Retoft-Interface-Pattern" class="headerlink" title="Retoft Interface Pattern"></a>Retoft Interface Pattern</h3><p>如果使用的是Java。如果有两个类不是你的的(因此不能修改它们)。你希望编写一些可以交替使用它们的客户端代码。如何指定它们的类型?你不能指定类;不止一个。不能指定它们的公共超类;它太通用了(可能是java.lang.Object)。不能指定它们的公共接口;要么没有，要么太笼统了。</p>
<p>因此，应用适配器模式的公共专门化。实现客户端需要的接口。对于您尝试使用的每个第三方类，创建一个适配器类。适配器应该实现接口;编写每个接口消息的代码，以便将其委托给第三方类中的适当消息。客户端应该引用接口。当客户端需要使用第三方类的实例时，用对应适配器类的实例包装它，并通过接口使用该实例。适配器允许客户端通过同构接口交换使用异构类，而无需修改原始类。</p>
<p>但，这是一种模式？，还是某种运行时类型更改模式语言中的适配器?</p>
<p>它是GangOfFour设计模式书中AdapterPattern的变体。</p>
<p>在这本书中假设您控制了感兴趣的类之一，并试图使某些不兼容的类保持一致。以上的思想概括了AdapterPattern的思想。</p>
<h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><ul>
<li>有助于实现可重用性和灵活性。</li>
<li>由于必须使用不同的接口，所以Client类并不复杂，并且可以使用多态性在适配器的不同实现之间进行交换。</li>
</ul>
<p>Disadvantages</p>
<ul>
<li>所有请求都被转发，因此开销略有增加。</li>
<li>有时需要沿着适配器链进行许多调整才能达到所需的类型。</li>
</ul>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>适配器模式很容易理解，因为现实世界中到处都是适配器。例如，考虑一个USB到以太网适配器。当我们在一端有以太网接口，另一端有USB接口时，我们需要这个。因为它们彼此不相容。我们使用一个适配器将一个转换为另一个。这个示例非常类似于面向对象适配器。在设计中，当我们有一个类(客户机)期望某种类型的对象，并且我们有一个对象(Adaptee)提供相同的特性，但公开不同的接口时，就会使用适配器。</p>
<p>使用适配器模式：</p>
<ul>
<li>客户端通过使用目标接口调用适配器上的方法向适配器发出请求</li>
<li>适配器使用adaptee接口在adaptee上转换该请求。</li>
<li>客户端接收调用的结果，并且不知道适配器的存在。</li>
</ul>
<p>适配器设计模式的另一个很好的现实例子是移动充电器。移动电池需要3伏的电压来充电，但普通插座可以产生120V(美国)或240V(印度)。因此，移动充电器作为移动充电插座和壁挂式插座之间的适配器。</p>
<p> 首先我们将有两类-Volt(测量伏特)和Socket(产生恒定电压120V)。<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> package com.journaldev.design.adapter;</span><br><span class="line"></span><br><span class="line">public class Volt &#123;</span><br><span class="line"></span><br><span class="line">	private int volts;</span><br><span class="line">	</span><br><span class="line">	public Volt(int v)&#123;</span><br><span class="line">		this.volts=v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getVolts() &#123;</span><br><span class="line">		return volts;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setVolts(int volts) &#123;</span><br><span class="line">		this.volts = volts;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.adapter;</span><br><span class="line"></span><br><span class="line">public class Socket &#123;</span><br><span class="line"></span><br><span class="line">	public Volt getVolt()&#123;</span><br><span class="line">		return new Volt(120);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们想建立一个适配器，可以产生3伏，12伏和默认120伏。首先，我们将使用这些方法创建适配器接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.adapter;</span><br><span class="line"></span><br><span class="line">public interface SocketAdapter &#123;</span><br><span class="line"></span><br><span class="line">	public Volt get120Volt();</span><br><span class="line">		</span><br><span class="line">	public Volt get12Volt();</span><br><span class="line">	</span><br><span class="line">	public Volt get3Volt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Two-Way-Adapter-Pattern"><a href="#Two-Way-Adapter-Pattern" class="headerlink" title="Two Way Adapter Pattern"></a>Two Way Adapter Pattern</h3><p>在实现适配器模式时，有两种方法——类适配器和对象适配器——但是这两种方法产生相同的结果。</p>
<ul>
<li>Class Adapter (类适配器) —— 使用 java继承 方式扩展源接口，在示例中是Socket类。</li>
<li>Object Adapter (对象适配器) —— 使用 Java组合，适配器包含源对象。</li>
</ul>
<h4 id="Class-Adapter"><a href="#Class-Adapter" class="headerlink" title="Class Adapter"></a>Class Adapter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.adapter;</span><br><span class="line"></span><br><span class="line">//Using inheritance for adapter pattern</span><br><span class="line">public class SocketClassAdapterImpl extends Socket implements SocketAdapter&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Volt get120Volt() &#123;</span><br><span class="line">		return getVolt();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Volt get12Volt() &#123;</span><br><span class="line">		Volt v= getVolt();</span><br><span class="line">		return convertVolt(v,10);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Volt get3Volt() &#123;</span><br><span class="line">		Volt v= getVolt();</span><br><span class="line">		return convertVolt(v,40);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private Volt convertVolt(Volt v, int i) &#123;</span><br><span class="line">		return new Volt(v.getVolts()/i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-Adapter"><a href="#Object-Adapter" class="headerlink" title="Object Adapter"></a>Object Adapter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.adapter;</span><br><span class="line"></span><br><span class="line">public class SocketObjectAdapterImpl implements SocketAdapter&#123;</span><br><span class="line"></span><br><span class="line">	//Using Composition for adapter pattern</span><br><span class="line">	private Socket sock = new Socket();</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public Volt get120Volt() &#123;</span><br><span class="line">		return sock.getVolt();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Volt get12Volt() &#123;</span><br><span class="line">		Volt v= sock.getVolt();</span><br><span class="line">		return convertVolt(v,10);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Volt get3Volt() &#123;</span><br><span class="line">		Volt v= sock.getVolt();</span><br><span class="line">		return convertVolt(v,40);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private Volt convertVolt(Volt v, int i) &#123;</span><br><span class="line">		return new Volt(v.getVolts()/i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这两个适配器实现几乎是相同的，它们实现SocketAdapter接口。适配器接口也可以是一个抽象类。</p>
<p>实际调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.test;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.adapter.SocketAdapter;</span><br><span class="line">import com.journaldev.design.adapter.SocketClassAdapterImpl;</span><br><span class="line">import com.journaldev.design.adapter.SocketObjectAdapterImpl;</span><br><span class="line">import com.journaldev.design.adapter.Volt;</span><br><span class="line"></span><br><span class="line">public class AdapterPatternTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		testClassAdapter();</span><br><span class="line">		testObjectAdapter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void testObjectAdapter() &#123;</span><br><span class="line">		SocketAdapter sockAdapter = new SocketObjectAdapterImpl();</span><br><span class="line">		Volt v3 = getVolt(sockAdapter,3);</span><br><span class="line">		Volt v12 = getVolt(sockAdapter,12);</span><br><span class="line">		Volt v120 = getVolt(sockAdapter,120);</span><br><span class="line">		System.out.println(&quot;v3 volts using Object Adapter=&quot;+v3.getVolts());</span><br><span class="line">		System.out.println(&quot;v12 volts using Object Adapter=&quot;+v12.getVolts());</span><br><span class="line">		System.out.println(&quot;v120 volts using Object Adapter=&quot;+v120.getVolts());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void testClassAdapter() &#123;</span><br><span class="line">		SocketAdapter sockAdapter = new SocketClassAdapterImpl();</span><br><span class="line">		Volt v3 = getVolt(sockAdapter,3);</span><br><span class="line">		Volt v12 = getVolt(sockAdapter,12);</span><br><span class="line">		Volt v120 = getVolt(sockAdapter,120);</span><br><span class="line">		System.out.println(&quot;v3 volts using Class Adapter=&quot;+v3.getVolts());</span><br><span class="line">		System.out.println(&quot;v12 volts using Class Adapter=&quot;+v12.getVolts());</span><br><span class="line">		System.out.println(&quot;v120 volts using Class Adapter=&quot;+v120.getVolts());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static Volt getVolt(SocketAdapter sockAdapter, int i) &#123;</span><br><span class="line">		switch (i)&#123;</span><br><span class="line">		case 3: return sockAdapter.get3Volt();</span><br><span class="line">		case 12: return sockAdapter.get12Volt();</span><br><span class="line">		case 120: return sockAdapter.get120Volt();</span><br><span class="line">		default: return sockAdapter.get120Volt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Adapter-Design-Pattern-Example-in-JDK"><a href="#Adapter-Design-Pattern-Example-in-JDK" class="headerlink" title="Adapter Design Pattern Example in JDK"></a>Adapter Design Pattern Example in JDK</h3><ul>
<li>java.util.Arrays#asList()</li>
<li>java.io.InputStreamReader(InputStream) (returns a Reader)</li>
<li>java.io.OutputStreamWriter(OutputStream) (returns a Writer)</li>
</ul>
<h1 id="Aggregate-Pattern-in-Java"><a href="#Aggregate-Pattern-in-Java" class="headerlink" title="Aggregate Pattern in Java"></a>Aggregate Pattern in Java</h1><h2 id="What-is-Aggregate-Pattern"><a href="#What-is-Aggregate-Pattern" class="headerlink" title="What is Aggregate Pattern?"></a>What is Aggregate Pattern?</h2><p>聚合模式可以引用统计或计算机编程中的概念。这两种用法都将大小写看作是由更小、更简单的部分组成的。</p>
<p>聚合模式是一个重要的统计概念，在许多领域中，它依赖于统计数据来预测大型组的行为，其基础是子组以某种方式一致行为的趋势。它在社会学、经济学、心理学和犯罪学中尤其有用。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Aggregate_pattern">more</a></p>
<p>聚合模式在JAVA中使用：</p>
<ul>
<li>当没有is-a关系时，通过聚合也可以最好地实现代码重用。</li>
<li>只有在关系为a的关系在涉及的对象的整个生命周期中都得到维护时，才应该使用继承;否则，聚合是最好的选择。</li>
</ul>
<h2 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h2><p>如果类有实体引用，则称为聚合。聚合表示HAS-A关系。</p>
<p>Employee对象包含许多信息，如id、name、emailId等。它还包含一个名为address的对象，该对象包含它自己的信息，如城市、州、国家、邮政编码等，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Employee&#123;  </span><br><span class="line">	int id;  </span><br><span class="line">	String name;  </span><br><span class="line">	Address address;//Address is a class  </span><br><span class="line">	...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在这种情况下，Employee有一个实体引用地址,他们之间的关系就是Employee有一个Address。</p>
<p>Employee有一个Address对象，Address对象包含它自己的信息，比如city、state、country等等。在这种情况下，关系就是Employee有一个Address。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;  </span><br><span class="line">	String city,state,country;  </span><br><span class="line">	</span><br><span class="line">	public Address(String city, String state, String country) &#123;  </span><br><span class="line">		this.city = city;  </span><br><span class="line">		this.state = state;  </span><br><span class="line">		this.country = country;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Emp &#123;  </span><br><span class="line">	int id;  </span><br><span class="line">	String name;  </span><br><span class="line">	Address address;  </span><br><span class="line">  </span><br><span class="line">	public Emp(int id, String name,Address address) &#123;  </span><br><span class="line">		this.id = id;  </span><br><span class="line">		this.name = name;  </span><br><span class="line">		this.address=address;  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	void display()&#123;  </span><br><span class="line">		System.out.println(id+&quot; &quot;+name);  </span><br><span class="line">		System.out.println(address.city+&quot; &quot;+address.state+&quot; &quot;+address.country);  </span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;  </span><br><span class="line">		Address address1=new Address(&quot;gzb&quot;,&quot;UP&quot;,&quot;india&quot;);  </span><br><span class="line">		Address address2=new Address(&quot;gno&quot;,&quot;UP&quot;,&quot;india&quot;);  </span><br><span class="line">		</span><br><span class="line">		Emp e=new Emp(111,&quot;varun&quot;,address1);  </span><br><span class="line">		Emp e2=new Emp(112,&quot;arun&quot;,address2);  </span><br><span class="line">			</span><br><span class="line">		e.display();  </span><br><span class="line">		e2.display();  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="Bridge-Pattern-in-Java"><a href="#Bridge-Pattern-in-Java" class="headerlink" title="Bridge Pattern in Java"></a>Bridge Pattern in Java</h1><h2 id="What-is-Brige-Pattern"><a href="#What-is-Brige-Pattern" class="headerlink" title="What is Brige Pattern?"></a>What is Brige Pattern?</h2><p>桥接模式是软件工程中使用的一种设计模式，其目的是“将抽象与其实现解耦，以便两者可以独立地变化”，由“Gang of Four”引入。桥接使用封装、聚合，并可以使用继承将职责分离到不同的类中。</p>
<p>当一个类经常变化时,面向对象编程的特性变得非常有用,因为对于程序的代码的更改可以很容易地对程序的先验知识进行。当课堂和它经常发生的变化时,桥的模式是有用的。类本身可以被认为是抽象,以及类可以作为实现的内容。桥梁模式也可以被认为是两层抽象。</p>
<p>桥接模式经常与适配器模式混淆，通常使用对象适配器模式来实现。</p>
<p>变体:通过将实现延迟到使用抽象的点，可以进一步解耦实现。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bridge_pattern">more</a></p>
<h2 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h2><p>桥接模式的概念:将抽象与其实现分离，以便两者可以独立变化</p>
<p>桥接设计模式的实现遵循组合优于继承的思想</p>
<p>如果我们以实例来研究桥接设计模式，就会很容易理解。假设我们在接口和实现中都有一个接口层次结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.bridge;</span><br><span class="line"></span><br><span class="line">public interface Color &#123;</span><br><span class="line"></span><br><span class="line">	public void applyColor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.bridge;</span><br><span class="line"></span><br><span class="line">public abstract class Shape &#123;</span><br><span class="line">	//Composition - implementor</span><br><span class="line">	protected Color color;</span><br><span class="line">	</span><br><span class="line">	//constructor with implementor as input argument</span><br><span class="line">	public Shape(Color c)&#123;</span><br><span class="line">		this.color=c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	abstract public void applyColor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有如下所示的三角形和五边形实现类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.bridge;</span><br><span class="line"></span><br><span class="line">public class Triangle extends Shape&#123;</span><br><span class="line"></span><br><span class="line">	public Triangle(Color c) &#123;</span><br><span class="line">		super(c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void applyColor() &#123;</span><br><span class="line">		System.out.print(&quot;Triangle filled with color &quot;);</span><br><span class="line">		color.applyColor();</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.bridge;</span><br><span class="line"></span><br><span class="line">public class Pentagon extends Shape&#123;</span><br><span class="line"></span><br><span class="line">	public Pentagon(Color c) &#123;</span><br><span class="line">		super(c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void applyColor() &#123;</span><br><span class="line">		System.out.print(&quot;Pentagon filled with color &quot;);</span><br><span class="line">		color.applyColor();</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红颜色和绿颜色的实现类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.bridge;</span><br><span class="line"></span><br><span class="line">public class RedColor implements Color&#123;</span><br><span class="line"></span><br><span class="line">	public void applyColor()&#123;</span><br><span class="line">		System.out.println(&quot;red.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.bridge;</span><br><span class="line"></span><br><span class="line">public class GreenColor implements Color&#123;</span><br><span class="line"></span><br><span class="line">	public void applyColor()&#123;</span><br><span class="line">		System.out.println(&quot;green.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序测试桥接模式实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.test;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.bridge.GreenColor;</span><br><span class="line">import com.journaldev.design.bridge.Pentagon;</span><br><span class="line">import com.journaldev.design.bridge.RedColor;</span><br><span class="line">import com.journaldev.design.bridge.Shape;</span><br><span class="line">import com.journaldev.design.bridge.Triangle;</span><br><span class="line"></span><br><span class="line">public class BridgePatternTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Shape tri = new Triangle(new RedColor());</span><br><span class="line">		tri.applyColor();</span><br><span class="line">		</span><br><span class="line">		Shape pent = new Pentagon(new GreenColor());</span><br><span class="line">		pent.applyColor();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当抽象和实现各自具有不同的层次结构，并且我们希望向客户机应用程序隐藏实现时，可以使用桥接设计模式。</p>
<h1 id="Composite-Pattern-in-Java"><a href="#Composite-Pattern-in-Java" class="headerlink" title="Composite Pattern in Java"></a>Composite Pattern in Java</h1><h2 id="What-is-Composite-Pattern"><a href="#What-is-Composite-Pattern" class="headerlink" title="What is Composite Pattern?"></a>What is Composite Pattern?</h2><p>在软件工程中，组合模式是一种分区设计模式。复合模式描述一组对象，这些对象以相同的方式作为同一类型对象的单个实例进行处理。组合的目的是将对象“组合”到树结构中，以表示部分-整体层次结构。实现复合模式可以让客户端统一地处理单个对象和组合。</p>
<p>组合设计模式是23种著名的GoF设计模式之一，这些设计模式描述如何解决重复出现的设计问题，从而设计灵活且可重用的面向对象软件，即更容易实现、更改、测试和重用的对象。</p>
<p>组合设计模式可以解决哪些问题?</p>
<ul>
<li>应该表示部分-整体层次结构，以便客户端能够统一地对待部分和整体对象。</li>
<li>部分-整体层次结构应该表示为树结构。</li>
</ul>
<p>当定义部分对象和作为部分对象容器的整个对象时，客户端必须分别对待它们，这使得客户端代码变得复杂。</p>
<p>组合设计模式描述了什么解决方案?</p>
<ul>
<li>为部分 (Leaf)对象和整体 (Composite)对象定义统一的组件接口。</li>
<li>单个 Leaf 对象直接实现组件接口，Composite 对象将请求转发给其子组件。</li>
</ul>
<p>这使得客户端能够通过组件接口统一地处理 Leaf 和 Composite 对象: Leaf 对象直接执行请求，Composite 对象递归地将请求转发到树结构的子组件。这使得客户端类更容易实现、更改、测试和重用。</p>
<p>在处理树状结构的数据时，程序员经常不得不区分叶节点和分支节点。这使得代码更复杂，因此更容易出错。解决方案是一个允许统一处理复杂和原始对象的接口。在面向对象编程中，组合是设计为一个或多个相似对象的组合的对象，这些对象都具有相似的功能。这被称为对象之间的“has-a”关系。关键的概念是，您可以像操作一组对象一样操作对象的单个实例。</p>
<h2 id="Usage-3"><a href="#Usage-3" class="headerlink" title="Usage"></a>Usage</h2><p>当我们必须表示部分-整体层次结构时，应当使用组合设计模式。当我们需要以必须以相同方式处理结构中的对象的方式创建结构时，我们可以应用组合设计模式。</p>
<p>让我们通过一个真实的例子来理解它——一个图是一个由物体组成的结构，比如圆、线、三角形等。这里的图是由不同的部分组成，它们都有相同的操作。</p>
<p>组合模式由以下对象组成：</p>
<ul>
<li>Base Component (基组件) - 基组件是组合中所有对象的接口，客户端程序使用基组件来处理组合中的对象。它可以是一个接口，也可以是一个抽象类，其中包含所有对象共有的一些方法。</li>
<li>Leaf (叶) - 定义组合中的元素的行为。它是组合和实现基本组件的构建块。它没有对其他组件的引用。</li>
<li>Composite (组合) - 它由叶元素组成，并在基组件中实现操作。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/01/15/JavaDesignPatterns-Structural/" data-id="ckvgcipjb000bplqh19dy2etf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/design-patterns/" rel="tag">design patterns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/structural/" rel="tag">structural</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SoftwareDesignPatterns" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/SoftwareDesignPatterns/" class="article-date">
  <time datetime="2019-01-09T02:45:03.000Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Software-Design-Patterns/">Software Design Patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/09/SoftwareDesignPatterns/">软件设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-Design-Pattern"><a href="#What-is-Design-Pattern" class="headerlink" title="What is Design Pattern?"></a>What is Design Pattern?</h1><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p>
<p>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p>
<p>并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p>
<p>随着软件开发社群对设计模式的兴趣日益增长，已经出版了一些相关的专著，定期召开相应的研讨会，而且沃德·坎宁安（Ward Cunningham）为此发明了WikiWiki用来交流设计模式的经验。<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_design_pattern">more</a></p>
<h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><p>设计模式最初是Christopher Alexander(1977/78)提出的一个架构概念。1987年，Kent Beck和Ward Cunningham开始尝试将模式应用于编程——特别是模式语言——并在那年的OOPSLA会议上展示了他们的成果。在接下来的几年里，Beck, Cunningham等人对这项工作进行了跟进。</p>
<p>1994年，所谓的“四人帮”(Gamma et al.)出版了《设计模式：可复用面向对象软件的基础》(Design Patterns: Elements of Reusable Object-Oriented Software)一书，该书经常缩写为“GoF”，此后，设计模式在计算机科学中变得流行起来。同年，举行了第一次编程模式语言会议，并于次年建立了 Portland Pattern Repository ，用于记录设计模式。这个术语的范围仍有争议。值得注意的设计模式类书籍包括:</p>
<ul>
<li>Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1995). <em>Design Patterns: Elements of Reusable Object-Oriented Software(设计模式：可复用面向对象软件的基础)</em>. ISBN 0-201-63361-2.</li>
<li>Brinch Hansen, Per (1995). <em>Studies in Computational Science: Parallel Programming Paradigms</em>. ISBN 0-13-439324-4.</li>
<li>Buschmann, Frank; Meunier, Regine; Rohnert, Hans; Sommerlad, Peter (1996). <em>Pattern-Oriented Software Architecture, Volume 1: A System of Patterns(面向模式的软件体系结构(卷1))</em>. ISBN 0-471-95869-7.</li>
<li>Beck, Kent (1997). <em>Smalltalk Best Practice Patterns</em>. ISBN 978-0134769042.</li>
<li>Schmidt, Douglas C.; Stal, Michael; Rohnert, Hans; Buschmann, Frank (2000). <em>Pattern-Oriented Software Architecture, Volume 2: Patterns for Concurrent and Networked Objects(面向模式的软件体系结构(卷2))</em>. ISBN 0-471-60695-2.</li>
<li>Fowler, Martin (2002). <em>Patterns of Enterprise Application Architecture(企业应用架构模式)</em>. ISBN 978-0-321-12742-6.</li>
<li>Hohpe, Gregor; Woolf, Bobby (2003). <em>Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions(企业集成模式)</em>. ISBN 0-321-20068-3.</li>
<li>Freeman, Eric T; Robson, Elisabeth; Bates, Bert; Sierra, Kathy (2004). <em>Head First Design Patterns(深入浅出设计模式)</em>. ISBN 0-596-00712-4.</li>
</ul>
<h1 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h1><p>设计模式最初被分为三类:创建模式、结构模式和行为模式，并使用委托、聚合和协商的概念进行描述。有关面向对象设计的进一步背景，请参见耦合和内聚、继承、接口和多态性。另一个分类还引入了架构设计模式的概念，该概念可以应用于软件的架构级别，例如模型-视图-控制器模式(Model–view–controller，MVC)。</p>
<blockquote>
<p>耦合性（英语：Coupling，dependency，或称耦合力或耦合度）是一种软件度量，是指一程序中，模块及模块之间信息或参数依赖的程度。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">more</a></p>
</blockquote>
<blockquote>
<p>内聚性（Cohesion）也称为内聚力，是一软件度量，是指机能相关的程序组合成一模块的程度，或是各机能凝聚的状态或程度。是结构化分析的重要概念之一。量测内聚性的方式很多，有些方法是由分析源代码，得到非量化的结果，有些方法则是检查源代码的文本特征，以得到内聚性的量化分数。内聚性是属于顺序式的量测量，一般会以“高内聚性”或“低内聚性”来表示。一般会希望程序的模块有高内聚性，因为高内聚性一般和许多理想的软件特性有关，包括鲁棒性、可靠度、可复用性及易懂性（understandability）等特性，而低内聚性一般也代表不易维护、不易测试、不易复用以及难以理解。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)">more</a></p>
</blockquote>
<blockquote>
<blockquote>
<p>耦合性和内聚性是一个相对的概念。一般而言高内聚性代表低耦合性，反之亦然。内聚性是由赖瑞·康斯坦丁所提出，是以实务上可减少维护及修改的“良好”软件的特性为基础。</p>
</blockquote>
</blockquote>
<blockquote>
<p>继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类”。继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类的行为在编译期就已经决定，无法在运行期扩展。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">more</a></p>
</blockquote>
<blockquote>
<p>接口（英语：interface），台湾译为介面，中介之面的意思；大陆译作界面，也译作接口，但“port”大陆也是译作接口。接口泛指实体把自己提供给外界的一种抽象化物（可以为另一实体），用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他实体与其交互的方式，就如面向对象编程提供的多重抽象化。接口可能也提供某种意义上的在讲不同语言的实体之间的翻译，诸如人类与计算机之间。因为接口是一种间接手段，所以相比起直接沟通，会引致些额外负担。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interface_(computing)">more</a></p>
</blockquote>
<blockquote>
<p>多态（英语：polymorphism）指为不同数据类型的实体提供统一的接口。 多态类型（英语：polymorphic type）可以将自身所支持的操作套用到其它类型的值上。计算机程序运行时，相同的消息可能会送给多个不同的类别之对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作。多态也可定义为“一种将不同的特殊行为和单个泛化记号相关联的能力”。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">more</a></p>
</blockquote>
<blockquote>
<p>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。MVC模式最早由Trygve Reenskaug在1978年提出，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。专业人员可以通过自身的专长分组：</p>
<ul>
<li>控制器（Controller）- 负责转发请求，对请求进行处理。</li>
<li>视图（View） - 界面设计人员进行图形界面设计。</li>
<li>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">more</a></li>
</ul>
</blockquote>
<h3 id="Creational-patterns-创建模式"><a href="#Creational-patterns-创建模式" class="headerlink" title="Creational patterns(创建模式)"></a>Creational patterns(创建模式)</h3><table>
<thead>
<tr>
<th>Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td>Abstract Factory<br/>抽象工厂</td>
<td align="left">Provide an interface for creating families of related or dependent objects without specifying their concrete classes.<br/>为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。</td>
</tr>
<tr>
<td>Builder<br/>生成器</td>
<td align="left">Separate the construction of a complex object from its representation, allowing the same construction process to create various representations.<br/>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td>
</tr>
<tr>
<td>Dependency Injection<br/>依赖注入</td>
<td align="left">A class accepts the objects it requires from an injector instead of creating the objects directly.<br/> 类从注入器接受它需要的对象，而不是直接创建对象。</td>
</tr>
<tr>
<td>Factory Method<br/>工厂方法</td>
<td align="left">Define an interface for creating a single object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.<br/>定义用于创建单个对象的接口，但让子类决定实例化哪个类。 工厂方法把一个类的实例化下放到子类。</td>
</tr>
<tr>
<td>Lazy initialization<br/>延迟初始化</td>
<td align="left">Tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed. This pattern appears in the GoF catalog as “virtual proxy”, an implementation strategy for the Proxy pattern.<br/>将对象的创建、值的计算或其他一些开销很大的过程延迟到第一次需要它的时候。这种模式出现在GoF目录中,作为“虚拟代理”,是代理模式的实现策略。</td>
</tr>
<tr>
<td>Multiton<br/>多例</td>
<td align="left">Ensure a class has only named instances, and provide a global point of access to them.<br/>确保一个类只有命名的实例，并提供对这些实例的全局访问。</td>
</tr>
<tr>
<td>Object pool<br/>对象池</td>
<td align="left">Avoid expensive acquisition and release of resources by recycling objects that are no longer in use. Can be considered a generalisation of connection pool and thread pool patterns.<br/>通过回收不再使用的对象，避免昂贵的资源获取和释放。可以认为是连接池和线程池模式的一般化。</td>
</tr>
<tr>
<td>Prototype<br/>原型</td>
<td align="left">Specify the kinds of objects to create using a prototypical instance, and create new objects from the ‘skeleton’ of an existing object, thus boosting performance and keeping memory footprints to a minimum.<br/>指定使用原型实例创建的对象类型，并从现有对象的“骨架”创建新对象，从而提高性能并将内存占用降到最低。</td>
</tr>
<tr>
<td>Resource acquisition is initialization<br/>资源获取为初始化</td>
<td align="left">Ensure that resources are properly released by tying them to the lifespan of suitable objects.<br/> 确保通过将资源绑定到合适对象的生命周期来正确释放资源。</td>
</tr>
<tr>
<td>Singleton<br/>单例</td>
<td align="left">Ensure a class has only one instance, and provide a global point of access to it.确保一个类只有一个实例，并提供对这些实例的全局访问。</td>
</tr>
</tbody></table>
<h3 id="Structural-patterns-结构模式"><a href="#Structural-patterns-结构模式" class="headerlink" title="Structural patterns(结构模式)"></a>Structural patterns(结构模式)</h3><table>
<thead>
<tr>
<th>Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td>Adapter, Wrapper or Translator<br/>适配器，包装器或转换器</td>
<td align="left">Convert the interface of a class into another interface clients expect. An adapter lets classes work together that could not otherwise because of incompatible interfaces. The enterprise integration pattern equivalent is the translator.<br/>将类的接口转换为客户期望的另一个接口。适配器允许类一起工作，否则由于不兼容的接口。企业集成模式等同于翻译。</td>
</tr>
<tr>
<td>Bridge<br/>桥接</td>
<td align="left">Decouple an abstraction from its implementation allowing the two to vary independently.<br/>将抽象与其实现分离，允许两者独立变化。</td>
</tr>
<tr>
<td>Composite<br/>组合</td>
<td align="left">Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.<br/>将对象组合成树结构以表示部分整体层次结构。 Composite允许客户端统一处理单个对象和对象组合。</td>
</tr>
<tr>
<td>Decorator<br/>修饰</td>
<td align="left">Attach additional responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative to subclassing for extending functionality.<br/>动态地将额外的职责附加到保持相同接口的对象上。装饰器为扩展功能提供了子类化的灵活选择。</td>
</tr>
<tr>
<td>Extension object<br/>拓展对象</td>
<td align="left">Adding functionality to a hierarchy without changing the hierarchy.<br/>在不更改层次结构的情况下向层次结构添加功能。</td>
</tr>
<tr>
<td>Facade<br/>外观</td>
<td align="left">Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.<br/>为子系统中的一组接口提供统一的接口。Facade定义了一个更高级的接口，使子系统更容易使用。</td>
</tr>
<tr>
<td>Flyweight<br/>享元</td>
<td align="left">Use sharing to support large numbers of similar objects efficiently.<br/>通过共享以便有效的支持大量小颗粒对象。</td>
</tr>
<tr>
<td>Front controller<br/>前控制器</td>
<td align="left">The pattern relates to the design of Web applications. It provides a centralized entry point for handling requests.<br/>该模式与Web应用程序的设计有关。它为处理请求提供了一个集中入口点。</td>
</tr>
<tr>
<td>Marker<br/>标记</td>
<td align="left">Empty interface to associate metadata with a class.<br/>空接口，用于将元数据与类关联。</td>
</tr>
<tr>
<td>Module<br/>模块</td>
<td align="left">Group several related elements, such as classes, singletons, methods, globally used, into a single conceptual entity.<br/>将多个相关元素(如类、单例、全局使用的方法)分组到单个概念实体中。</td>
</tr>
<tr>
<td>Proxy<br/>代理</td>
<td align="left">Provide a surrogate or placeholder for another object to control access to it.<br/>为另一个对象提供代理或占位符来控制对它的访问。</td>
</tr>
<tr>
<td>Twin<br/>孪生</td>
<td align="left">Twin allows modeling of multiple inheritance in programming languages that do not support this feature.<br/>Twin标准允许在不支持此特性的编程语言中对多重继承进行建模。</td>
</tr>
</tbody></table>
<h3 id="Behavioral-patterns-行为模式"><a href="#Behavioral-patterns-行为模式" class="headerlink" title="Behavioral patterns(行为模式)"></a>Behavioral patterns(行为模式)</h3><table>
<thead>
<tr>
<th>Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td>Blackboard<br/>黑板</td>
<td align="left">Artificial intelligence pattern for combining disparate sources of data (see <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blackboard_system">blackboard system</a>)<br/>用于组合不同数据源的人工智能模式(参见黑板系统)</td>
</tr>
<tr>
<td>Chain of responsibility<br/>责任链</td>
<td align="left">Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.<br/>通过给多个对象处理请求的机会，避免将请求的发送方与其接收方耦合。将接收对象链接起来，并沿着链传递请求，直到对象处理它。</td>
</tr>
<tr>
<td>Command<br/>命令</td>
<td align="left">Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests, and the queuing or logging of requests. It also allows for the support of undoable operations.<br/>将请求封装为一个对象，从而允许使用不同请求的客户端参数化，以及请求的排队或日志记录。它还支持可撤消的操作。</td>
</tr>
<tr>
<td>Interpreter<br/>解释器</td>
<td align="left">Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.<br/>给定一种语言，定义其语法的表示，以及使用该表示来解释该语言中的句子的解释器。</td>
</tr>
<tr>
<td>Iterator<br/>迭代器</td>
<td align="left">Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.<br/>提供一种按顺序访问聚合对象的元素而不暴露其底层表示的方法。</td>
</tr>
<tr>
<td>Mediator<br/>中介者</td>
<td align="left">Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it allows their interaction to vary independently.<br/>定义封装一组对象如何交互的对象。中介器通过防止对象显式地相互引用来促进松耦合，并且允许它们的交互独立地变化。</td>
</tr>
<tr>
<td>Memento<br/>备忘录</td>
<td align="left">Without violating encapsulation, capture and externalize an object’s internal state allowing the object to be restored to this state later.<br/>在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后将对象恢复到该状态。</td>
</tr>
<tr>
<td>Null object<br/>空对象</td>
<td align="left">Avoid null references by providing a default object.<br/>通过提供默认对象来避免空引用。</td>
</tr>
<tr>
<td>Observer or Publish/subscribe<br/>观察者</td>
<td align="left">Define a one-to-many dependency between objects where a state change in one object results in all its dependents being notified and updated automatically.<br/>定义对象之间的一对多依赖关系，其中一个对象中的状态更改将导致所有依赖关系被自动通知和更新。</td>
</tr>
<tr>
<td>Servant<br/>助手</td>
<td align="left">Define common functionality for a group of classes. The servant pattern is also frequently called helper class or utility class implementation for a given set of classes. The helper classes generally have no objects hence they have all static methods that act upon different kinds of class objects.<br/>为一组类定义公共功能。对于给定的一组类，服务模式也经常被称为助手类或实用程序类实现。helper类通常没有对象，因此它们具有所有作用于不同类型的类对象的静态方法。</td>
</tr>
<tr>
<td>Specification<br/>规格</td>
<td align="left">Recombinable business logic in a Boolean fashion.<br/>以布尔方式重组业务逻辑。</td>
</tr>
<tr>
<td>State<br/>状态</td>
<td align="left">Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.<br/>允许对象在其内部状态发生变化时改变其行为。对象将显示更改其类。</td>
</tr>
<tr>
<td>Strategy<br/>策略</td>
<td align="left">Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.<br/>定义一系列算法，封装每个算法，并使它们可互换。策略允许算法独立于使用它的客户机变化。</td>
</tr>
<tr>
<td>Template method<br/>模板方法</td>
<td align="left">Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.<br/>在操作中定义算法的框架，将一些步骤推迟到子类。模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。</td>
</tr>
<tr>
<td>Visitor<br/>访问者</td>
<td align="left">Represent an operation to be performed on the elements of an object structure. Visitor lets a new operation be defined without changing the classes of the elements on which it operates.<br/>表示要对对象结构的元素执行的操作。Visitor允许定义一个新操作，而无需更改它所操作的元素的类。</td>
</tr>
</tbody></table>
<h3 id="Concurrency-patterns-并发模式"><a href="#Concurrency-patterns-并发模式" class="headerlink" title="Concurrency patterns(并发模式)"></a>Concurrency patterns(并发模式)</h3><table>
<thead>
<tr>
<th>Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td>Active Object<br/>主动对象</td>
<td align="left">Decouples method execution from method invocation that reside in their own thread of control. The goal is to introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests.<br/>将方法执行与驻留在它们自己的控制线程中的方法调用解耦。目标是通过使用异步方法调用和用于处理请求的调度器引入并发性。</td>
</tr>
<tr>
<td>Balking<br/>阻碍</td>
<td align="left">Only execute an action on an object when the object is in a particular state.<br/>只有当对象处于特定状态时，才对该对象执行操作。</td>
</tr>
<tr>
<td>Binding properties<br/>绑定属性</td>
<td align="left">Combining multiple observers to force properties in different objects to be synchronized or coordinated in some way.<br/>组合多个观察者以强制以某种方式同步或协调不同对象中的属性。</td>
</tr>
<tr>
<td>Compute kernel<br/>计算内核</td>
<td align="left">The same calculation many times in parallel, differing by integer parameters used with non-branching pointer math into shared arrays, such as GPU-optimized Matrix multiplication or Convolutional neural network.<br/>相同的计算并行多次，不同于非分支指针数学用于共享数组的整数参数，例如GPU优化的矩阵乘法或卷积神经网络。</td>
</tr>
<tr>
<td>Double-checked locking<br/>双重检查锁定</td>
<td align="left">Reduce the overhead of acquiring a lock by first testing the locking criterion (the ‘lock hint’) in an unsafe manner; only if that succeeds does the actual locking logic proceed.Can be unsafe when implemented in some language/hardware combinations. It can therefore sometimes be considered an anti-pattern.<br/>首先以不安全的方式测试锁标准(“锁提示”)，从而减少获取锁的开销;只有成功了，实际的锁定逻辑才会继续。在某些语言/硬件组合中实现可能不安全。因此，有时可以认为它是一个反模式。</td>
</tr>
<tr>
<td>Event-based asynchronous<br/>基于事件的异步</td>
<td align="left">Addresses problems with the asynchronous pattern that occur in multithreaded programs.<br/>处理多线程程序中出现的异步模式的问题。</td>
</tr>
<tr>
<td>Guarded suspension<br/>守卫</td>
<td align="left">Manages operations that require both a lock to be acquired and a precondition to be satisfied before the operation can be executed.<br/>管理既需要获取锁又需要在执行操作之前满足先决条件的操作。</td>
</tr>
<tr>
<td>Join<br/>连接</td>
<td align="left">Join-pattern provides a way to write concurrent, parallel and distributed programs by message passing. Compared to the use of threads and locks, this is a high-level programming model.<br/>Join-pattern提供了一种通过消息传递编写并发、并行和分布式程序的方法。与线程和锁的使用相比，这是一个高级编程模型。</td>
</tr>
<tr>
<td>Lock<br/>锁</td>
<td align="left">One thread puts a “lock” on a resource, preventing other threads from accessing or modifying it.<br/>一个线程对资源进行“锁定”，防止其他线程访问或修改资源。</td>
</tr>
<tr>
<td>Messaging design pattern (MDP)<br/>消息传递设计模式</td>
<td align="left">Allows the interchange of information (i.e. messages) between components and applications.<br/>允许在组件和应用程序之间交换信息（即消息）。</td>
</tr>
<tr>
<td>Monitor object<br/>监控对象</td>
<td align="left">An object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying to use it at the same time.<br/>一种对象，其方法可以互斥，从而防止多个对象同时错误地尝试使用它。</td>
</tr>
<tr>
<td>Reactor<br/>反应器</td>
<td align="left">A reactor object provides an asynchronous interface to resources that must be handled synchronously.<br/>反应器对象提供了必须同步处理的资源的异步接口。</td>
</tr>
<tr>
<td>Read-write lock<br/>迭代器</td>
<td align="left">Allows concurrent read access to an object, but requires exclusive access for write operations.<br/>允许对对象进行并发读访问，但需要对写操作进行独占访问。</td>
</tr>
<tr>
<td>Scheduler<br/>调度</td>
<td align="left">Explicitly control when threads may execute single-threaded code.<br/>明确控制线程何时可以执行单线程代码。</td>
</tr>
<tr>
<td>Thread pool<br/>线程池</td>
<td align="left">A number of threads are created to perform a number of tasks, which are usually organized in a queue. Typically, there are many more tasks than threads. Can be considered a special case of the object pool pattern.<br/>创建了许多线程来执行许多任务，这些任务通常组织在队列中。通常，除了线程之外还有许多任务。可以认为是对象池模式的特例。</td>
</tr>
<tr>
<td>Thread-specific storage<br/>特定于线程的存储</td>
<td align="left">Static or “global” memory local to a thread.<br/>线程本地的静态或“全局”内存。</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2019/01/09/SoftwareDesignPatterns/" data-id="ckvgcipjn0015plqhfttlcrq0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/design-patterns/" rel="tag">design patterns</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaDesignPatterns-Creational" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/27/JavaDesignPatterns-Creational/" class="article-date">
  <time datetime="2018-12-27T09:17:15.000Z" itemprop="datePublished">2018-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Software-Design-Patterns/">Software Design Patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/27/JavaDesignPatterns-Creational/">Java 设计模式 - Creational</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h1><p>在软件工程中，创造型设计模式是处理对象创建机制的设计模式，它试图以适合这种情况的方式创建对象。对象创建的基本形式可能会导致设计问题或增加设计的复杂性。创造型设计模式通过某种方式控制对象的创建来解决这个问题。</p>
<p>创造型设计模式由两个主导思想组成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</p>
<p>创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>创建型模式旨在将系统与它的对象创建、结合、表示的方式分离。这些设计模式在对象创建的类型、主体、方式、时间等方面提高了系统的灵活性。</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>现代软件工程更加依赖对象的组合，而不是类的继承，强调从硬编码的行为转变到定义一组基本行为来组合成复杂的行为。硬编码的行为不够灵活，因为如果想要改变设计的一部分，需要通过重写或者重新实现才能完成。另外，硬编码没有提高重用性，而且难以跟踪错误。由于这些原因，创建型模式比硬编码的行为更有用。创建型模式使设计变得更灵活，提供了不同的方式，从代码中移除了对需要实例化的具体类的引用。换句话说，这些模式增强了对象和类之间的独立性。</p>
<p>在以下情况中，可以考虑应用创建型模式：</p>
<ul>
<li>一个系统需要和它的对象和产品的创建相互独立。</li>
<li>一组相关的对象被设计为一起使用。</li>
<li>隐藏一个类库的具体实现，仅暴露它们的接口。</li>
<li>创建独立复杂对象的不同表示。</li>
<li>一个类希望它的子类实现它所创建的对象。</li>
<li>类的实例化在运行时才指定。</li>
<li>一个类只能有一个实例，而且这个实例能在任何时候访问到。</li>
<li>实例应该能在不修改的情况下具有可扩展性。</li>
</ul>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>创建型设计模式的一些示例包括：</p>
<ul>
<li>Factory Mothed pattern(工厂方法模式) - 允许一个类的实例化推迟到子类中进行。</li>
<li>Abstract Factory pattern(抽象工厂模式) - 提供一个创建相关或依赖对象的接口，而不指定对象的具体类。</li>
<li>Singleton pattern(单例模式) - 保证一个类只有一个实例，并且提供对这个实例的全局访问方式。</li>
<li>Builder pattern(生成器模式) - 将一个复杂对象的创建与它的表示分离，使同样的创建过程可以创建不同的表示。</li>
<li>Lazy Initialization pattern(延迟初始化模式) - 将对象的创建，某个值的计算，或者其他代价较高的过程推迟到它第一次需要时进行。</li>
<li>Object Pool pattern(对象池模式) - 通过回收不再使用的对象，避免创建和销毁对象时代价高昂的获取和释放资源的过程。</li>
<li>Prototype pattern(原型模式) - 使用原型实例指定要创建的对象类型，通过复制原型创建新的对象。</li>
</ul>
<h1 id="Factory-Pattern-in-Java"><a href="#Factory-Pattern-in-Java" class="headerlink" title="Factory Pattern in Java"></a>Factory Pattern in Java</h1><h2 id="What-is-Factory-Design-Pattern"><a href="#What-is-Factory-Design-Pattern" class="headerlink" title="What is Factory Design Pattern?"></a>What is Factory Design Pattern?</h2><p>工厂方法模式（Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
<p>创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。</p>
<p>对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Factory_method_pattern">more</a></p>
<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><p>在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂是构造方法的抽象，用来实现不同的分配方案。</p>
<p>工厂对象通常包含一个或多个方法，用来创建这个工厂所能创建的各种类型的对象。这些方法可能接收参数，用来指定对象创建的方式，最后返回创建的对象。</p>
<p>有时，特定类型对象的控制过程比简单地创建一个对象更复杂。在这种情况下，工厂对象就派上用场了。工厂对象可能会动态地创建产品对象的类，或者从对象池中返回一个对象，或者对所创建的对象进行复杂的配置，或者应用其他的操作。</p>
<p>这些类型的对象很有用。几个不同的设计模式都应用了工厂的概念，并可以使用在很多语言中。例如，在《设计模式》一书中，像工厂方法模式、抽象工厂模式、生成器模式，甚至是单例模式都应用了工厂的概念。</p>
<h2 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h2><p>当我们有一个具有多个子类的超类，并且基于输入，我们需要返回其中一个子类时，将使用工厂设计模式。这种模式将类的实例化从客户端程序转移到工厂类。</p>
<p>让我们首先学习如何在java中实现工厂设计模式，然后我们将研究工厂模式的优势。我们将在JDK中看到一些工厂设计模式的使用。请注意，此模式也称为工厂方法设计模式。</p>
<h3 id="Factory-Design-Pattern-Super-Class"><a href="#Factory-Design-Pattern-Super-Class" class="headerlink" title="Factory Design Pattern Super Class"></a>Factory Design Pattern Super Class</h3><p>工厂设计模式中的超类可以是接口，抽象类或普通的java类。对于我们的工厂设计模式示例，我们使用带有重写的toString()方法的抽象超类进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.model;</span><br><span class="line"></span><br><span class="line">public abstract class Computer &#123;</span><br><span class="line">	</span><br><span class="line">	public abstract String getRAM();</span><br><span class="line">	public abstract String getHDD();</span><br><span class="line">	public abstract String getCPU();</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString()&#123;</span><br><span class="line">		return &quot;RAM= &quot;+this.getRAM()+&quot;, HDD=&quot;+this.getHDD()+&quot;, CPU=&quot;+this.getCPU();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Factory-Design-Pattern-Sub-Classes"><a href="#Factory-Design-Pattern-Sub-Classes" class="headerlink" title="Factory Design Pattern Sub Classes"></a>Factory Design Pattern Sub Classes</h3><p>假设我们有两个子类PC和Server，具有以下实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.model;</span><br><span class="line"></span><br><span class="line">public class PC extends Computer &#123;</span><br><span class="line"></span><br><span class="line">	private String ram;</span><br><span class="line">	private String hdd;</span><br><span class="line">	private String cpu;</span><br><span class="line">	</span><br><span class="line">	public PC(String ram, String hdd, String cpu)&#123;</span><br><span class="line">		this.ram=ram;</span><br><span class="line">		this.hdd=hdd;</span><br><span class="line">		this.cpu=cpu;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String getRAM() &#123;</span><br><span class="line">		return this.ram;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getHDD() &#123;</span><br><span class="line">		return this.hdd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getCPU() &#123;</span><br><span class="line">		return this.cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这两个类都在扩展计算机超类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.model;</span><br><span class="line"></span><br><span class="line">public class Server extends Computer &#123;</span><br><span class="line"></span><br><span class="line">	private String ram;</span><br><span class="line">	private String hdd;</span><br><span class="line">	private String cpu;</span><br><span class="line">	</span><br><span class="line">	public Server(String ram, String hdd, String cpu)&#123;</span><br><span class="line">		this.ram=ram;</span><br><span class="line">		this.hdd=hdd;</span><br><span class="line">		this.cpu=cpu;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String getRAM() &#123;</span><br><span class="line">		return this.ram;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getHDD() &#123;</span><br><span class="line">		return this.hdd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getCPU() &#123;</span><br><span class="line">		return this.cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Factory-Class"><a href="#Factory-Class" class="headerlink" title="Factory Class"></a>Factory Class</h3><p>现在我们已经准备好了超级类和子类，我们可以编写工厂类。这是基本的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.factory;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.model.Computer;</span><br><span class="line">import com.journaldev.design.model.PC;</span><br><span class="line">import com.journaldev.design.model.Server;</span><br><span class="line"></span><br><span class="line">public class ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">	public static Computer getComputer(String type, String ram, String hdd, String cpu)&#123;</span><br><span class="line">		if(&quot;PC&quot;.equalsIgnoreCase(type)) return new PC(ram, hdd, cpu);</span><br><span class="line">		else if(&quot;Server&quot;.equalsIgnoreCase(type)) return new Server(ram, hdd, cpu);</span><br><span class="line">		</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于工厂设计模式方法的一些要点是;</p>
<ul>
<li>我们可以保持工厂类是单例的，也可以保持返回子类的方法是静态的。</li>
<li>注意，基于输入参数，将创建并返回不同的子类。 getComputer是工厂方法。</li>
</ul>
<h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><ul>
<li>工厂模式提供了接口而不是实现的代码方法。</li>
<li>工厂模式从客户端代码中移除实际实现类的实例化。工厂模式使我们的代码更健壮，耦合更少，易于扩展。例如，我们可以很容易地更改PC类实现，因为客户机程序不知道这一点。</li>
<li>工厂模式通过继承提供实现和客户端类之间的抽象。</li>
</ul>
<blockquote>
<p>代码健壮性是指软件对于规范要求以外的输入情况的处理能力。所谓健壮的系统是指对于规范要求以外的输入能够判断出这个输入不符合规范要求，并能有合理的处理方式。通俗地讲，代码的健壮性越好，系统越不容易崩溃。</p>
</blockquote>
<h2 id="Factory-Design-Pattern-Examples-in-JDK"><a href="#Factory-Design-Pattern-Examples-in-JDK" class="headerlink" title="Factory Design Pattern Examples in JDK"></a>Factory Design Pattern Examples in JDK</h2><ul>
<li>java.util.Calendar，ResourceBundle和NumberFormat getInstance()方法使用Factory模式。</li>
<li>包装类中的valueOf()方法，如Boolean，Integer等。</li>
</ul>
<h1 id="Abstract-Factory-Design-Pattern-in-Java"><a href="#Abstract-Factory-Design-Pattern-in-Java" class="headerlink" title="Abstract Factory Design Pattern in Java"></a>Abstract Factory Design Pattern in Java</h1><h2 id="What-is-Abstract-Factory-Design-Pattern"><a href="#What-is-Abstract-Factory-Design-Pattern" class="headerlink" title="What is Abstract Factory Design Pattern?"></a>What is Abstract Factory Design Pattern?</h2><p>抽象工厂模式（Abstract factory pattern）是一种软件开发设计模式，抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来，且无需指定它们具体的实现类。在正常使用中，客户端创建抽象工厂的具体实现，然后使用抽象工厂的通用接口创建作为该主题部分的具体对象。该客户端不需要知道（或关心），它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。此模式将一组对象的实现细节与其一般用法分开，并依赖于对象组合，因为对象创建是在工厂界面中公开的方法中实现的。</p>
<p>举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建信件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（信件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“信件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“信件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。</p>
<p>“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。</p>
<p>使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Abstract_factory_pattern">more</a></p>
<h2 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h2><p>如果熟悉java中的工厂设计模式，会注意到我们有一个Factory类。此工厂类根据提供的输入返回不同的子类，工厂类使用if-else或switch语句来实现此目的。</p>
<p>在抽象工厂模式中，我们摆脱if-else块并为每个子类设置工厂类。然后是一个Abstract Factory类，它将根据输入工厂类返回子类。起初，它似乎令人困惑但是一旦你看到实现，就很容易理解和理解Factory和Abstract Factory模式之间的细微差别。</p>
<h3 id="Abstract-Factory-Design-Pattern-Super-Class-and-Subclasses"><a href="#Abstract-Factory-Design-Pattern-Super-Class-and-Subclasses" class="headerlink" title="Abstract Factory Design Pattern Super Class and Subclasses"></a>Abstract Factory Design Pattern Super Class and Subclasses</h3><p>就像工厂模式一样，我们将使用相同的超类和子类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.model;</span><br><span class="line"> </span><br><span class="line">public abstract class Computer &#123;</span><br><span class="line">     </span><br><span class="line">    public abstract String getRAM();</span><br><span class="line">    public abstract String getHDD();</span><br><span class="line">    public abstract String getCPU();</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;RAM= &quot;+this.getRAM()+&quot;, HDD=&quot;+this.getHDD()+&quot;, CPU=&quot;+this.getCPU();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.model;</span><br><span class="line"> </span><br><span class="line">public class PC extends Computer &#123;</span><br><span class="line"> </span><br><span class="line">    private String ram;</span><br><span class="line">    private String hdd;</span><br><span class="line">    private String cpu;</span><br><span class="line">     </span><br><span class="line">    public PC(String ram, String hdd, String cpu)&#123;</span><br><span class="line">        this.ram=ram;</span><br><span class="line">        this.hdd=hdd;</span><br><span class="line">        this.cpu=cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getRAM() &#123;</span><br><span class="line">        return this.ram;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String getHDD() &#123;</span><br><span class="line">        return this.hdd;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String getCPU() &#123;</span><br><span class="line">        return this.cpu;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.model;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class Server extends Computer &#123;</span><br><span class="line"> </span><br><span class="line">    private String ram;</span><br><span class="line">    private String hdd;</span><br><span class="line">    private String cpu;</span><br><span class="line">     </span><br><span class="line">    public Server(String ram, String hdd, String cpu)&#123;</span><br><span class="line">        this.ram=ram;</span><br><span class="line">        this.hdd=hdd;</span><br><span class="line">        this.cpu=cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getRAM() &#123;</span><br><span class="line">        return this.ram;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String getHDD() &#123;</span><br><span class="line">        return this.hdd;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String getCPU() &#123;</span><br><span class="line">        return this.cpu;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Factory-Class-for-Each-subclass"><a href="#Factory-Class-for-Each-subclass" class="headerlink" title="Factory Class for Each subclass"></a>Factory Class for Each subclass</h3><p>首先，我们需要创建一个Abstract Factory接口或抽象类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.abstractfactory;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.model.Computer;</span><br><span class="line"></span><br><span class="line">public interface ComputerAbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">	public Computer createComputer();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，createComputer()方法正在返回超类计算机的实例。现在我们的工厂类将实现此接口并返回其各自的子类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.abstractfactory;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.model.Computer;</span><br><span class="line">import com.journaldev.design.model.PC;</span><br><span class="line"></span><br><span class="line">public class PCFactory implements ComputerAbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">	private String ram;</span><br><span class="line">	private String hdd;</span><br><span class="line">	private String cpu;</span><br><span class="line">	</span><br><span class="line">	public PCFactory(String ram, String hdd, String cpu)&#123;</span><br><span class="line">		this.ram=ram;</span><br><span class="line">		this.hdd=hdd;</span><br><span class="line">		this.cpu=cpu;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Computer createComputer() &#123;</span><br><span class="line">		return new PC(ram,hdd,cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，我们将为服务器子类创建一个工厂类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.abstractfactory;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.model.Computer;</span><br><span class="line">import com.journaldev.design.model.Server;</span><br><span class="line"></span><br><span class="line">public class ServerFactory implements ComputerAbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">	private String ram;</span><br><span class="line">	private String hdd;</span><br><span class="line">	private String cpu;</span><br><span class="line">	</span><br><span class="line">	public ServerFactory(String ram, String hdd, String cpu)&#123;</span><br><span class="line">		this.ram=ram;</span><br><span class="line">		this.hdd=hdd;</span><br><span class="line">		this.cpu=cpu;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public Computer createComputer() &#123;</span><br><span class="line">		return new Server(ram,hdd,cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们将创建一个 consumer 类，它将为客户端类提供创建子类的入口点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.abstractfactory;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.model.Computer;</span><br><span class="line"></span><br><span class="line">public class ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">	public static Computer getComputer(ComputerAbstractFactory factory)&#123;</span><br><span class="line">		return factory.createComputer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，它是一个简单的类和有一个getComputer方法，它接受ComputerAbstractFactory参数并返回Computer对象。此时，方法必须要实现。</p>
<p>让我们编写一个简单的测试方法，看看如何使用抽象工厂来获取子类的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.test;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.abstractfactory.PCFactory;</span><br><span class="line">import com.journaldev.design.abstractfactory.ServerFactory;</span><br><span class="line">import com.journaldev.design.factory.ComputerFactory;</span><br><span class="line">import com.journaldev.design.model.Computer;</span><br><span class="line"></span><br><span class="line">public class TestDesignPatterns &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		testAbstractFactory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void testAbstractFactory() &#123;</span><br><span class="line">		Computer pc = com.journaldev.design.abstractfactory.ComputerFactory.getComputer(new PCFactory(&quot;2 GB&quot;,&quot;500 GB&quot;,&quot;2.4 GHz&quot;));</span><br><span class="line">		Computer server = com.journaldev.design.abstractfactory.ComputerFactory.getComputer(new ServerFactory(&quot;16 GB&quot;,&quot;1 TB&quot;,&quot;2.9 GHz&quot;));</span><br><span class="line">		System.out.println(&quot;AbstractFactory PC Config::&quot;+pc);</span><br><span class="line">		System.out.println(&quot;AbstractFactory Server Config::&quot;+server);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Advantages-1"><a href="#Advantages-1" class="headerlink" title="Advantages"></a>Advantages</h2><ul>
<li>抽象工厂模式提供了接口而不是实现代码的方法。</li>
<li>抽象工厂模式是“工厂中的工厂”，可以很容易地扩展以适应更多的产品，例如，我们可以添加另一个子类笔记本电脑和一个笔记本电脑工厂。</li>
<li>抽象的工厂模式是健壮的，避免了工厂模式的条件逻辑。</li>
</ul>
<h2 id="Abstract-Factory-Design-Pattern-Examples-in-JDK"><a href="#Abstract-Factory-Design-Pattern-Examples-in-JDK" class="headerlink" title="Abstract Factory Design Pattern Examples in JDK"></a>Abstract Factory Design Pattern Examples in JDK</h2><ul>
<li>javax.xml.parsers.DocumentBuilderFactory#newInstance()</li>
<li>javax.xml.transform.TransformerFactory#newInstance()</li>
<li>javax.xml.xpath.XPathFactory#newInstance()</li>
</ul>
<h1 id="Singleton-Design-Pattern-in-Java"><a href="#Singleton-Design-Pattern-in-Java" class="headerlink" title="Singleton Design Pattern in Java"></a>Singleton Design Pattern in Java</h1><h2 id="What-is-Singleton-Design-Pattern"><a href="#What-is-Singleton-Design-Pattern" class="headerlink" title="What is Singleton Design Pattern?"></a>What is Singleton Design Pattern?</h2><p>单例模式（Singleton Design Pattern）是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Singleton_pattern">more</a></p>
<p>总结为以下几点：</p>
<ul>
<li>Singleton模式限制类的实例化，并确保java虚拟机中只存在该类的一个实例。</li>
<li>单例类必须提供一个全局访问点来获取类的实例。</li>
<li>单例模式用于日志记录，驱动程序对象，缓存和线程池。</li>
<li>Singleton设计模式也用于其他设计模式，如Abstract Factory，Builder，Prototype，Facade等。</li>
<li>例如java.lang.Runtime，单核设计模式也用于核心java类中java.awt.Desktop。</li>
</ul>
<h2 id="Usage-3"><a href="#Usage-3" class="headerlink" title="Usage"></a>Usage</h2><p>为了实现Singleton模式，我们有不同的方法，但它们都有以下常见概念：</p>
<ul>
<li>私有构造函数，用于限制其他类的实例化。</li>
<li>同一个类的私有静态变量，它是该类的唯一实例。</li>
<li>返回类实例的公共静态方法，这是外部世界获取单例类实例的全局访问点。</li>
</ul>
<p>Singleton模式有以下实现的不同方法以及设计实现的不同关注点：</p>
<ul>
<li>Eager initialization</li>
<li>Static block initialization</li>
<li>Lazy Initialization</li>
<li>Thread Safe Singleton</li>
<li>Bill Pugh Singleton Implementation</li>
<li>Using Reflection to destroy Singleton Pattern</li>
<li>Enum Singleton</li>
<li>Serialization and Singleton</li>
</ul>
<h3 id="Eager-Initialization"><a href="#Eager-Initialization" class="headerlink" title="Eager Initialization"></a>Eager Initialization</h3><p>在 Eager Initialization (即时初始化) 中，单例类的实例是在类加载时创建的，这是创建单例类最简单的方法，但它有一个缺点，即使客户端应用程序可能不使用它，也会创建实例。</p>
<p>下面是静态初始化singleton类的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">public class EagerInitializedSingleton &#123;</span><br><span class="line">    </span><br><span class="line">    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();</span><br><span class="line">    </span><br><span class="line">    //private constructor to avoid client applications to use constructor</span><br><span class="line">    private EagerInitializedSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static EagerInitializedSingleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果单例类没有使用很多资源，那么可以使用这种方法。但是在大多数情况下，单例类是为资源(如文件系统、数据库连接等)创建的。我们应该避免实例化，除非客户端调用getInstance方法。此外，此方法不提供任何异常处理选项。</p>
<h3 id="Static-block-initialization"><a href="#Static-block-initialization" class="headerlink" title="Static block initialization"></a>Static block initialization</h3><p>Static block initialization (静态块初始化) 实现类似于 Eager Initialization (即时初始化)，除了在静态块中创建类的实例，该静态块提供异常处理选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">public class StaticBlockSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static StaticBlockSingleton instance;</span><br><span class="line">    </span><br><span class="line">    private StaticBlockSingleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    //static block initialization for exception handling</span><br><span class="line">    static&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            instance = new StaticBlockSingleton();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;Exception occured in creating singleton instance&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static StaticBlockSingleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即时初始化和静态块初始化都是在实例被使用之前创建的，这不是最佳实践。因此，在接下来的部分中，我们将学习如何创建一个支持延迟初始化的单例类。</p>
<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/1365/static-keyword-in-java">Static Keyword</a></p>
<h3 id="Lazy-Initialization"><a href="#Lazy-Initialization" class="headerlink" title="Lazy Initialization"></a>Lazy Initialization</h3><p>实现单例模式的 Lazy Initialization (延迟初始化) 在全局访问方法中创建实例。下面是使用这种方法创建单例类的示例代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">public class LazyInitializedSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static LazyInitializedSingleton instance;</span><br><span class="line">    </span><br><span class="line">    private LazyInitializedSingleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static LazyInitializedSingleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new LazyInitializedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现在单线程环境中工作得很好，但是当涉及到多线程系统时，如果多个线程同时在if条件中，它可能会导致问题。它将破坏单例模式，两个线程都将获得单例类的不同实例。在下一节中，我们将看到创建线程安全的单例类的不同方法。</p>
<h3 id="Thread-Safe-Singleton"><a href="#Thread-Safe-Singleton" class="headerlink" title="Thread Safe Singleton"></a>Thread Safe Singleton</h3><p>创建线程安全的单例类的更简单方法是使全局访问方法同步，以便一次只有一个线程可以执行此方法。这种方法的一般实现类似于下面的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">public class ThreadSafeSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadSafeSingleton instance;</span><br><span class="line">    </span><br><span class="line">    private ThreadSafeSingleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized ThreadSafeSingleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new ThreadSafeSingleton();i</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现工作得很好，并提供了线程安全，但是由于与synchronized方法相关的成本，它降低了性能，尽管我们只需要它来处理可能创建单独实例的前几个线程(即:Java同步)。为了避免每次额外的开销，使用了双重检查锁定原则。在这种方法中，同步块在if条件中使用，并附加一个检查，以确保只创建了一个单例类的实例。</p>
<p>下面的代码片段提供了双重检查的锁定实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ThreadSafeSingleton getInstanceUsingDoubleLocking()&#123;</span><br><span class="line">    if(instance == null)&#123;</span><br><span class="line">        synchronized (ThreadSafeSingleton.class) &#123;</span><br><span class="line">            if(instance == null)&#123;</span><br><span class="line">                instance = new ThreadSafeSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples">Thread Safety in Java Singleton</a></p>
<h3 id="Bill-Pugh-Singleton-Implementation"><a href="#Bill-Pugh-Singleton-Implementation" class="headerlink" title="Bill Pugh Singleton Implementation"></a>Bill Pugh Singleton Implementation</h3><p>在Java 5之前，Java内存模型有很多问题，在某些情况下，如果有太多线程试图同时获取Singleton类的实例，那么上面的方法就会失败。因此Bill Pugh提出了一种不同的方法来使用内部静态助手类创建单例类。Bill Pugh单例实现是这样的;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">public class BillPughSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private BillPughSingleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static class SingletonHelper&#123;</span><br><span class="line">        private static final BillPughSingleton INSTANCE = new BillPughSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static BillPughSingleton getInstance()&#123;</span><br><span class="line">        return SingletonHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意包含singleton类实例的私有内部静态类。加载单例类时，SingletonHelper类不会加载到内存中，只有当有人调用getInstance方法时，才会加载此类并创建Singleton类实例。</p>
<p>这是Singleton类最广泛使用的方法，因为它不需要同步。许多项目中使用这种方法，它也很容易理解和实现。</p>
<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/996/java-inner-class">Java Inner Class</a></p>
<h3 id="Using-Reflection-to-destroy-Singleton-Pattern"><a href="#Using-Reflection-to-destroy-Singleton-Pattern" class="headerlink" title="Using Reflection to destroy Singleton Pattern"></a>Using Reflection to destroy Singleton Pattern</h3><p>反射可用于销毁所有上述单例实现方法。让我们看一下示例类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectionSingletonTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance();</span><br><span class="line">        EagerInitializedSingleton instanceTwo = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Constructor[] constructors = EagerInitializedSingleton.class.getDeclaredConstructors();</span><br><span class="line">            for (Constructor constructor : constructors) &#123;</span><br><span class="line">                //Below code will destroy the singleton pattern</span><br><span class="line">                constructor.setAccessible(true);</span><br><span class="line">                instanceTwo = (EagerInitializedSingleton) constructor.newInstance();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(instanceOne.hashCode());</span><br><span class="line">        System.out.println(instanceTwo.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行上面的测试类时，会注意到两个实例的hashCode与销毁单例模式的方法不同。反射是非常强大的，并且在很多框架中使用，比如Spring和Hibernate.</p>
<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/1789/java-reflection-example-tutorial">Java Reflection Tutorial</a>。</p>
<h3 id="Enum-Singleton"><a href="#Enum-Singleton" class="headerlink" title="Enum Singleton"></a>Enum Singleton</h3><p>Joshua Bloch 在 Effect java 中建议使用Enum来实现Singleton设计模式，因为Java确保任何枚举值只在Java程序中实例化一次。由于Java Enum值是全局可访问的，因此单例也是如此。缺点是枚举类型有些不灵活; 例如，它不允许延迟初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">public enum EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/716/java-enum">Java Enum</a></p>
<h3 id="Serialization-and-Singleton"><a href="#Serialization-and-Singleton" class="headerlink" title="Serialization and Singleton"></a>Serialization and Singleton</h3><p>有时在分布式系统中，我们需要在Singleton类中实现Serializable接口，以便我们可以将其状态存储在文件系统中并在以后的时间点检索它。这是一个小型单例类，它也实现了Serializable接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class SerializedSingleton implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -7604766932017737115L;</span><br><span class="line"></span><br><span class="line">    private SerializedSingleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static class SingletonHelper&#123;</span><br><span class="line">        private static final SerializedSingleton instance = new SerializedSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static SerializedSingleton getInstance()&#123;</span><br><span class="line">        return SingletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化单例类的问题在于，每当我们反序列化它时，它将创建该类的新实例。让我们用一个简单的程序来看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.singleton;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInput;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutput;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class SingletonSerializedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        SerializedSingleton instanceOne = SerializedSingleton.getInstance();</span><br><span class="line">        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(</span><br><span class="line">                &quot;filename.ser&quot;));</span><br><span class="line">        out.writeObject(instanceOne);</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        //deserailize from file to object</span><br><span class="line">        ObjectInput in = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                &quot;filename.ser&quot;));</span><br><span class="line">        SerializedSingleton instanceTwo = (SerializedSingleton) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;instanceOne hashCode=&quot;+instanceOne.hashCode());</span><br><span class="line">        System.out.println(&quot;instanceTwo hashCode=&quot;+instanceTwo.hashCode());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的输出是;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instanceOne hashCode=2011117821</span><br><span class="line">instanceTwo hashCode=109647522</span><br></pre></td></tr></table></figure>

<p>所以它破坏了单例模式，为了克服这种情况我们需要做的就是提供readResolve()方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Object readResolve() &#123;</span><br><span class="line">    return getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此之后，您会注意到两个实例的hashCode在测试程序中是相同的。</p>
<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/927/objectoutputstream-java-write-object-file">Java Serialization</a> 和 <a target="_blank" rel="noopener" href="https://www.journaldev.com/933/objectinputstream-java-read-object-file">Java Deserialization</a></p>
<h1 id="Multiton-Pattern-in-Java"><a href="#Multiton-Pattern-in-Java" class="headerlink" title="Multiton Pattern in Java"></a>Multiton Pattern in Java</h1><h2 id="What-is-Multiton-Pattern"><a href="#What-is-Multiton-Pattern" class="headerlink" title="What is Multiton Pattern?"></a>What is Multiton Pattern?</h2><p>。 </p>
<p>在软件工程中，Multiton模式是一种对单例模式进行推广的设计模式。虽然Singleton模式只允许创建类的一个实例，但是Multiton模式允许受控地创建多个实例，它通过使用映射来管理这些实例。</p>
<p>Multiton模式是Singleton模式的扩展和增强版本。正如模式的名称所示，Multiton模式只不过是类的实例集合的预定义“n”，而Singleton类只有一个实例。Multiton模式（类）使用哈希或字典对实例列表进行分组。列表中的每个实例都与相应的密钥配对。通过使用密钥，相应的实例将返回到调用代码</p>
<p>大多数人和教科书都认为这是一种Singleton模式。例如，Multiton并没有显式地出现在备受推崇的面向对象编程教科书《设计模式》(Design Patterns)中(它是一种名为registry of singletons的更灵活的方法)。</p>
<p>虽然看起来多例只不过是一个具有同步访问的简单哈希表，但是有两个重要的区别。首先，Multiton不允许客户机添加映射。其次，多例从不返回空引用或空引用;相反，它使用关联键在第一个请求上创建并存储一个多实例。具有相同键的后续请求将返回原始实例。哈希表只是一个实现细节，而不是唯一可能的方法。该模式简化了应用程序中共享对象的检索。</p>
<p>由于对象池只创建一次，并且是与类(而不是实例)关联的成员，因此,Multiton保留了其扁平的行为，而不是演化为树结构。</p>
<p>Multiton是唯一的，因为它提供了对Multiton的单个目录(即所有键本身都在同一个名称空间中)的集中访问，其中池中的每个Multiton实例可能都有自己的状态。通过这种方式，模式提倡对系统的基本对象(例如LDAP系统提供的对象)进行索引存储。然而，Multiton仅限于单个系统的广泛使用，而不是无数的分布式系统。</p>
<p>Multiton模式的特点:</p>
<ul>
<li>多例模式可以有多个实例</li>
<li>多例类必须自己创建、管理自己的实例，并向外界提供自己的实例，因此，他的构造函数也是private的，这点跟单例模式是相同的</li>
<li>更具是否有上限分为：有上限多例类和无上限多例类。</li>
<li>多例模式往往具有一个聚集属性，通过向这个聚集属性登记已经创建过的实例达到循环使用实例的目的</li>
</ul>
<p>Multiton模式的缺陷：</p>
<ul>
<li>像Singleton模式一样，这种模式使单元测试变得更加困难，因为它将全局状态引入应用程序。</li>
<li>使用垃圾收集语言，它可能成为内存泄漏的来源，因为它引入了对对象的全局强引用。</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package at.gridtec.multiton;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Multiton &#123;</span><br><span class="line"></span><br><span class="line">    private static final int NUM_OF_INSTANCES = 5;</span><br><span class="line">    private static final List&lt;Multiton&gt; instanceList = new ArrayList&lt;Multiton&gt;(); </span><br><span class="line">    private static int instanceCount = 0;</span><br><span class="line">    private int instanceNum;</span><br><span class="line"></span><br><span class="line">    private Multiton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Multiton getInstance() &#123;</span><br><span class="line"></span><br><span class="line">        Multiton instance = null;</span><br><span class="line"></span><br><span class="line">        if (instanceList.size() == NUM_OF_INSTANCES) &#123;</span><br><span class="line">            instance = instanceList.get(instanceCount % NUM_OF_INSTANCES);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            instance = new Multiton();</span><br><span class="line">            instance.instanceNum = instanceList.size() + 1;</span><br><span class="line">            instanceList.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instanceCount++;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int getInstanceNum() &#123;</span><br><span class="line">        return instanceNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * for testing purposes</span><br><span class="line">     */</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Multiton Number: &quot; + getInstanceNum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package at.gridtec.multiton;</span><br><span class="line"></span><br><span class="line">public class MutlitonTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 25; i++) &#123;</span><br><span class="line">            System.out.println(Multiton.getInstance());</span><br><span class="line">            if (Multiton.getInstance().getInstanceNum() &gt; 5) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Builder-Design-Pattern-in-Java"><a href="#Builder-Design-Pattern-in-Java" class="headerlink" title="Builder Design Pattern in Java"></a>Builder Design Pattern in Java</h1><h2 id="What-is-Builder-Design-Pattern"><a href="#What-is-Builder-Design-Pattern" class="headerlink" title="What is Builder Design Pattern?"></a>What is Builder Design Pattern?</h2><p>Builder设计模式是二十三种着名的GoF设计模式之一，描述了如何解决面向对象软件中的重复设计问题。</p>
<p>当Object包含许多属性时，Factory和Abstract Factory设计模式存在三个主要问题。</p>
<ul>
<li>从客户端程序传递到Factory类的参数太多，可能容易出错，因为大多数情况下，参数的类型是相同的，而从客户端来说，很难维护参数的顺序。</li>
<li>一些参数可能是可选的，但在Factory模式中，我们被迫发送所有需要发送为NULL的参数和可选参数。</li>
<li>如果对象很重并且它的创建很复杂，那么所有这些复杂性将成为Factory类的一部分，这会令人困惑。</li>
</ul>
<p>我们可以通过提供具有所需参数的构造函数然后使用不同的setter方法来设置可选参数来解决大量参数的问题。这种方法的问题是，除非明确设置所有属性，否则Object状态将不一致。</p>
<p>Builder模式通过提供逐步构建对象的方法并提供实际返回最终Object的方法，解决了大量可选参数和不一致状态的问题。</p>
<p>Builder设计模式的目的是将复杂 Object 的构造与其表示分开。通过这样做，相同的构造过程可以创建不同的表示。类（相同的构造过程）可以委托给不同的Builder对象来创建复杂对象的不同表示。</p>
<h2 id="Usage-4"><a href="#Usage-4" class="headerlink" title="Usage"></a>Usage</h2><p>如何在java中实现构建器设计模式。</p>
<ul>
<li>首先，需要创建一个静态嵌套类，然后将所有参数从外部类复制到Builder类。我们应该遵循命名约定，如果类名是，Computer那么构建器类应该命名为ComputerBuilder。</li>
<li>Java Builder类应该有一个公共构造函数，其中包含所有必需的属性作为参数。</li>
<li>Java Builder类应具有设置可选参数的方法，并且应在设置可选属性后返回相同的Builder对象。</li>
<li>最后一步是build()在构建器类中提供一个方法，该方法将返回客户端程序所需的Object。为此，我们需要在Class中使用Builder类作为参数的私有构造函数。</li>
</ul>
<p>下面是示例构建器模式示例代码，其中我们有一个Computer类和ComputerBuilder类来构建它:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.builder;</span><br><span class="line"></span><br><span class="line">public class Computer &#123;</span><br><span class="line">	</span><br><span class="line">	//required parameters</span><br><span class="line">	private String HDD;</span><br><span class="line">	private String RAM;</span><br><span class="line">	</span><br><span class="line">	//optional parameters</span><br><span class="line">	private boolean isGraphicsCardEnabled;</span><br><span class="line">	private boolean isBluetoothEnabled;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	public String getHDD() &#123;</span><br><span class="line">		return HDD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getRAM() &#123;</span><br><span class="line">		return RAM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean isGraphicsCardEnabled() &#123;</span><br><span class="line">		return isGraphicsCardEnabled;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean isBluetoothEnabled() &#123;</span><br><span class="line">		return isBluetoothEnabled;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private Computer(ComputerBuilder builder) &#123;</span><br><span class="line">		this.HDD=builder.HDD;</span><br><span class="line">		this.RAM=builder.RAM;</span><br><span class="line">		this.isGraphicsCardEnabled=builder.isGraphicsCardEnabled;</span><br><span class="line">		this.isBluetoothEnabled=builder.isBluetoothEnabled;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//Builder Class</span><br><span class="line">	public static class ComputerBuilder&#123;</span><br><span class="line"></span><br><span class="line">		// required parameters</span><br><span class="line">		private String HDD;</span><br><span class="line">		private String RAM;</span><br><span class="line"></span><br><span class="line">		// optional parameters</span><br><span class="line">		private boolean isGraphicsCardEnabled;</span><br><span class="line">		private boolean isBluetoothEnabled;</span><br><span class="line">		</span><br><span class="line">		public ComputerBuilder(String hdd, String ram)&#123;</span><br><span class="line">			this.HDD=hdd;</span><br><span class="line">			this.RAM=ram;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public ComputerBuilder setGraphicsCardEnabled(boolean isGraphicsCardEnabled) &#123;</span><br><span class="line">			this.isGraphicsCardEnabled = isGraphicsCardEnabled;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public ComputerBuilder setBluetoothEnabled(boolean isBluetoothEnabled) &#123;s</span><br><span class="line">			this.isBluetoothEnabled = isBluetoothEnabled;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public Computer build()&#123;</span><br><span class="line">			return new Computer(this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，Computer类只有getter方法，没有公共构造函数。因此，获取Computer对象的唯一方法是通过ComputerBuilder类。</p>
<p>这是一个构建器模式示例测试程序，显示如何使用Builder类来获取对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.test;</span><br><span class="line"></span><br><span class="line">import com.journaldev.design.builder.Computer;</span><br><span class="line"></span><br><span class="line">public class TestBuilderPattern &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//Using builder to get the object in a single line of code and </span><br><span class="line">                //without any inconsistent state or arguments management issues		</span><br><span class="line">		Computer comp = new Computer.ComputerBuilder(</span><br><span class="line">				&quot;500 GB&quot;, &quot;2 GB&quot;).setBluetoothEnabled(true)</span><br><span class="line">				.setGraphicsCardEnabled(true).build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Dependency-injection-in-Java"><a href="#Dependency-injection-in-Java" class="headerlink" title="Dependency injection in Java"></a>Dependency injection in Java</h1><h2 id="What-is-Dependency-Injection"><a href="#What-is-Dependency-Injection" class="headerlink" title="What is Dependency Injection?"></a>What is Dependency Injection?</h2><p>在软件工程中，依赖注入是一种技术，一个对象（或静态方法）提供另一个对象的依赖性。依赖项是可以使用的对象（服务）。注入是将依赖项传递给将使用它的依赖对象（客户端）。该服务是客户所在的一部分。将服务传递给客户端，而不是允许客户端构建或找到服务，是模式的基本要求。</p>
<p>依赖注入的目的是将对象解耦到不需要更改客户端代码的程度，因为它所依赖的对象需要更改为另一个。这允许遵循开放/封闭原则。</p>
<p>依赖注入是更广泛的控制反转技术的一种形式。与其他形式的控制反转一样，依赖注入支持依赖性反转原则。客户端将其依赖关系的责任委托给外部代码（注入器）。客户端不允许调用注入器代码; 它是构建服务并调用客户端注入它们的注入代码。这意味着客户端代码不需要知道注入代码，如何构建服务，甚至不知道它正在使用哪些实际服务; 客户端只需要知道服务的内在接口，因为它们定义了客户端如何使用服务。这分离了使用和构造的责任。</p>
<p>客户端接受依赖注入有三种常用方法：setter- ，interface- 和 constructor-based injection 。Setter 和 constructor-based injection 主要取决于它们何时可以使用。interface 注入的不同之处在于依赖关系有机会控制其自身的注入。每个都要求单独的构造代码（注入器）负责将客户端及其依赖关系引入彼此。</p>
<p>在Java中依赖注入设计模式允许我们删除硬编码的依赖项，并使我们的应用程序松散耦合，可扩展和可维护。我们可以在java中实现依赖注入，以将依赖项解析从编译时移动到运行时。</p>
<h2 id="Usage-5"><a href="#Usage-5" class="headerlink" title="Usage"></a>Usage</h2><p>假设我们有一个EmailService用于发送电子邮件的应用程序。通常我们会像下面这样实现它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.legacy;</span><br><span class="line"></span><br><span class="line">public class EmailService &#123;</span><br><span class="line"></span><br><span class="line">	public void sendEmail(String message, String receiver)&#123;</span><br><span class="line">		//logic to send email</span><br><span class="line">		System.out.println(&quot;Email sent to &quot;+receiver+ &quot; with Message=&quot;+message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmailService类保存将电子邮件消息发送到收件人电子邮件地址的逻辑。我们的应用程序代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.legacy;</span><br><span class="line"></span><br><span class="line">public class MyApplication &#123;</span><br><span class="line"></span><br><span class="line">	private EmailService email = new EmailService();</span><br><span class="line">	</span><br><span class="line">	public void processMessages(String msg, String rec)&#123;</span><br><span class="line">		//do some msg validation, manipulation logic etc</span><br><span class="line">		this.email.sendEmail(msg, rec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初看起来，上面的实现似乎没有错。但上面的代码逻辑有一定的局限性。</p>
<ul>
<li>MyApplicationclass负责初始化电子邮件服务，然后使用它。这导致了硬编码的依赖性。如果我们希望将来切换到其他一些高级电子邮件服务，则需要在MyApplication类中进行代码更改。这使我们的应用程序难以扩展，如果在多个类中使用电子邮件服务，那将更加困难。</li>
<li>如果我们想扩展我们的应用程序以提供其他消息传递功能，例如SMS或Facebook消息，那么我们需要为此编写另一个应用程序。这将涉及应用程序类和客户端类中的代码更改。</li>
<li>由于我们的应用程序直接创建电子邮件服务实例，因此测试应用程序将非常困难。我们无法在测试类中模拟这些对象。</li>
</ul>
<p>有人可能会说，我们可以通过一个构造函数将电子邮件服务作为参数来从MyApplication类中删除电子邮件服务实例的创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.legacy;</span><br><span class="line"></span><br><span class="line">public class MyApplication &#123;</span><br><span class="line"></span><br><span class="line">	private EmailService email = null;</span><br><span class="line">	</span><br><span class="line">	public MyApplication(EmailService svc)&#123;</span><br><span class="line">		this.email=svc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void processMessages(String msg, String rec)&#123;</span><br><span class="line">		//do some msg validation, manipulation logic etc</span><br><span class="line">		this.email.sendEmail(msg, rec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在这种情况下，我们要求客户端应用程序或测试类的初始化，这不是一个好的电子邮件服务的设计策略。</p>
<p>现在让我们看看我们如何应用java依赖注入模式来解决上述实现的所有问题。 java中的依赖注入至少需要以下内容：</p>
<ul>
<li>服务组件应该使用基类或接口进行设计。最好选择定义服务契约的接口或抽象类。</li>
<li>使用者类应该根据服务接口编写。</li>
<li>注入器类，它将初始化服务，然后初始化使用者类。</li>
</ul>
<h3 id="Service-Components"><a href="#Service-Components" class="headerlink" title="Service Components"></a>Service Components</h3><p>我们可以使用MessageService来声明服务实现的契约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.service;</span><br><span class="line"></span><br><span class="line">public interface MessageService &#123;</span><br><span class="line"></span><br><span class="line">	void sendMessage(String msg, String rec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现上述接口的电子邮件和SMS服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.service;</span><br><span class="line"></span><br><span class="line">public class EmailServiceImpl implements MessageService &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sendMessage(String msg, String rec) &#123;</span><br><span class="line">		//logic to send email</span><br><span class="line">		System.out.println(&quot;Email sent to &quot;+rec+ &quot; with Message=&quot;+msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.service;</span><br><span class="line"></span><br><span class="line">public class SMSServiceImpl implements MessageService &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sendMessage(String msg, String rec) &#123;</span><br><span class="line">		//logic to send SMS</span><br><span class="line">		System.out.println(&quot;SMS sent to &quot;+rec+ &quot; with Message=&quot;+msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Service-Consumer"><a href="#Service-Consumer" class="headerlink" title="Service Consumer"></a>Service Consumer</h3><p>我们不需要为使用者类提供基接口，但是需要为使用者类提供一个声明契约的使用者接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.consumer;</span><br><span class="line"></span><br><span class="line">public interface Consumer &#123;</span><br><span class="line"></span><br><span class="line">	void processMessages(String msg, String rec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用者类的实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.consumer;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.service.MessageService;</span><br><span class="line"></span><br><span class="line">public class MyDIApplication implements Consumer&#123;</span><br><span class="line"></span><br><span class="line">	private MessageService service;</span><br><span class="line">	</span><br><span class="line">	public MyDIApplication(MessageService svc)&#123;</span><br><span class="line">		this.service=svc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void processMessages(String msg, String rec)&#123;</span><br><span class="line">		//do some msg validation, manipulation logic etc</span><br><span class="line">		this.service.sendMessage(msg, rec);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我们的应用程序类只是在引用服务。它没有初始化导致它成为了一个“关注点分离”的服务。服务接口的使用还允许我们通过模拟MessageService轻松地测试应用程序，并在运行时而不是编译时绑定服务。</p>
<blockquote>
<p>关注点分离（Separation of concerns，SOC）是对只与“特定概念、目标”（关注点）相关联的软件组成部分进行“标识、封装和操纵”的能力，即标识、封装和操纵关注点的能力。是处理复杂性的一个原则。由于关注点混杂在一起会导致复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。<br/>关注点分离在计算机科学中，是将计算机程序分隔为不同部分的设计原则，是面向对象的程序设计的核心概念。每一部分会有各自的关注焦点。关注焦点是影响计算机程式代码的一组资讯。关注焦点可以像是将代码优化过的硬件细节一般，或者像实例化类别的名称一样具体。展现关注点分离设计的程序被称为模组化程序。模组化程度，也就是区分关注焦点，通过将资讯封装在具有明确界面的程序代码段落中。封装是一种资讯隐藏手段。资讯系统中的分层设计是关注点分离的另一个实施例（例如，表示层，业务逻辑层，数据访问层，维持齐一层）。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用（将针对特定领域问题代码抽象化成较少的程式码，例如将代码封装成function或是class），业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好的管理起来。</p>
</blockquote>
<p>现在，我们准备编写java依赖注入器类，这些类将初始化服务和使用者类。</p>
<h3 id="Injectors-Classes"><a href="#Injectors-Classes" class="headerlink" title="Injectors Classes"></a>Injectors Classes</h3><p>让我们有一个带有返回使用者类的方法声明的接口MessageServiceInjector。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.injector;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.Consumer;</span><br><span class="line"></span><br><span class="line">public interface MessageServiceInjector &#123;</span><br><span class="line"></span><br><span class="line">	public Consumer getConsumer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，对于每个服务，我们都必须创建下面这样的注入器类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.injector;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.Consumer;</span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;</span><br><span class="line">import com.journaldev.java.dependencyinjection.service.EmailServiceImpl;</span><br><span class="line"></span><br><span class="line">public class EmailServiceInjector implements MessageServiceInjector &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Consumer getConsumer() &#123;</span><br><span class="line">		return new MyDIApplication(new EmailServiceImpl());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.injector;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.Consumer;</span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;</span><br><span class="line">import com.journaldev.java.dependencyinjection.service.SMSServiceImpl;</span><br><span class="line"></span><br><span class="line">public class SMSServiceInjector implements MessageServiceInjector &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Consumer getConsumer() &#123;</span><br><span class="line">		return new MyDIApplication(new SMSServiceImpl());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们看看我们的客户端应用程序将如何在一个简单的程序中使用该应用程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.test;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.Consumer;</span><br><span class="line">import com.journaldev.java.dependencyinjection.injector.EmailServiceInjector;</span><br><span class="line">import com.journaldev.java.dependencyinjection.injector.MessageServiceInjector;</span><br><span class="line">import com.journaldev.java.dependencyinjection.injector.SMSServiceInjector;</span><br><span class="line"></span><br><span class="line">public class MyMessageDITest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String msg = &quot;Hi Pankaj&quot;;</span><br><span class="line">		String email = &quot;pankaj@abc.com&quot;;</span><br><span class="line">		String phone = &quot;4088888888&quot;;</span><br><span class="line">		MessageServiceInjector injector = null;</span><br><span class="line">		Consumer app = null;</span><br><span class="line">		</span><br><span class="line">		//Send email</span><br><span class="line">		injector = new EmailServiceInjector();</span><br><span class="line">		app = injector.getConsumer();</span><br><span class="line">		app.processMessages(msg, email);</span><br><span class="line">		</span><br><span class="line">		//Send SMS</span><br><span class="line">		injector = new SMSServiceInjector();</span><br><span class="line">		app = injector.getConsumer();</span><br><span class="line">		app.processMessages(msg, phone);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，我们的应用程序类只负责使用服务。服务类是在注入器中创建的。另外，如果我们必须进一步扩展我们的应用程序以允许facebook消息传递，我们将只编写服务类和注入器类。</p>
<p>因此，依赖注入实现解决了硬编码依赖的问题，并帮助我们使应用程序更加灵活和易于扩展。现在让我们看看如何通过模拟注入器和服务类来轻松地测试应用程序类。</p>
<h3 id="JUnit-Test-Case-with-Mock-Injector-and-Service"><a href="#JUnit-Test-Case-with-Mock-Injector-and-Service" class="headerlink" title="JUnit Test Case with Mock Injector and Service"></a>JUnit Test Case with Mock Injector and Service</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.test;</span><br><span class="line"></span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.Consumer;</span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;</span><br><span class="line">import com.journaldev.java.dependencyinjection.injector.MessageServiceInjector;</span><br><span class="line">import com.journaldev.java.dependencyinjection.service.MessageService;</span><br><span class="line"></span><br><span class="line">public class MyDIApplicationJUnitTest &#123;</span><br><span class="line"></span><br><span class="line">	private MessageServiceInjector injector;</span><br><span class="line">	@Before</span><br><span class="line">	public void setUp()&#123;</span><br><span class="line">		//mock the injector with anonymous class</span><br><span class="line">		injector = new MessageServiceInjector() &#123;</span><br><span class="line">			</span><br><span class="line">			@Override</span><br><span class="line">			public Consumer getConsumer() &#123;</span><br><span class="line">				//mock the message service</span><br><span class="line">				return new MyDIApplication(new MessageService() &#123;</span><br><span class="line">					</span><br><span class="line">					@Override</span><br><span class="line">					public void sendMessage(String msg, String rec) &#123;</span><br><span class="line">						System.out.println(&quot;Mock Message Service implementation&quot;);</span><br><span class="line">						</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		Consumer consumer = injector.getConsumer();</span><br><span class="line">		consumer.processMessages(&quot;Hi Pankaj&quot;, &quot;pankaj@abc.com&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@After</span><br><span class="line">	public void tear()&#123;</span><br><span class="line">		injector = null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如您所看到的，我正在使用匿名类来模拟注入器和服务类，并且我可以轻松地测试我的应用程序方法。</p>
<p>我们已经使用构造函数注入应用程序类中的依赖项，另一种方法是使用setter方法注入应用程序类中的依赖项。对于setter方法依赖注入，我们的应用程序类将实现如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.consumer;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.service.MessageService;</span><br><span class="line"></span><br><span class="line">public class MyDIApplication implements Consumer&#123;</span><br><span class="line"></span><br><span class="line">	private MessageService service;</span><br><span class="line">	</span><br><span class="line">	public MyDIApplication()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	//setter dependency injection	</span><br><span class="line">	public void setService(MessageService service) &#123;</span><br><span class="line">		this.service = service;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void processMessages(String msg, String rec)&#123;</span><br><span class="line">		//do some msg validation, manipulation logic etc</span><br><span class="line">		this.service.sendMessage(msg, rec);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.java.dependencyinjection.injector;</span><br><span class="line"></span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.Consumer;</span><br><span class="line">import com.journaldev.java.dependencyinjection.consumer.MyDIApplication;</span><br><span class="line">import com.journaldev.java.dependencyinjection.service.EmailServiceImpl;</span><br><span class="line"></span><br><span class="line">public class EmailServiceInjector implements MessageServiceInjector &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Consumer getConsumer() &#123;</span><br><span class="line">		MyDIApplication app = new MyDIApplication();</span><br><span class="line">		app.setService(new EmailServiceImpl());</span><br><span class="line">		return app;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setter依赖注入的最佳示例之一是Struts2 Servlet API感知接口。</p>
<p>使用基于构造函数的依赖注入还是基于setter是一个设计决策，这取决于您的需求。例如，如果我的应用程序在没有服务类的情况下无法工作，那么我更喜欢基于构造函数的DI，否则我将使用基于DI的setter方法，只在真正需要时才使用它。</p>
<p>Java中的依赖注入是通过将对象绑定从编译时移动到运行时来实现应用程序中的控制反转(IoC)的一种方法。通过工厂模式、模板方法设计模式、策略模式和服务定位模式来实现IoC。</p>
<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/2410/spring-dependency-injection">Spring依赖项注入</a>、<a target="_blank" rel="noopener" href="https://www.journaldev.com/2403/google-guice-dependency-injection-example-tutorial">谷歌Guice</a>和Java EE CDI框架通过使用Java反射API和Java注解简化了依赖项注入的过程。我们只需要注解字段、构造函数或setter方法，并在配置xml文件或类中配置它们。</p>
<h2 id="Advantages-2"><a href="#Advantages-2" class="headerlink" title="Advantages"></a>Advantages</h2><ul>
<li>Separation of Concerns(关注点分离)</li>
<li>在应用程序类中减少样板代码，因为初始化依赖项的所有工作都由注入器组件处理</li>
<li>可配置组件使应用程序易于扩展</li>
<li>使用模拟对象进行单元测试很容易</li>
</ul>
<h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h2><ul>
<li>如果过度使用，可能会导致维护问题，因为更改的效果在运行时是已知的。</li>
<li>java中的依赖项注入隐藏了服务类依赖项，这些依赖项可能导致在编译时捕获的运行时错误。</li>
</ul>
<h1 id="Lazy-Initialization-in-Java"><a href="#Lazy-Initialization-in-Java" class="headerlink" title="Lazy Initialization in Java"></a>Lazy Initialization in Java</h1><h2 id="What-is-Lazy-Initialization"><a href="#What-is-Lazy-Initialization" class="headerlink" title="What is Lazy Initialization?"></a>What is Lazy Initialization?</h2><p>在计算机编程中，延迟初始化是一种策略，它将对象的创建、值的计算或其他一些开销很大的进程延迟到第一次需要它的时候。它是一种惰性计算，在引用对象或其他比较大的资源实例化时使用。</p>
<p>延迟初始化通常是通过增加访问器方法(或属性的getter)来完成，检查充当缓存的私有成员是否已经初始化。如果有，则立即返回。如果没有，则创建一个新实例，将其放入成员变量中，并在第一次使用时及时返回给调用者。</p>
<p>如果对象具有很少使用的属性，这可以提高启动速度。这意味着对于平均性能可能稍差的程序,可以大大提高平均响应时间，因为对于对象实例化的影响是随实例化时间扩展（“摊销”）的而不是集中在系统的启动阶段。</p>
<p>在多线程代码中，必须同步对延迟初始化对象/状态的访问以防止竞争条件。</p>
<p>在软件设计模式中，延迟初始化通常与工厂方法模式一起使用。这其中结合了三种设计模式：</p>
<ul>
<li>使用工厂方法创建类的实例(factory method pattern)</li>
<li>将实例存储在Map中，并将相同的实例返回给具有相同参数的实例的请求(multiton pattern)</li>
<li>在第一次请求对象时使用延迟初始化来实例化它(lazy initialization pattern)</li>
</ul>
<h2 id="Usage-6"><a href="#Usage-6" class="headerlink" title="Usage"></a>Usage</h2><p>延迟初始化的使用主要分为两种：</p>
<ul>
<li>Lazy class loading (延迟类加载)</li>
<li>Lazy object creation (延迟对象创建)</li>
</ul>
<h3 id="Lazy-class-loading"><a href="#Lazy-class-loading" class="headerlink" title="Lazy class loading"></a>Lazy class loading</h3><p>Java运行时内置了类的延迟实例化。类只有在第一次引用时才加载到内存中。(它们也可以首先通过HTTP从Web服务器加载。)</p>
<p>延迟类加载是Java运行时环境的一个重要特性，因为它可以在某些情况下减少内存使用。例如，如果一个程序的某个部分从来没有在一个会话期间执行过，那么只在该部分中引用的类将永远不会被加载。</p>
<h3 id="Lazy-object-creation"><a href="#Lazy-object-creation" class="headerlink" title="Lazy object creation"></a>Lazy object creation</h3><p>延迟对象创建与延迟类加载紧密耦合。第一次在以前未加载的类类型上使用new关键字时，Java运行时将为您加载它。与延迟类加载相比，延迟对象创建可以在更大程度上减少内存使用。</p>
<p>为了介绍延迟对象创建的概念，让我们看一个简单的代码示例，其中一个框架使用一个MessageBox来显示错误消息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyFrame extends Frame</span><br><span class="line">&#123;</span><br><span class="line">  private MessageBox mb_ = new MessageBox();</span><br><span class="line">  //private helper used by this class</span><br><span class="line">  private void showMessage(String message)</span><br><span class="line">  &#123;</span><br><span class="line">    //set the message text</span><br><span class="line">    mb_.setMessage( message );</span><br><span class="line">    mb_.pack();</span><br><span class="line">    mb_.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，当创建MyFrame的一个实例时，MessageBox实例mb_也会被创建。递归应用相同的规则。因此，在类MessageBox的构造函数中初始化或分配的任何实例变量也会从堆中分配，等等。如果MyFrame的实例没有用于在会话中显示错误消息，那么我们就是在不必要地浪费内存。</p>
<p>在这个相当简单的例子中，我们不会得到太多。但是，如果您考虑一个更复杂的类，它使用许多其他类，而其他类又递归地使用和实例化更多的对象，那么潜在的内存使用就更明显了。</p>
<h3 id="将延迟实例化视为减少资源需求的策略"><a href="#将延迟实例化视为减少资源需求的策略" class="headerlink" title="将延迟实例化视为减少资源需求的策略"></a>将延迟实例化视为减少资源需求的策略</h3><p>下面列出了上述示例的惰性方法，其中在第一次调用showMessage()时实例化了对象mb_。(也就是说，直到程序真正需要它的时候。)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class MyFrame extends Frame</span><br><span class="line">&#123;</span><br><span class="line">  private MessageBox mb_ ; //null, implicit</span><br><span class="line">  //private helper used by this class</span><br><span class="line">  private void showMessage(String message)</span><br><span class="line">  &#123;</span><br><span class="line">    if(mb_==null)//first call to this method</span><br><span class="line">      mb_=new MessageBox();</span><br><span class="line">    //set the message text</span><br><span class="line">    mb_.setMessage( message );</span><br><span class="line">    mb_.pack();</span><br><span class="line">    mb_.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仔细查看showMessage()，您将看到我们首先确定实例变量mb_是否等于null。由于我们还没有在声明时初始化mb_，所以Java运行时已经为我们处理了这个问题。因此，我们可以安全地继续创建MessageBox实例。将来对showMessage()的所有调用都将发现mb_不等于null，因此跳过对象的创建并使用现有实例。</p>
<h2 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h2><p>假设客户机要求我们编写一个系统，该系统将允许用户对文件系统上的图像进行编目，并提供查看缩略图或完整图像的功能。我们的第一个尝试可能是编写一个在构造函数中加载映像的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ImageFile</span><br><span class="line">&#123;</span><br><span class="line">  private String filename_;</span><br><span class="line">  private Image image_;</span><br><span class="line">  public ImageFile(String filename)</span><br><span class="line">  &#123;</span><br><span class="line">    filename_=filename;</span><br><span class="line">    //load the image</span><br><span class="line">  &#125;</span><br><span class="line">  public String getName()&#123; return filename_;&#125;</span><br><span class="line">  public Image getImage()</span><br><span class="line">  &#123;</span><br><span class="line">    return image_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，ImageFile实现了一种过度热切的方法来实例化Image对象。对它有利的是，这种设计保证了在调用getImage()时可以立即获得图像。然而，这不仅会非常缓慢(对于包含许多映像的目录)，而且这种设计可能会耗尽可用内存。为了避免这些潜在的问题，我们可以用即时访问的性能优势来换取更少的内存使用。正如您可能已经猜到的，我们可以通过使用惰性实例化来实现这一点。</p>
<p>下面是更新后的ImageFile类，使用的方法与MyFrame类处理其MessageBox实例变量的方法相同:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ImageFile</span><br><span class="line">&#123;</span><br><span class="line">  private String filename_;</span><br><span class="line">  private Image image_; //=null, implicit</span><br><span class="line">  public ImageFile(String filename)</span><br><span class="line">  &#123;</span><br><span class="line">    //only store the filename</span><br><span class="line">    filename_=filename;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getName()&#123; return filename_;&#125;</span><br><span class="line">  public Image getImage()</span><br><span class="line">  &#123;</span><br><span class="line">    if(image_==null)</span><br><span class="line">    &#123;</span><br><span class="line">      //first call to getImage()</span><br><span class="line">      //load the image...</span><br><span class="line">    &#125;</span><br><span class="line">    return image_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个版本中，实际的映像只在第一次调用getImage()时加载。总而言之，这里的权衡是为了减少总体内存使用和启动时间，我们要为在第一次请求时加载映像付出代价——在程序执行的那个点引入性能冲击。这是在需要限制内存使用的上下文中反映代理模式的另一种习惯用法。</p>
<p>上面所示的延迟实例化策略对于我们的示例来说很好，但是稍后您将看到设计如何在多线程上下文中进行更改。</p>
<h3 id="Java中单例模式的延迟实例化"><a href="#Java中单例模式的延迟实例化" class="headerlink" title="Java中单例模式的延迟实例化"></a>Java中单例模式的延迟实例化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton</span><br><span class="line">&#123;</span><br><span class="line">  private Singleton() &#123;&#125;</span><br><span class="line">  static private Singleton instance_ = new Singleton();</span><br><span class="line">  static public Singleton instance()</span><br><span class="line">  &#123;</span><br><span class="line">    return instance_;</span><br><span class="line">  &#125;</span><br><span class="line">  //public methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在泛型版本中，我们声明并初始化instance_字段如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final Singleton instance_ = new Singleton();</span><br></pre></td></tr></table></figure>

<p>使用延迟实例化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton instance()</span><br><span class="line">&#123;</span><br><span class="line">  if(instance_==null) //Lazy instantiation</span><br><span class="line">    instance_= new Singleton();</span><br><span class="line">  return instance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的清单是GoF给出的c++单例的一个直接端口，通常也被吹捧为通用Java版本。如果您已经熟悉这个表单，并且对我们没有像这样列出泛型单例感到惊讶，那么当您了解到在Java中完全没有必要这样做时，您会更加惊讶!这是一个常见的例子，说明如果您将代码从一种语言移植到另一种语言，而不考虑各自的运行时环境，会发生什么情况。</p>
<p>需要说明的是，GoF c++版本的Singleton使用了延迟实例化，因为不能保证在运行时静态初始化对象的顺序。(参见Scott Meyer的Singleton了解c++中的另一种方法)。在Java中，我们不必担心这些问题。</p>
<p>在Java中，由于Java运行时处理类加载和静态实例变量初始化的方式，没有必要使用惰性的方法实例化单例。在前面，我们描述了如何以及何时加载类。只有公共静态方法的类在第一次调用这些方法时由Java运行时加载;单例的情况是什么呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton s=Singleton.instance();</span><br></pre></td></tr></table></figure>

<p>程序中对Singleton.instance()的第一个调用强制Java运行时加载单例类。由于字段instance_被声明为静态的，Java运行时将在成功加载该类之后初始化它。因此，确保对Singleton.instance()的调用将返回一个完全初始化的Singleton。</p>
<h3 id="延迟实例化：多线程应用程序中存在危险"><a href="#延迟实例化：多线程应用程序中存在危险" class="headerlink" title="延迟实例化：多线程应用程序中存在危险"></a>延迟实例化：多线程应用程序中存在危险</h3><p>对于具体的单例，使用延迟实例化不仅在Java中是不必要的，在多线程应用程序的上下文中也是非常危险的。考虑Singleton.instance()方法的延迟版本，其中两个或多个单独的线程试图通过instance()获得对对象的引用。如果一个线程在成功执行If (instance_==null)行之后被抢占，但是在它完成instance_=new Singleton()行之前，另一个线程也可以使用instance_ still ==null()来输入这个方法，这很糟糕!</p>
<p>这个场景的结果是创建一个或多个单例对象的可能性。当单例类连接到数据库或远程服务器时，这是一个令人头痛的问题。解决这个问题的简单方法是使用synchronized关键字来保护方法不被多个线程同时进入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized static public instance() &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>但是，对于广泛使用单例类的大多数多线程应用程序来说，这种方法有些笨拙，因此会阻塞对instance()的并发调用。顺便说一下，调用同步方法总是比调用非同步方法慢得多。所以我们需要的是一种同步策略，它不会导致不必要的阻塞。幸运的是，这样的策略是存在的。它被称为双重检查习语。</p>
<h3 id="双重检查语法"><a href="#双重检查语法" class="headerlink" title="双重检查语法"></a>双重检查语法</h3><p>使用双重检查习惯用法来保护使用延迟实例化的方法。下面是如何用Java实现它:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton instance()</span><br><span class="line">&#123;</span><br><span class="line">  if(instance_==null) //don&#x27;t want to block here</span><br><span class="line">  &#123;</span><br><span class="line">    //two or more threads might be here!!!</span><br><span class="line">    synchronized(Singleton.class)</span><br><span class="line">    &#123;</span><br><span class="line">      //must check again as one of the</span><br><span class="line">      //blocked threads can still enter</span><br><span class="line">      if(instance_==null)</span><br><span class="line">        instance_= new Singleton();//safe</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return instance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有在构造单例之前多个线程调用instance()时，双重检查用法才会使用同步来提高性能。一旦对象被实例化，instance_就不再是==null，从而允许该方法避免阻塞并发调用者。</p>
<p>在Java中使用多个线程可能非常复杂。事实上，并发性的主题非常广泛，以至于Doug Lea写了一本关于它的书:Concurrent Programming in Java (Java并发编程)。</p>
<h1 id="Object-Pool-in-Java"><a href="#Object-Pool-in-Java" class="headerlink" title="Object Pool in Java"></a>Object Pool in Java</h1><h2 id="What-is-Object-Pool"><a href="#What-is-Object-Pool" class="headerlink" title="What is Object Pool?"></a>What is Object Pool?</h2><p>对象池模式是一种软件创建设计模式，用于初始化类实例的成本非常高的情况。基本上，对象池是包含一定数量对象的容器。因此，当从池中取出一个对象时，它将在池中不可用，直到它被放回。</p>
<p>对象池(也称为资源池)用于管理对象缓存。访问对象池的客户机可以通过简单地请求池提供一个已经实例化的对象来避免创建新对象。通常，池将是一个不断增长的池，也就是说，如果池为空，池本身将创建新对象，或者我们可以有一个池，它限制了创建的对象的数量。</p>
<p>最好将当前未使用的所有可重用对象保存在同一个对象池中，以便由一个一致的策略管理它们。为此，可重用池类被设计为单例类。</p>
<p>对象池允许其他人从其池中“check out”对象，当进程不再需要这些对象时，将它们返回到池中以便重用。</p>
<p>但是，我们不希望进程必须等待某个特定的对象被释放，因此对象池也会根据需要实例化新对象，但是还必须实现定期清理未使用对象的功能。</p>
<h2 id="Usage-7"><a href="#Usage-7" class="headerlink" title="Usage"></a>Usage</h2><p>连接池模式的一般思想是，如果类的实例可以重用，那么可以通过重用它们来避免创建类的实例。</p>
<p>通常，最好将当前未使用的所有可重用对象保存在同一个对象池中，以便由一个一致的策略管理它们。为了实现这一点，ReusablePool类被设计为一个单例类。它的构造函数是私有的，这迫使其他类调用它的getInstance方法来获取ReusablePool类的一个实例。</p>
<p>客户端对象在需要可重用对象时调用ReusablePool对象的acquirereavailable方法。ReusablePool对象维护可重用对象的集合。它使用可重用对象的集合来包含当前未使用的可重用对象池。</p>
<p>当调用acquirereavailable方法时，如果池中有任何可重用对象，则从池中删除可重用对象并返回它。如果池为空，则acquirereavailable方法将在可能的情况下创建可重用对象。如果acquirereavailable方法不能创建新的可重用对象，那么它将等待，直到将可重用对象返回到集合。</p>
<p>客户端对象在使用完可重用对象后，将可重用对象传递给ReusablePool对象的releasereavailable方法。releasereavailable方法将可重用对象返回给未使用的可重用对象池。</p>
<p>在对象池模式的许多应用程序中，有理由限制可能存在的可重用对象的总数。在这种情况下，创建可重用对象的ReusablePool对象负责创建的可重用对象数量不超过指定的最大数量。如果ReusablePool对象负责限制它们将创建的对象的数量，那么ReusablePool类将有一个方法来指定要创建的对象的最大数量。</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><p>对象池模式类似于办公室仓库。当一个新员工被雇佣时，办公室经理必须为他准备一个工作空间。她想知道办公室仓库里是否有备用设备。如果是，她就用它。如果没有，她就从亚马逊订购新设备。如果一名员工被解雇，他的设备就会被转移到仓库，在需要新的工作地点的时候就可以拿到仓库。</p>
<h3 id="Check-List"><a href="#Check-List" class="headerlink" title="Check List"></a>Check List</h3><ul>
<li>创建内部,带有私有对象数组的ObjectPool类</li>
<li>在ObjectPool类中创建获取和释放方法</li>
<li>确保ObjectPool是Singleton</li>
</ul>
<h3 id="Rules-of-thumb"><a href="#Rules-of-thumb" class="headerlink" title="Rules of thumb"></a>Rules of thumb</h3><ul>
<li>工厂方法模式可用于封装对象的创建逻辑。但是，对象池模式在创建对象之后并不管理它们，而是跟踪它创建的对象。</li>
<li>对象池通常实现为单例。</li>
</ul>
<h3 id="Use-in-Java"><a href="#Use-in-Java" class="headerlink" title="Use in Java"></a>Use in Java</h3><p>ObjectPool Class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ObjectPool&lt;T&gt; &#123;</span><br><span class="line">  private long expirationTime;</span><br><span class="line"></span><br><span class="line">  private Hashtable&lt;T, Long&gt; locked, unlocked;</span><br><span class="line"></span><br><span class="line">  public ObjectPool() &#123;</span><br><span class="line">    expirationTime = 30000; // 30 seconds</span><br><span class="line">    locked = new Hashtable&lt;T, Long&gt;();</span><br><span class="line">    unlocked = new Hashtable&lt;T, Long&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract T create();</span><br><span class="line"></span><br><span class="line">  public abstract boolean validate(T o);</span><br><span class="line"></span><br><span class="line">  public abstract void expire(T o);</span><br><span class="line"></span><br><span class="line">  public synchronized T checkOut() &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    T t;</span><br><span class="line">    if (unlocked.size() &gt; 0) &#123;</span><br><span class="line">      Enumeration&lt;T&gt; e = unlocked.keys();</span><br><span class="line">      while (e.hasMoreElements()) &#123;</span><br><span class="line">        t = e.nextElement();</span><br><span class="line">        if ((now - unlocked.get(t)) &gt; expirationTime) &#123;</span><br><span class="line">          // object has expired</span><br><span class="line">          unlocked.remove(t);</span><br><span class="line">          expire(t);</span><br><span class="line">          t = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          if (validate(t)) &#123;</span><br><span class="line">            unlocked.remove(t);</span><br><span class="line">            locked.put(t, now);</span><br><span class="line">            return (t);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // object failed validation</span><br><span class="line">            unlocked.remove(t);</span><br><span class="line">            expire(t);</span><br><span class="line">            t = null;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // no objects available, create a new one</span><br><span class="line">    t = create();</span><br><span class="line">    locked.put(t, now);</span><br><span class="line">    return (t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void checkIn(T t) &#123;</span><br><span class="line">    locked.remove(t);</span><br><span class="line">    unlocked.put(t, System.currentTimeMillis());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//The three remaining methods are abstract </span><br><span class="line">//and therefore must be implemented by the subclass</span><br><span class="line"></span><br><span class="line">public class JDBCConnectionPool extends ObjectPool&lt;Connection&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private String dsn, usr, pwd;</span><br><span class="line"></span><br><span class="line">  public JDBCConnectionPool(String driver, String dsn, String usr, String pwd) &#123;</span><br><span class="line">    super();</span><br><span class="line">    try &#123;</span><br><span class="line">      Class.forName(driver).newInstance();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    this.dsn = dsn;</span><br><span class="line">    this.usr = usr;</span><br><span class="line">    this.pwd = pwd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected Connection create() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return (DriverManager.getConnection(dsn, usr, pwd));</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      return (null);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void expire(Connection o) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      ((Connection) o).close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean validate(Connection o) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return (!((Connection) o).isClosed());</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      return (false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBCConnectionPool将允许应用程序借用和返回数据库连接:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">  public static void main(String args[]) &#123;</span><br><span class="line">    // Do something...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Create the ConnectionPool:</span><br><span class="line">    JDBCConnectionPool pool = new JDBCConnectionPool(</span><br><span class="line">      &quot;org.hsqldb.jdbcDriver&quot;, &quot;jdbc:hsqldb://localhost/mydb&quot;,</span><br><span class="line">      &quot;sa&quot;, &quot;secret&quot;);</span><br><span class="line"></span><br><span class="line">    // Get a connection:</span><br><span class="line">    Connection con = pool.checkOut();</span><br><span class="line"></span><br><span class="line">    // Use the connection</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Return the connection:</span><br><span class="line">    pool.checkIn(con);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Prototype-Pattern-in-Java"><a href="#Prototype-Pattern-in-Java" class="headerlink" title="Prototype Pattern in Java"></a>Prototype Pattern in Java</h1><h2 id="What-is-Prototype-Pattern"><a href="#What-is-Prototype-Pattern" class="headerlink" title="What is Prototype Pattern?"></a>What is Prototype Pattern?</h2><p>原型模式是软件开发中的一种创造性设计模式。当要创建的对象类型由一个原型实例决定时，将使用它，该原型实例被克隆以生成新的对象。此模式用于:</p>
<ul>
<li>避免在客户端应用程序中使用对象创建者的子类，就像工厂方法模式。</li>
<li>避免以标准方式(例如，使用“new”关键字)创建新对象的固有成本，因为它对于给定的应用程序来说非常昂贵。</li>
</ul>
<p>要实现此模式，请声明一个抽象基类，该类指定一个pure virtual clone()方法。任何需要“多态构造函数”功能的类都从抽象基类派生自己，并实现clone()操作。</p>
<p>客户端没有编写代码来调用硬编码类名上的“new”操作符，而是在原型上调用clone()方法，使用指定所需的特定具体派生类的参数调用工厂方法，或者通过另一种设计模式提供的某种机制调用clone()方法。</p>
<p>一个细胞的有丝分裂——导致两个相同的细胞——是一个原型的一个例子，它在复制自身中起着积极的作用，因此，展示了原型模式。当一个细胞分裂时，会产生两个基因型相同的细胞。换句话说，细胞克隆自己。</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h2><p>Prototype模式提供了一种机制，可以将原始对象复制到新对象，然后根据我们的需要对其进行修改。原型设计模式使用java克隆来复制对象。</p>
<p>通过一个实例，可以很容易地理解原型设计模式。假设我们有一个从数据库加载数据的对象。现在我们需要在程序中多次修改该数据，因此使用new关键字创建对象并再次从数据库加载所有数据不是一个好主意。</p>
<p>更好的方法是将现有对象克隆到一个新对象中，然后进行数据操作。</p>
<p>原型设计模式要求您复制的对象应该提供复制特性。它不应该由任何其他类来完成。然而，是否使用对象属性的浅拷贝或深拷贝取决于需求及其设计决策。</p>
<p>下面是一个示例程序，展示了java中的原型设计模式示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.journaldev.design.prototype;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Employees implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">	private List&lt;String&gt; empList;</span><br><span class="line">	</span><br><span class="line">	public Employees()&#123;</span><br><span class="line">		empList = new ArrayList&lt;String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Employees(List&lt;String&gt; list)&#123;</span><br><span class="line">		this.empList=list;</span><br><span class="line">	&#125;</span><br><span class="line">	public void loadData()&#123;</span><br><span class="line">		//read all employees from database and put into the list</span><br><span class="line">		empList.add(&quot;Pankaj&quot;);</span><br><span class="line">		empList.add(&quot;Raj&quot;);</span><br><span class="line">		empList.add(&quot;David&quot;);</span><br><span class="line">		empList.add(&quot;Lisa&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public List&lt;String&gt; getEmpList() &#123;</span><br><span class="line">		return empList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object clone() throws CloneNotSupportedException&#123;</span><br><span class="line">			List&lt;String&gt; temp = new ArrayList&lt;String&gt;();</span><br><span class="line">			for(String s : this.getEmpList())&#123;</span><br><span class="line">				temp.add(s);</span><br><span class="line">			&#125;</span><br><span class="line">			return new Employees(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，重写clone方法以提供员工列表的副本。</p>
<p>下面的原型设计模式示例测试程序将展示原型模式的好处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import com.journaldev.design.prototype.Employees;</span><br><span class="line"></span><br><span class="line">public class PrototypePatternTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">		Employees emps = new Employees();</span><br><span class="line">		emps.loadData();</span><br><span class="line">		</span><br><span class="line">		//Use the clone method to get the Employee object</span><br><span class="line">		Employees empsNew = (Employees) emps.clone();</span><br><span class="line">		Employees empsNew1 = (Employees) emps.clone();</span><br><span class="line">		List&lt;String&gt; list = empsNew.getEmpList();</span><br><span class="line">		list.add(&quot;John&quot;);</span><br><span class="line">		List&lt;String&gt; list1 = empsNew1.getEmpList();</span><br><span class="line">		list1.remove(&quot;Pankaj&quot;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;emps List: &quot;+emps.getEmpList());</span><br><span class="line">		System.out.println(&quot;empsNew List: &quot;+list);</span><br><span class="line">		System.out.println(&quot;empsNew1 List: &quot;+list1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有提供对象克隆，那么每次都必须调用数据库来获取employee列表。然后做一些需要耗费资源和时间的操作。</p>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>design_patterns : <a target="_blank" rel="noopener" href="https://sourcemaking.com/design_patterns">https://sourcemaking.com/design_patterns</a></li>
<li>geeksforgeeks : <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/object-pool-design-pattern">https://www.geeksforgeeks.org/object-pool-design-pattern</a></li>
<li>wiki-Software design pattern : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_design_pattern">https://en.wikipedia.org/wiki/Software_design_pattern</a></li>
<li>journaldev : <a target="_blank" rel="noopener" href="https://www.journaldev.com/1827/java-design-patterns-example-tutorial">https://www.journaldev.com/1827/java-design-patterns-example-tutorial</a></li>
<li>tutorialspoint : <a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/design_pattern/index.htm">https://www.tutorialspoint.com/design_pattern/index.htm</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2018/12/27/JavaDesignPatterns-Creational/" data-id="ckvgcipjh000qplqhc10dfl1x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/creational/" rel="tag">creational</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/design-patterns/" rel="tag">design patterns</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaVersionCharacter10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/25/JavaVersionCharacter10/" class="article-date">
  <time datetime="2018-12-25T07:37:37.000Z" itemprop="datePublished">2018-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/25/JavaVersionCharacter10/">Java10 版本特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为当今使用最广泛的编程语言之一的 Java 在 2018 年 3 月 21 日发布了第十个大版本。为了更快地迭代、更好地跟进社区反馈，Java 语言版本发布周期调整为每隔 6 个月发布一次。Java 10 是这一新规则之后，采用新发布周期的第一个大版本。</p>
<h1 id="长期支持模型"><a href="#长期支持模型" class="headerlink" title="长期支持模型"></a>长期支持模型</h1><p>从2017年开始，甲骨文和Java社区宣布将向Java推出新的6个月节奏。它转向了Oracle Java SE产品的长期支持（LTS）模型。</p>
<p>LTS版本的产品将提供Oracle的主要和持续支持，并将每3年定位一次。</p>
<h2 id="Oracle-JDK-vs-Open-JDK"><a href="#Oracle-JDK-vs-Open-JDK" class="headerlink" title="Oracle JDK vs Open JDK"></a>Oracle JDK vs Open JDK</h2><p>为了更加开发人员友好，Oracle和Java社区现在将OpenJDK二进制文件作为主要JDK推进。从早期开始，这是一个很大的缓解，其中JDK二进制文件是适当的并且由Oracle授权，Oracle在重新分发方面有各种限制。然而，Oracle将继续生产他们的JDK，但仅限于长期支持版本。这是一个向更多云和容器友好的方向，因为开放的JDK二进制文件可以作为容器的一部分进行分发。</p>
<p>Open JDK二进制文件将每6个月发布一次，而Oracle JDK二进制文件将每3年发布一次（LTS版本）。</p>
<p>Java 9和10是非LTS版本。将于2018年9月发布的Java 11将是LTS版本。</p>
<h2 id="JCP"><a href="#JCP" class="headerlink" title="JCP"></a>JCP</h2><p>JCP（Java Community Process）成立于1998年，是使有兴趣的各方参与定义Java的特征和未来版本的正式过程。</p>
<p>JCP使用JSR（Java规范请求，Java Specification Requests）作为正式规范文档，描述被提议加入到Java体系中的的规范和技术。</p>
<p>JSR变为final状态前需要正式的公开审查，并由JCP Executive Committee投票决定。最终的JSR会提供一个参考实现，它是免费而且公开源代码的；还有一个验证是否符合API规范的Technology Compatibility Kit。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JCP">详情</a></p>
<h2 id="JEP"><a href="#JEP" class="headerlink" title="JEP"></a>JEP</h2><p>JEP(JDK Enhancement Proposal，改善提议) 是JDK发布项目及相关工作的长期路线图。</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/1">详情</a></p>
<h1 id="局部变量类型推断-JEP-286"><a href="#局部变量类型推断-JEP-286" class="headerlink" title="局部变量类型推断(JEP 286)"></a>局部变量类型推断(JEP 286)</h1><h2 id="What-is-Local-Variable-Type-Inference"><a href="#What-is-Local-Variable-Type-Inference" class="headerlink" title="What is Local-Variable Type Inference?"></a><strong>What is Local-Variable Type Inference?</strong></h2><p>局部变量类型推断(Local-Variable Type Inference)是 Java 10 中最值得开发人员注意的新特性，这是 Java 语言开发人员为了简化 Java 应用程序的编写而进行的又一重要改进。</p>
<p>这一新功能将为 Java 增加一些新语法，允许开发人员省略通常不必要的局部变量类型初始化声明。新的语法将减少 Java 代码的冗长度，同时保持对静态类型安全性的承诺。局部变量类型推断主要是向 Java 语法中引入在其他语言（比如 C#、JavaScript）中很常见的保留类型名称 var。但需要特别注意的是：var 不是一个关键字，而是一个保留字。只要编译器可以推断此种类型，开发人员不再需要专门声明一个局部变量的类型，也就是可以随意定义变量而不必指定变量的类型。这种改进对于链式表达式来说，也会很方便。</p>
<p>虽然变量类型的推断在 Java 中不是一个崭新的概念，但在局部变量中确是很大的一个改进。说到变量类型推断，从 Java 5 中引进泛型，到 Java 7 的 &lt;&gt; 操作符允许不绑定类型而初始化 List，再到 Java 8 中的 Lambda 表达式，再到现在 Java 10 中引入的局部变量类型推断，Java 类型推断正大刀阔斧地向前进步、发展。</p>
<p>但这种 var 变量类型推断的使用也有局限性，仅局限于具有初始化器的局部变量、增强型 for 循环中的索引变量以及在传统 for 循环中声明的局部变量，而不能用于推断方法的参数类型，不能用于构造函数参数类型推断，不能用于推断方法返回类型，也不能用于字段类型推断，同时还不能用于捕获表达式（或任何其他类型的变量声明）。</p>
<p>不过对于开发者而言，变量类型显式声明会提供更加全面的程序语言信息，对于理解和维护代码有很大的帮助。Java 10 中新引入的局部变量类型推断能够帮助我们快速编写更加简洁的代码，但是局部变量类型推断的保留字 var 的使用势必会引起变量类型可视化缺失，并不是任何时候使用 var 都能容易、清晰的分辨出变量的类型。一旦 var 被广泛运用，开发者在没有 IDE 的支持下阅读代码，势必会对理解程序的执行流程带来一定的困难。所以还是建议尽量显式定义变量类型，在保持代码简洁的同时，也需要兼顾程序的易读性、可维护性。</p>
<p>局部变量类型推断只能在以下场景中使用：</p>
<ul>
<li>仅限于具有初始化程序的本地变量</li>
<li>增强的for循环或索引的索引</li>
<li>本地声明为for循环</li>
</ul>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/286">JEP 286</a></p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a><strong>Usage</strong></h2><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var numbers = List.of(1, 2, 3, 4, 5); // inferred value ArrayList&lt;String&gt;</span><br><span class="line">// Index of Enhanced For Loop</span><br><span class="line">for (var number  - numbers) &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">// Local variable declared in a loop</span><br><span class="line">for (var i = 0; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">    System.out.println(numbers.get(i));</span><br><span class="line">&#125;</span><br><span class="line">var stream = numbers.stream();// Stream&lt;int&gt;</span><br></pre></td></tr></table></figure>

<p>具体用法实例</p>
<p><a target="_blank" rel="noopener" href="https://www.journaldev.com/19871/java-10-local-variable-type-inference">Java 10 - Local Variable Type Inference</a></p>
<h1 id="整合-JDK-代码仓库-JEP-296"><a href="#整合-JDK-代码仓库-JEP-296" class="headerlink" title="整合 JDK 代码仓库(JEP 296)"></a>整合 JDK 代码仓库(JEP 296)</h1><h2 id="What-is-Consolidate-the-JDK-Forest-into-a-Single-Repository"><a href="#What-is-Consolidate-the-JDK-Forest-into-a-Single-Repository" class="headerlink" title="What is Consolidate the JDK Forest into a Single Repository?"></a><strong>What is Consolidate the JDK Forest into a Single Repository?</strong></h2><p>为了简化开发流程，Java 10 中会将多个代码库合并到一个代码仓库中。</p>
<p>在已发布的 Java 版本中，JDK 的整套代码根据不同功能已被分别存储在多个 Mercurial 存储库，这八个 Mercurial 存储库分别是：root、corba、hotspot、jaxp、jaxws、jdk、langtools、nashorn。</p>
<p>虽然以上八个存储库之间相互独立以保持各组件代码清晰分离，但同时管理这些存储库存在许多缺点，并且无法进行相关联源代码的管理操作。其中最重要的一点是，涉及多个存储库的变更集无法进行原子提交 （atomic commit）。例如，如果一个 bug 修复时需要对独立存储两个不同代码库的代码进行更改，那么必须创建两个提交：每个存储库中各一个。这种不连续性很容易降低项目和源代码管理工具的可跟踪性和加大复杂性。特别是，不可能跨越相互依赖的变更集的存储库执行原子提交这种多次跨仓库的变化是常见现象。</p>
<p>为了解决这个问题，JDK 10 中将所有现有存储库合并到一个 Mercurial 存储库中。这种合并的一个次生效应是，单一的 Mercurial 存储库比现有的八个存储库要更容易地被镜像(作为一个 Git 存储库)，并且使得跨越相互依赖的变更集的存储库运行原子提交成为可能，从而简化开发和管理过程。虽然在整合过程中，外部开发人员有一些阻力，但是 JDK 开发团队已经使这一更改成为 JDK 10 的一部分。</p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/296">JEP 296</a></p>
<h1 id="统一的垃圾回收接口-JEP-304"><a href="#统一的垃圾回收接口-JEP-304" class="headerlink" title="统一的垃圾回收接口(JEP 304)"></a>统一的垃圾回收接口(JEP 304)</h1><h2 id="What-is-Garbage-Collector-Interface"><a href="#What-is-Garbage-Collector-Interface" class="headerlink" title="What is Garbage Collector Interface?"></a><strong>What is Garbage Collector Interface?</strong></h2><p>在当前的 Java 结构中，组成垃圾回收器（GC）实现的组件分散在代码库的各个部分。尽管这些惯例对于使用 GC 计划的 JDK 开发者来说比较熟悉，但对新的开发人员来说，对于在哪里查找特定 GC 的源代码，或者实现一个新的垃圾收集器常常会感到困惑。更重要的是，随着 Java modules 的出现，我们希望在构建过程中排除不需要的 GC，但是当前 GC 接口的横向结构会给排除、定位问题带来困难。</p>
<p>为解决此问题，需要整合并清理 GC 接口，以便更容易地实现新的 GC，并更好地维护现有的 GC。Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。这种方式提供了足够的灵活性来实现全新 GC 接口，同时允许以混合搭配方式重复使用现有代码，并且能够保持代码更加干净、整洁，便于排查收集器问题。</p>
<p>此更改为内部GC代码提供了更好的模块化。它将来有助于在不更改现有代码库的情况下添加新GC，也有助于删除或管理以前的GC。</p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/304">JEP 304</a></p>
<h1 id="并行全垃圾回收器-G1-JEP-307"><a href="#并行全垃圾回收器-G1-JEP-307" class="headerlink" title="并行全垃圾回收器 G1(JEP 307)"></a>并行全垃圾回收器 G1(JEP 307)</h1><h2 id="What-is-Parallel-Full-GC-for-G1"><a href="#What-is-Parallel-Full-GC-for-G1" class="headerlink" title="What is Parallel Full GC for G1?"></a><strong>What is Parallel Full GC for G1?</strong></h2><p>G1 是设计来作为一种低延时的垃圾回收器（但是如果它跟不上旧的堆碎片产生的提升速率的话，将仍然采用完整压缩集合）。在 JDK9 之前，默认的收集器是并行，吞吐，收集器。为了减少在使用默认的收集器的应用性能配置文件的差异，G1 现在有一个并行完整收集机制。</p>
<p>大家如果接触过 Java 性能调优工作，应该会知道，调优的最终目标是通过参数设置来达到快速、低延时的内存垃圾回收以提高应用吞吐量，尽可能的避免因内存回收不及时而触发的完整 GC（Full GC 会带来应用出现卡顿）。</p>
<p>G1 垃圾回收器是 Java 9 中 Hotspot 的默认垃圾回收器，是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC，但是当并发收集无法快速回收内存时，会触发垃圾回收器回退进行 Full GC。之前 Java 版本中的 G1 垃圾回收器执行 GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。</p>
<p>Java 10 中将采用并行化 mark-sweep-compact 算法，并使用与年轻代回收和混合回收相同数量的线程。具体并行 GC 线程数量可以通过：-XX：ParallelGCThreads 参数来调节，但这也会影响用于年轻代和混合收集的工作线程数。</p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/307">JEP 307</a></p>
<h1 id="应用程序类数据共享-JEP-310"><a href="#应用程序类数据共享-JEP-310" class="headerlink" title="应用程序类数据共享(JEP 310)"></a>应用程序类数据共享(JEP 310)</h1><h2 id="What-is-Application-Class-Data-Sharing"><a href="#What-is-Application-Class-Data-Sharing" class="headerlink" title="What is Application Class-Data Sharing?"></a><strong>What is Application Class-Data Sharing?</strong></h2><p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。简单来说，Java 安装程序会把 rt.jar 中的核心类提前转化成内部表示，转储到一个共享存档（shared archive）中。多个 Java 进程（或者说 JVM 实例）可以共享这部分数据。为改善启动和占用空间，Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。</p>
<p>CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。</p>
<p>其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。</p>
<p>可以想像为类似于操作系统的休眠过程，合上电脑时把当前应用环境写入磁盘，再次使用时就可以快速恢复环境。</p>
<p>对大型企业应用程序的内存使用情况的分析表明，此类应用程序通常会将数以万计的类加载到应用程序类加载器中，如果能够将 AppCDS 应用于这些应用，将为每个 JVM 进程节省数十乃至数百兆字节的内存。另外对于云平台上的微服务分析表明，许多服务器在启动时会加载数千个应用程序类，AppCDS 可以让这些服务快速启动并改善整个系统响应时间。</p>
<p>简单来说：应用程序数据共享，事通过跨进程共享通用类的元数据，减少空间占用及启动时长。</p>
<p>应用程序数据共享主要是为4个目的：</p>
<ul>
<li>通过在不同的Java进程间共享公共类元数据来减少占用空间。</li>
<li>改善启动时间。</li>
<li>扩展CDS以允许来自JDK运行时映像文件（比如，$JAVA_HOME/lib/modules）的归档类（archived classes）和应用程序class path加载到内置平台和系统类加载器（system class loader）中。</li>
<li>扩展CDS以允许将打包的classes加载到自定义class loader中。</li>
</ul>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/310">JEP 310</a></p>
<h1 id="线程-局部管控-JEP-312"><a href="#线程-局部管控-JEP-312" class="headerlink" title="线程-局部管控(JEP 312)"></a>线程-局部管控(JEP 312)</h1><h2 id="What-is-Thread-Local-Handshakes"><a href="#What-is-Thread-Local-Handshakes" class="headerlink" title="What is Thread-Local Handshakes?"></a><strong>What is Thread-Local Handshakes?</strong></h2><p>在已有的 Java 版本中，JVM 线程只能全部启用或者停止，没法做到对单独某个线程的操作。为了能够对单独的某个线程进行操作，Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程。通过这种方式显著地提高了现有 JVM 功能的性能开销，并且改变了到达 JVM 全局安全点的现有时间语义。</p>
<p>增加的参数为：-XX:ThreadLocalHandshakes (默认为开启)，将允许用户在支持的平台上选择安全点。</p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/312">JEP 312</a></p>
<h1 id="移除-Native-Header-自动生成工具-JEP-313"><a href="#移除-Native-Header-自动生成工具-JEP-313" class="headerlink" title="移除 Native-Header 自动生成工具(JEP 313)"></a>移除 Native-Header 自动生成工具(JEP 313)</h1><h2 id="Why-Remove-the-Native-Header-Generation-Tool"><a href="#Why-Remove-the-Native-Header-Generation-Tool" class="headerlink" title="Why Remove the Native-Header Generation Tool?"></a><strong>Why Remove the Native-Header Generation Tool?</strong></h2><p>自 Java 9 以来便开始了一些对 JDK 的调整，用户每次调用 javah 工具时会被警告该工具在未来的版本中将会执行的删除操作。当编译 JNI 代码时，已不再需要单独的 Native-Header 工具来生成头文件，因为这可以通过 Java 8（JDK-7150368）中添加的 javac 来完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还没有具体时间表。</p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/313">JEP 313</a></p>
<h1 id="额外的-Unicode-语言标签扩展-JEP-314"><a href="#额外的-Unicode-语言标签扩展-JEP-314" class="headerlink" title="额外的 Unicode 语言标签扩展(JEP 314)"></a>额外的 Unicode 语言标签扩展(JEP 314)</h1><h2 id="What-is-Additional-Unicode-Language-Tag-Extensions"><a href="#What-is-Additional-Unicode-Language-Tag-Extensions" class="headerlink" title="What is Additional Unicode Language-Tag Extensions?"></a><strong>What is Additional Unicode Language-Tag Extensions?</strong></h2><p>自 Java 7 开始支持 BCP 47 语言标记以来， JDK 中便增加了与日历和数字相关的 Unicode 区域设置扩展，在 Java 9 中，新增支持 ca 和 nu 两种语言标签扩展。而在 Java 10 中将继续增加 Unicode 语言标签扩展，具体为：增强 java.util.Locale 类及其相关的 API，以更方便的获得所需要的语言地域环境信息。同时在这次升级中还带来了如下扩展支持：</p>
<ul>
<li>cu - 货币类型</li>
<li>fw - 一周的第一天</li>
<li>rg - 区域覆盖</li>
<li>tz - 时区</li>
</ul>
<p>为了支持这些附加扩展，对各种API进行了更改，以便根据Unicode或其他扩展提供信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.text.DateFormat::get*Instance</span><br><span class="line">java.text.DateFormatSymbols::getInstance</span><br><span class="line">java.text.DecimalFormatSymbols::getInstance</span><br><span class="line">java.text.NumberFormat::get*Instance</span><br><span class="line">java.time.format.DateTimeFormatter::localizedBy</span><br><span class="line">java.time.format.DateTimeFormatterBuilder::getLocalizedDateTimePattern</span><br><span class="line">java.time.format.DecimalStyle::of</span><br><span class="line">java.time.temporal.WeekFields::of</span><br><span class="line">java.util.Calendar::&#123;getFirstDayOfWeek,getMinimalDaysInWeek&#125;</span><br><span class="line">java.util.Currency::getInstance</span><br><span class="line">java.util.Locale::getDisplayName</span><br><span class="line">java.util.spi.LocaleNameProvider</span><br></pre></td></tr></table></figure>

<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/314">JEP 314</a></p>
<h1 id="备用存储装置上的堆分配-JEP-316"><a href="#备用存储装置上的堆分配-JEP-316" class="headerlink" title="备用存储装置上的堆分配(JEP 316)"></a>备用存储装置上的堆分配(JEP 316)</h1><h2 id="What-is-Heap-Allocation-on-Alternative-Memory-Devices"><a href="#What-is-Heap-Allocation-on-Alternative-Memory-Devices" class="headerlink" title="What is Heap Allocation on Alternative Memory Devices?"></a><strong>What is Heap Allocation on Alternative Memory Devices?</strong></h2><p>随着便宜的NV-DIMM内存的普及，未来的系统可能配备异构内存架构。这种技术的一个例子是英特尔的3D XPoint。除DRAM之外，这样的架构将具有一种或多种具有不同特性的非DRAM存储器。这个JEP针对与DRAM具有相同语义的替代存储器设备，包括原子操作的语义，因此可以代替DRAM用于对象堆而不改变现有的应用程序代码。所有其他的内存结构，如代码堆，元代码空间，线程堆栈等，都将继续驻留在DRAM中。</p>
<p>一些操作系统中已经通过文件系统提供了使用非 DRAM 内存的方法。例如：NTFS DAX 模式和 ext4 DAX。这些文件系统中的内存映射文件可绕过页面缓存并提供虚拟内存与设备物理内存的相互映射。与 DRAM 相比，NV-DIMM 可能具有更高的访问延迟，低优先级进程可以为堆使用 NV-DIMM 内存，允许高优先级进程使用更多 DRAM。</p>
<p>在多JVM部署中，一些JVM（如守护进程，服务等）的优先级低于其他JVM。与DRAM相比，NV-DIMM可能具有更高的访问延迟。低优先级进程可以使用NV-DIMM内存作为堆，允许高优先级进程使用更多的DRAM。</p>
<p>大数据和内存数据库等应用程序对内存的需求不断增加。这种应用可以使用NV-DIMM作为堆，因为与DRAM相比，NV-DIMM有更大的容量，成本更低。</p>
<p>要在这样的备用设备上进行堆分配，可以使用堆分配参数 -XX：AllocateHeapAt = <path>，这个参数将指向文件系统的文件并使用内存映射来达到在备用存储设备上进行堆分配的预期结果。</p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/316">JEP 316</a></p>
<h1 id="基于-Java-的-实验性-JIT-编译器（试验版本）-JEP-317"><a href="#基于-Java-的-实验性-JIT-编译器（试验版本）-JEP-317" class="headerlink" title="基于 Java 的 实验性 JIT 编译器（试验版本）(JEP 317)"></a>基于 Java 的 实验性 JIT 编译器（试验版本）(JEP 317)</h1><h2 id="What-is-Experimental-Java-Based-JIT-Compiler"><a href="#What-is-Experimental-Java-Based-JIT-Compiler" class="headerlink" title="What is Experimental Java-Based JIT Compiler?"></a><strong>What is Experimental Java-Based JIT Compiler?</strong></h2><p>Java 10 中开启了基于 Java 的 JIT 编译器 Graal，并将其用作 Linux/x64 平台上的实验性 JIT 编译器开始进行测试和调试工作，另外 Graal 将使用 Java 9 中引入的 JVM 编译器接口（JVMCI）,基于Java的JIT编译器Graal是JDK 9中引入的实验性AOT（Ahead-of-Time）编译器的基础。</p>
<p>Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++实现的 C1 及 C2 相比，它的模块化更加明显，也更加容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现 AOT 编译。在 Java 10 中，Graal 作为试验性 JIT 编译器一同发布（JEP 317）。将 Graal 编译器研究项目引入到 Java 中，或许能够为 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。</p>
<p>Java 10 中默认情况下 HotSpot 仍使用的是 C2 编译器，要启用 Graal 作为 JIT 编译器，请在 Java 命令行上使用以下参数：</p>
<p><code>-XX：+ UnlockExperimentalVMOptions -XX：+ UseJVMCICompiler</code></p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/317">JEP 317</a></p>
<h1 id="根证书认证-JEP-319"><a href="#根证书认证-JEP-319" class="headerlink" title="根证书认证(JEP 319)"></a>根证书认证(JEP 319)</h1><h2 id="What-is-Root-Certificates"><a href="#What-is-Root-Certificates" class="headerlink" title="What is Root Certificates?"></a><strong>What is Root Certificates?</strong></h2><p>自 Java 9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 Java 9 中 cacerts 目录为空，这样就会给开发者带来很多不便。从 Java 10 开始，将会在 JDK 中提供一套默认的 CA 根证书。</p>
<p>作为 JDK 一部分的 cacerts 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。但是，JDK 源代码中的 cacerts 密钥库至目前为止一直是空的。因此，在 JDK 构建中，默认情况下，关键安全组件（如 TLS）是不起作用的。要解决此问题，用户必须使用一组根证书配置和 cacerts 密钥库下的 CA 根证书。</p>
<p>在 JDK 中将提供一套默认的 CA 根证书。关键的安全部件，如 TLS ，在 OpenJDK 构建中将默认有效。这是 Oracle 正在努力确保 OpenJDK 二进制和 Oracle JDK 二进制功能上一样的工作的一部分，是一项有用的补充内容。</p>
<p>详细相关JEP</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/319">JEP 319</a></p>
<h1 id="基于时间的版本发布模式"><a href="#基于时间的版本发布模式" class="headerlink" title="基于时间的版本发布模式"></a>基于时间的版本发布模式</h1><p>虽然 JEP 223中引入的版本字符串方案较以往有了显著的改进。但是，该方案并不适合以后严格按照六个月的节奏来发布 Java 新版本的这种情况。</p>
<p>按照 JEP 223 的语义中，每个基于 JDK 构建或使用组件的开发者（包括 JDK 的发布者）都必须提前敲定版本号，然后切换过去。开发人员则必须在代码中修改检查版本号的相关代码，这对所有参与者来说都很尴尬和混乱。</p>
<p>Java 10 中将重新编写之前 JDK 版本中引入的版本号方案，将使用基于时间模型定义的版本号格式来定义新版本。保留与 JEP 223 版本字符串方案的兼容性，同时也允许除当前模型以外的基于时间的发布模型。使开发人员或终端用户能够轻松找出版本的发布时间，以便开发人员能够判断是否将其升级到具有最新安全修补程序或可能的附加功能的新版本。</p>
<p>Oracle Java 平台组的首席架构师 Mark Reinhold 在博客上介绍了有关 Java 未来版本的一些想法（你能接受 Java 9 的下一个版本是 Java 18.3 吗？）。他提到，Java 计划按照时间来发布，每半年一个版本，而不是像之前那样按照重要特性来确定大版本，如果某个大的特性因故延期，这个版本可能一拖再拖。</p>
<p>当时，Mark 也提出来一种基于时间命名版本号的机制，比如下一个将于 2018 年 3 月发布的版本，就是 18.3，再下一个版本是 18.9，以后版本依此类推。</p>
<p>不过经过讨论，考虑和之前版本号的兼容等问题，最终选择的命名机制是：</p>
<p>$FEATURE.$INTERIM.$UPDATE.$PATCH</p>
<p>$FEATURE，每次版本发布加 1，不考虑具体的版本内容。2018 年 3 月的版本是 JDK 10，9 月的版本是 JDK 11，依此类推。</p>
<p>$INTERIM，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改。</p>
<p>“Feature releases” 版本将包含新特性，“Update releases” 版本仅修复 Bug</p>
<p>添加了新的API以编程方式获取这些版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Version version = Runtime.version();</span><br><span class="line">version.feature();</span><br><span class="line">version.interim();</span><br><span class="line">version.update();</span><br><span class="line">version.patch();</span><br></pre></td></tr></table></figure>

<h1 id="新-API"><a href="#新-API" class="headerlink" title="新 API"></a>新 API</h1><p>有 73 项新增内容添加到了标准类库中：</p>
<ul>
<li>java.awt.Toolkit int getMenuShortcutKeyMaskEx() - 确定哪个扩展修饰符键是菜单快捷键的适当加速键。</li>
<li>java.awt.geom.Path2D:void trimToSize() - 将此 Path2D 实例的容量计算到它当前的大小。应用可使用此操作将路径的存储空间最小化。这个方法也被添加到 Path2D.Double 和 Path2D.Float 类。</li>
<li>java.io.ByteArrayOutputStream:String toString(Charset) - 重载 toString()，通过使用指定的字符集解码字节，将缓冲区的内容转换为字符串。</li>
<li>java.io.PrintStream:lang.io.PrintWriter - 这两个类都有三个新的构造函数，它们需要额外的 Charset 参数。</li>
<li>java.io.Reader:long transferTo(Writer) - 从这个 Reader 中读取所有字符，并按照所读的顺序将字符写入给定的 Writer 。</li>
<li>java.lang.Runtime.Version - 有四种新方法返回新（JEP 322）版本字符串字段的整数值 - feature()、interim()、patch() 和 update() 。</li>
<li>java.lang.StackWalker.StackFrame:String getDescriptor() - 按照 JVM 标准返回此堆栈帧所代表的方法的描述符。</li>
<li>String getMethodType():返回此堆栈帧所代表的方法类型，描述参数类型和返回值类型。</li>
<li>java.lang.invoke.MethodType:Class&lt;?&gt; lastParameterType() - 返回这个方法类型的最后一个参数类型。如果这个方法类型没有参数，则返回空类型作为岗哨值（Sentinel Value）。</li>
<li>java.lang.management.RuntimeMXBean:long getPid() - 返回正在运行的 JVM 的进程 ID 。</li>
<li>java.lang.management.ThreadMXBean:ThreadInfo[] dumpAllThreads(boolean, boolean, int) - 返回所有活动线程的线程信息，其中有指定的最大元素数量和同步信息的堆栈跟踪。</li>
<li>ThreadInfo[] getThreadInfo(long[], boolean, boolean, int) - 返回每个线程的线程信息，这些线程的标识位于输入数组中，其中有指定的最大元素数量和同步信息的堆栈跟踪。</li>
<li>java.lang.reflect.MalformedParameterizedTypeException - 添加了一个新的构造函数，它以字符串的形式作为参数来获取详细信息。</li>
<li>java.net.URLDecoder:java.net.URLEncoder - 这两个类都有新的重载的解码和编码方法，将 charset 作为附加参数。</li>
<li>java.nio.channels.Channels - 两个新的静态重载方法，允许使用 Charset 的 newReader（ReadByteChannel，Charset）和newWriter（WriteByteChannel，Charset）。</li>
<li>java.nio.file.FileStore:long getBlockSize() - 在这个文件存储中返回每个块的字节数。</li>
<li>java.time.chrono - 这个包里有三个类，HijrahEra、MiinguoEra 和 ThaiBuddhistEra ，都有同样的方法。</li>
<li>String getDisplayName(TextStyle, Locale) - 这将返回用于识别 era 的文本名称，适合于向用户展示。</li>
<li>java.time.format.DateTimeFormatter:localizedBy(Locale) - 返回指定格式器的一个副本，其中包含地区、日历、区域、小数和/或时区的本地化值，这将取代该格式器中的值。</li>
<li>java.util - DoubleSummaryStatistics、IntSummaryStatistics 和 LongSummaryStatistics 都有一个新的构造函数，它包含 4 个数值。它使用指定的计数、最小值、最大值和总和构造一个非空实例。</li>
<li>java.util.List:java.util.Map:java.util.Set - 这些接口中的每一个都增加了一个新的静态方法，copyOf(Collection）。这些函数按照其迭代顺序返回一个不可修改的列表、映射或包含给定集合的元素的集合。</li>
<li>java.util.Optional:java.util.OptionalDouble:java.util.OptionalInt:java.util.OptionalLong - 每一个类都有一个新的方法，orElseThrow() ，它本质上和 get() 一样，也就是说，如果 Optional 有值则返回。否则，将抛出 NoSuchElementException 。</li>
<li>java.util.Formatter:java.util.Scanner - 这两个类都有三个新的构造函数，除了其他参数之外，它们都带有一个 charset 参数。</li>
<li>java.util.Properties - 这有一个新的构造函数，它接受一个 int 参数。这将创建一个没有默认值的空属性列表，并且指定初始大小以容纳指定的元素数量，而无需动态调整大小。还有一个新的重载的 replace 方法，接受三个 Object 参数并返回一个布尔值。只有在当前映射到指定值时，才会替换指定键的条目。</li>
<li>java.SplittableRandom:void nextBytes(byte[]) - 用生成的伪随机字节填充一个用户提供的字节数组。</li>
<li>java.util.concurrent.FutureTask - 添加了 toString() 方法，该方法返回一个标识 FutureTask 的字符串，以及它的完成状态。在括号中，状态包含如下字符串中的一个，“Completed Normally” 、“Completed Exceptionally”、 “Cancelled” 或者 “Not completed”。</li>
<li>java.util.concurrent.locks.StampedLock:boolean isLockStamp(long) - 返回一个标记戳表示是否持有一个锁。</li>
<li>boolean isOptimisticReadStamp(long) - 返回一个标记戳代表是否成功的进行了乐观读（optimistic read）。</li>
<li>boolean isReadLockStamp(long) - 返回一个标记戳表示是否持有一个非独占锁（即 read lock ）。</li>
<li>boolean isWriteLockStamp(long) - 返回一个标记戳表示是否持有一个独占锁（即 write lock ）。</li>
<li>java.jar.JarEntry:String getRealName() - 返回这个 JarEntry 的真实名称。如果这个 JarEntry 是一个多版本 jar 文件的入口，它被配置为这样处理，这个方法返回的名字是 JarEntry 所代表的版本条目的入口，而不是 ZipEntry.getName（） 返回的基本条目的路径名。如果 JarEntry 不代表一个多版本 jar 文件的版本化条目或者 jar 文件没有被配置为作为一个多版本 jar 文件进行处理，这个方法将返回与 ZipEntry.getName（） 返回的相同名称。</li>
<li>java.util.jar.JarFile:Stream<JarEntry> versionedStream() - 返回 jar 文件中指定版本的入口对应 Stream 。与 JarEntry 的 getRealName 方法类似，这与多版本 jar 文件有关。</li>
<li>java.util.spi.LocaleNameProvider:getDisplayUnicodeExtensionKey(String, Locale) - 为给定的 Unicode 扩展键返回一个本地化名称。</li>
<li>getDisplayUnicodeExtensionType(String, String, Locale) - 为给定的 Unicode 扩展键返回一个本地化名称。</li>
<li>java.util.stream.Collectors:toUnmodifiableList():toUnmodifiableSet():toUnmodifiableMap(Function, Function) - toUnmodifiableMap(Function, Function, BinaryOperator) - 这四个新方法都返回 Collectors ，将输入元素聚集到适当的不可修改的集合中。</li>
<li>java.lang.model.SourceVersion - 现在有了一个字段，它代表了 JDK 10 的版本。</li>
<li>java.lang.model.util.TypeKindVisitor6:javax.lang.model.util.TypeKindVisitor9:（我必须承认，我从来没听说过这些类）RevisitNoTypeAsModule(NoType, P) - 访问一个 MODULE 的 pseudo-type 。我不确定为什么只有这两个类得到这个方法，因为还有 Visitor7 和 Visitor8 变量。</li>
<li>javax.remote.management.rmi.RMIConnectorServer - 这个类已经添加了两个字段： CREDENTIALS_FILTER_PATTERN 和 SERIAL_FILTER_PATTERN 。</li>
<li>javax.ButtonModel - 看，Swing 还在更新！</li>
<li>ButtonGroup getGroup() - 返回按钮所属的组。通常用于单选按钮，它们在组中是互斥的。</li>
<li>javax.plaf.basic.BasicMenuUI:Dimension getMinimumSize(JComponent) - 返回指定组件适合观感的最小大小。</li>
</ul>
<h1 id="JVM-规范改动"><a href="#JVM-规范改动" class="headerlink" title="JVM 规范改动"></a>JVM 规范改动</h1><p>这些改动相当小：</p>
<ul>
<li>4.6节：类文件格式（第99页）。在方法访问标志方面有小的改动。</li>
<li>4.7节：模块属性（第169页）。如果模块不是 java.base ，则 JDK 10 不再允许设置 ACC_TRANSITIVE 或 ACC_STATIC_PHASE 。</li>
<li>4.10节：类文件的校验（第252页）。dup2 指令已改变了 typesafe form 1 的定义，颠倒了 canSafleyPushList 一节中类型的顺序（你需要仔细查看才能发现它）。</li>
<li>5.2节：Java 虚拟机启动（第350页）。该描述添加了在创建初始类或接口时可使用用户定义的类加载器（ bootstrap 类加载器除外）。</li>
</ul>
<h1 id="对-Java-语言规范的更改"><a href="#对-Java-语言规范的更改" class="headerlink" title="对 Java 语言规范的更改"></a>对 Java 语言规范的更改</h1><p>这里还有一些更改，但主要是为了支持局部变量类型推断。</p>
<ul>
<li>第3.8节：标识符（第23页）。在忽略了可忽略的字符之后，标识符的等价性现在被考虑了。这似乎是合乎逻辑的。</li>
<li>（第24页）一个新的 Token，TypeIdentifier，它支持对局部变量类型推断的新用法，而 var 的使用不是关键字，而是一个具有特殊含义的标识符，作为局部变量声明的类型。</li>
<li>第4.10.5节：类型预测（第76页）。这是一个相当复杂的部分，它涉及到捕获变量、嵌套类以及如何使用局部变量类型推断。我建议你阅读规范中的这一部分，而不是试图解释它。</li>
<li>第6.1节：声明（第134页）。一个反映使用 TypeIdentifier 来支持局部变量类型的推断的小改动。</li>
<li>第6.5节：确定名字的含义（第153页，第158页和第159页）。根据类型标识符的使用而更改类类型。</li>
<li>第6.5.4.1:简单的 PackageOrTypeNames（第160页）</li>
<li>第6.5.4.2节：合规的 PackageOrTypeNames（第160页）。这两种方式都与使用 TypeIdentifier 有细微的变化。</li>
<li>第7.5.3:单静态导入声明（第191页）。这改变了导入具有相同名称的静态类型的规则。除非类型是相同的，否则这将成为一个错误，在这种情况下，重复被忽略。</li>
<li>第7.7.1:依赖（第198页）。如果你明确声明一个模块需要 java.base ，那在必要的关键字之后，你就不能再使用修饰符（例如静态）了。</li>
<li>第8部分：正式参数（第244页）。接收者参数可能只出现在一个实例方法的 formalparameters 列表，或者是一个内部类的构造函数中，其中内部类没有在静态上下文中声明。</li>
<li>第9.7.4节：注释可能出现的地方（第335页）。有一个与局部变量类型推断相关的变更。</li>
<li>第14.4部分：局部变量声明语句（第433页）。实现局部变量类型推断所需的大量更改。</li>
<li>第14节：增强的 for 语句（第455页）。这个结构已经更新，包括对局部变量类型推断的支持。</li>
<li>第14.20.3节:try-with-resources（474页）。这个结构已经更新，包括对局部变量类型推断的支持。</li>
</ul>
<p>最后，第 19 章有多处语法更新，反映了应更多使用 TypeIdentifier 类型标识符，而不仅仅是 Identifier 标识符，以支持局部变量类型推断。</p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul>
<li>如果 Kerberos 的配置文件 krb5.conf 包含一个 INCLUDEDIR 选项，那么在 INCLUDEDIR 这个目录下所有以 .conf 结尾的文件都会被默认加载进来。</li>
<li>以前版本中已经过期的 Java 的启动选项 -d32 和 –d64 在当前版本已经被移除。如果你在新的版本里仍然使用了这两个选项，JVM 将无法正常启动。</li>
<li>JDK10 支持 JDK9 中的新版本 Doclet，JDK6、JDK7、JDK8 中的 Doclet 版本都不再支持。</li>
<li>JDK10 重新启用了在 JDK9 中被不当过时的 newFactory() 方法。</li>
<li>JDK10 引入了一个新的 Javadoc 标签： {@summary…}，解决了以前版本无法生成 API 摘要的问题。</li>
<li>JDK10 去掉了 BiasedLockingStartupDelay 的 4 秒启动延时。</li>
<li>以下在 com.sun.security.auth 包中的过时的类在新版本中都已经被移除：</li>
<li><ul>
<li> PolicyFile</li>
</ul>
</li>
<li><ul>
<li>SolarisNumericGroupPrincipal</li>
</ul>
</li>
<li><ul>
<li>SolarisNumericUserPrincipal</li>
</ul>
</li>
<li><ul>
<li>X500Principal</li>
</ul>
</li>
<li><ul>
<li>SolarisLoginModule</li>
</ul>
</li>
<li><ul>
<li>SolarisSystem</li>
</ul>
</li>
<li>在 java.lang.SecurityManager 类中的以下属性和方法（从 JDK 1.2 就已经过时）终于被移除了：</li>
<li><ul>
<li>inCheck (属性)</li>
</ul>
</li>
<li><ul>
<li>getInCheck</li>
</ul>
</li>
<li><ul>
<li>classDepth</li>
</ul>
</li>
<li><ul>
<li>classLoaderDepth</li>
</ul>
</li>
<li><ul>
<li>currentClassLoader</li>
</ul>
</li>
<li><ul>
<li>currentLoadedClass</li>
</ul>
</li>
<li><ul>
<li>inClass</li>
</ul>
</li>
<li><ul>
<li>inClassLoader</li>
</ul>
</li>
<li>以下 java.lang.Runtime 类中已经被废弃的国际化方法在新版本被移除：</li>
<li><ul>
<li>getLocalizedInputStream</li>
</ul>
</li>
<li><ul>
<li>getLocalizedOutputStream</li>
</ul>
</li>
<li>以下废弃的 Hotspot –X 选项在新版本中被移除：-Xoss, -Xsqnopause, -Xoptimize, -Xboundthreads and –Xusealtsigs.</li>
<li>policytool 在新版本中被移除。</li>
<li>javadoc 工具在新版本中可以通过 –add-stylesheets 命令选项支持多个 stylesheets 。</li>
<li>新版本的 JVM 能够根据系统分配给当前 Docker 容器的 CPU 数和内存来配置线程池和 GC 机制，而不再是直接使用系统的 CPU 和内存。并且增加了三个更强大的命令选项：-XX:InitialRAMPercentage、-XX:MaxRAMPercentage 和 -XX:MinRAMPercentage 。</li>
<li>新版本增加了一个新的系统属性：jdk.disableLastUsageTracking。这个新增的属性就像它的名字一样，会禁用 JRE 的上一次使用跟踪。</li>
</ul>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>openjdk : <a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/jdk/10/">http://openjdk.java.net/projects/jdk/10/</a></li>
<li>ibm-developerworks : <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html</a></li>
<li>journaldev : <a target="_blank" rel="noopener" href="https://www.journaldev.com/20395/java-10-features">https://www.journaldev.com/20395/java-10-features</a></li>
<li>Java 10 docs : <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/10/">https://docs.oracle.com/javase/10/</a></li>
<li>Java 10 docs api : <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/10/docs/api/overview-summary.html">https://docs.oracle.com/javase/10/docs/api/overview-summary.html</a></li>
<li>oschina : <a target="_blank" rel="noopener" href="https://www.oschina.net/translate/109-new-features-in-jdk-10?lang=chs&amp;p=1">https://www.oschina.net/translate/109-new-features-in-jdk-10?lang=chs&amp;p=1</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2018/12/25/JavaVersionCharacter10/" data-id="ckvgcipjc000eplqh1tbx8l37" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java10/" rel="tag">java10</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaVersionCharacter9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/20/JavaVersionCharacter9/" class="article-date">
  <time datetime="2018-12-20T06:14:20.000Z" itemprop="datePublished">2018-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/20/JavaVersionCharacter9/">Java9 版本特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><h2 id="What-is-Module-system"><a href="#What-is-Module-system" class="headerlink" title="What is Module system?"></a><strong>What is Module system?</strong></h2><p>Java 平台模块系统，也就是 Project Jigsaw，把模块化开发实践引入到了 Java 平台中。在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。这对于目前流行的不可变基础设施的实践来说，镜像的大小的减少可以节省很多存储空间和带宽资源 。</p>
<p>模块就是代码和数据的封装体。模块的代码被组织成多个包，每个包中包含Java类和接口；模块的数据则包括资源文件和其他静态信息。</p>
<p>模块化开发的实践在软件开发领域并不是一个新的概念。Java 开发社区已经使用这样的模块化实践有相当长的一段时间。主流的构建工具，包括 Apache Maven 和 Gradle 都支持把一个大的项目划分成若干个子项目。子项目之间通过不同的依赖关系组织在一起。每个子项目在构建之后都会产生对应的 JAR 文件。 在 Java9 中 ，已有的这些项目可以很容易的升级转换为 Java 9 模块 ，并保持原有的组织结构不变。</p>
<p>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。这个文件由根目录中的源代码文件 module-info.java 编译而来。该模块声明文件可以描述模块的不同特征。模块声明文件中可以包含的内容如下：</p>
<ul>
<li>模块导出的包 - 使用 exports 可以声明模块对其他模块所导出的包。包中的 public 和 protected 类型，以及这些类型的 public 和 protected 成员可以被其他模块所访问。没有声明为导出的包相当于模块中的私有成员，不能被其他模块使用。</li>
<li>模块的依赖关系 - 使用 requires 可以声明模块对其他模块的依赖关系。使用 requires transitive 可 以把一个模块依赖声明为传递的。传递的模块依赖可以被依赖当前模块的其他模块所读取。 如果一个模块所导出的类型的型构中包含了来自它所依赖的模块的类型，那么对该模块的依赖应该声明为传递的。</li>
<li>服务的提供和使用 - 如果一个模块中包含了可以被 ServiceLocator 发现的服务接口的实现 ，需要使用 provides with 语句来声明具体的实现类 ；如果一个模块需要使用服务接口，可以使用 uses 语句来声明。</li>
</ul>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a><strong>Usage</strong></h2><p>模块声明示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module com.mycompany.sample &#123; </span><br><span class="line">    exports com.mycompany.sample; </span><br><span class="line">    requires com.mycompany.common; </span><br><span class="line">    provides com.mycompany.common.DemoService with</span><br><span class="line">        com.mycompany.sample.DemoServiceImpl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该声明文件中，模块 com.mycompany.sample 导出了 Java 包 com.mycompany.sample。<br>该模块依赖于模块 com.mycompany.sample 。<br>该模块也提供了服务接口 com.mycompany.common.DemoService 的实现类 c om.mycompany.sample.DemoServiceImpl 。</p>
<h3 id="Create-Module-Example"><a href="#Create-Module-Example" class="headerlink" title="Create Module Example"></a>Create Module Example</h3><p>step 1</p>
<p>创建文件夹 src ,然后在该目录下再创建与模块名相同的文件夹 com\runoob\greetings</p>
<p>step 2</p>
<p>在src\com\runoob\greetings 目录下创建 module-info.java 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module com.runoob.greetings &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>module-info.java 用于创建模块。这一步我们创建了 com.runoob.greetings 模块</p>
<p>step 3</p>
<p>在模块中添加源代码文件，在目录src\com.runoob.greetings\com\runoob\greetings 中创建文件 Java9Tester.java，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.runoob.greetings;</span><br><span class="line"></span><br><span class="line">public class Java9Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>step 4</p>
<p>创建文件夹 mods，然后在该目录下创建 com\runoob\greetings 文件夹，编译模块到这个目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac -d mods/com.runoob.greetings </span><br><span class="line">   src/com.runoob.greetings/module-info.java </span><br><span class="line">   src/com.runoob.greetings/com/runoob/greetings/Java9Tester.java</span><br></pre></td></tr></table></figure>

<p>step 5</p>
<p>执行模块，查看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java --module-path mods -m com.runoob.greetings/com.runoob.greetings.Java9Tester</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>module-path 指定了模块所在的路径。</p>
<p>-m 指定主要模块。</p>
<hr>
<h1 id="Jshell-REPL"><a href="#Jshell-REPL" class="headerlink" title="Jshell : REPL"></a>Jshell : REPL</h1><h2 id="What-is-Jshell"><a href="#What-is-Jshell" class="headerlink" title="What is Jshell?"></a><strong>What is Jshell?</strong></h2><p>REPL(Read Eval Print Loop)意为交互式的编程环境。</p>
<p>jshell 是 Java 9 新增的一个实用工具。jshell 为 Java 增加了类似 NodeJS 和 Python 中的读取-求值-打印循环（ Read-Evaluation-Print Loop ） 。 在 jshell 中 可以直接 输入表达式并查看其执行结果。当需要测试一个方法的运行效果，或是快速的对表达式进行求值时，jshell 都非常实用。只需要通过 jshell 命令启动 jshell，然后直接输入表达式即可。每个表达式的结果会被自动保存下来 ，以数字编号作为引用，类似 $1 和$2 这样的名称 。可以在后续的表达式中引用之前语句的运行结果。 在 jshell 中 ，除了表达式之外，还可以创建 Java 类和方法。jshell 也有基本的代码完成功能。</p>
<h2 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a><strong>Usage</strong></h2><h3 id="执行-JSHELL"><a href="#执行-JSHELL" class="headerlink" title="执行 JSHELL"></a>执行 JSHELL</h3><p>JShell 允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接 输入表达式并查看其执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jshell</span><br><span class="line">|  Welcome to JShell -- Version 9-ea</span><br><span class="line">|  For an introduction type: /help intro</span><br><span class="line">jshell&gt;int add(int x, int y) &#123; </span><br><span class="line">    ...&gt; return x + y; </span><br><span class="line">    ...&gt; &#125;</span><br><span class="line"> | created method add(int,int)</span><br><span class="line">jshell&gt; add(1, 2) </span><br><span class="line">$19 ==&gt; 3</span><br></pre></td></tr></table></figure>
<h3 id="查看-JShell-命令"><a href="#查看-JShell-命令" class="headerlink" title="查看 JShell 命令"></a>查看 JShell 命令</h3><p>输入 /help 可以查看 JShell相关的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /help</span><br><span class="line">|  Type a Java language expression, statement, or declaration.</span><br><span class="line">|  Or type one of the following commands:</span><br><span class="line">|  /list [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the source you have typed</span><br><span class="line">|  /edit &lt;name or id&gt;</span><br><span class="line">|  edit a source entry referenced by name or id</span><br><span class="line">|  /drop &lt;name or id&gt;</span><br><span class="line">|  delete a source entry referenced by name or id</span><br><span class="line">|  /save [-all|-history|-start] &lt;file&gt;</span><br><span class="line">|  Save snippet source to a file.</span><br><span class="line">|  /open &lt;file&gt;</span><br><span class="line">|  open a file as source input</span><br><span class="line">|  /vars [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared variables and their values</span><br><span class="line">|  /methods [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared methods and their signatures</span><br><span class="line">|  /types [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared types</span><br><span class="line">|  /imports </span><br><span class="line">|  list the imported items</span><br></pre></td></tr></table></figure>
<h3 id="执行-JShell-命令"><a href="#执行-JShell-命令" class="headerlink" title="执行 JShell 命令"></a>执行 JShell 命令</h3><p>/imports 命令用于查看已导入的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /imports</span><br><span class="line">|    import java.io.*</span><br><span class="line">|    import java.math.*</span><br><span class="line">|    import java.net.*</span><br><span class="line">|    import java.nio.file.*</span><br><span class="line">|    import java.util.*</span><br><span class="line">|    import java.util.concurrent.*</span><br><span class="line">|    import java.util.function.*</span><br><span class="line">|    import java.util.prefs.*</span><br><span class="line">|    import java.util.regex.*</span><br><span class="line">|    import java.util.stream.*</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JShell-执行计算"><a href="#JShell-执行计算" class="headerlink" title="JShell 执行计算"></a>JShell 执行计算</h3><p>以下实例执行 JShell 简单计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; 3+1</span><br><span class="line">$1 ==&gt; 4</span><br><span class="line">jshell&gt; 13%7</span><br><span class="line">$2 ==&gt; 6</span><br><span class="line">jshell&gt; $2</span><br><span class="line">$2 ==&gt; 6</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JShell-创建与使用函数"><a href="#JShell-创建与使用函数" class="headerlink" title="JShell 创建与使用函数"></a>JShell 创建与使用函数</h3><p>创建一个函数 doubled() ，将传入的整型参数乘于 2 后返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int doubled(int i)&#123; return i*2;&#125;</span><br><span class="line">|  created method doubled(int)</span><br><span class="line">jshell&gt; doubled(6)</span><br><span class="line">$3 ==&gt; 12</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>

<h3 id="退出-JShell"><a href="#退出-JShell" class="headerlink" title="退出 JShell"></a>退出 JShell</h3><p>输入 /exit 命令退出 jshell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /exit</span><br><span class="line">| Goodbye </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="改进的-API-和类"><a href="#改进的-API-和类" class="headerlink" title="改进的 API 和类"></a>改进的 API 和类</h1><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Java 9 改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。</p>
<p>Java 9 为 Stream 新增了几个方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代：</p>
<h3 id="takeWhile-方法"><a href="#takeWhile-方法" class="headerlink" title="takeWhile 方法"></a>takeWhile 方法</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure>

<p>takeWhile() 方法使用一个断言作为参数，返回给定 Stream 的子集直到断言语句第一次返回 false。如果第一个值不满足断言条件，将返回一个空的 Stream。</p>
<p>takeWhile() 方法在有序的 Stream 中，takeWhile 返回从开头开始的尽量多的元素；在无序的 Stream 中，takeWhile 返回从开头开始的符合 Predicate 要求的元素的子集。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;,&quot;e&quot;,&quot;f&quot;).takeWhile(s-&gt;!s.isEmpty())</span><br><span class="line">         .forEach(System.out::print);      </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例 takeWhile 方法在碰到空字符串时停止循环输出，执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure>

<h3 id="dropWhile-方法"><a href="#dropWhile-方法" class="headerlink" title="dropWhile 方法"></a>dropWhile 方法</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure>

<p>dropWhile 方法和 takeWhile 作用相反的，使用一个断言作为参数，直到断言语句第一次返回 true 才返回给定 Stream 的子集。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;,&quot;e&quot;,&quot;f&quot;).dropWhile(s-&gt; !s.isEmpty())</span><br><span class="line">         .forEach(System.out::print);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例 dropWhile 方法在碰到空字符串时开始循环输出，执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ef</span><br></pre></td></tr></table></figure>

<h3 id="iterate-方法"><a href="#iterate-方法" class="headerlink" title="iterate 方法"></a>iterate 方法</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span><br></pre></td></tr></table></figure>

<p>方法允许使用初始种子值创建顺序（可能是无限）流，并迭代应用指定的下一个方法。 当指定的 hasNext 的 predicate 返回 false 时，迭代停止。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.IntStream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      IntStream.iterate(3, x -&gt; x &lt; 10, x -&gt; x + 3).forEach(System.out::println);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h3 id="ofNullable-方法"><a href="#ofNullable-方法" class="headerlink" title="ofNullable 方法"></a>ofNullable 方法</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t)</span><br></pre></td></tr></table></figure>

<p>ofNullable 方法可以预防 NullPointerExceptions 异常， 可以通过检查流来避免 null 值。</p>
<p>如果指定元素为非 null，则获取一个元素并生成单个元素流，元素为 null 则返回一个空流。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      long count = Stream.ofNullable(100).count();</span><br><span class="line">      System.out.println(count);</span><br><span class="line">  </span><br><span class="line">      count = Stream.ofNullable(null).count();</span><br><span class="line">      System.out.println(count);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p>Optional 类在 Java 8 中引入，Optional 类的引入很好的解决空指针异常。在 java 9 中, 添加了三个方法来改进它的功能：stream(),ifPresentOrElse()和or()。</p>
<h3 id="stream-方法"><a href="#stream-方法" class="headerlink" title="stream() 方法"></a>stream() 方法</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Stream&lt;T&gt; stream()</span><br></pre></td></tr></table></figure>

<p>stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream，否则返回一个空的 Stream（Stream.empty()）。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   List&lt;Optional&lt;String&gt;&gt; list = Arrays.asList (</span><br><span class="line">      Optional.empty(), </span><br><span class="line">      Optional.of(&quot;A&quot;), </span><br><span class="line">      Optional.empty(), </span><br><span class="line">      Optional.of(&quot;B&quot;));</span><br><span class="line"> </span><br><span class="line">      //filter the list based to print non-empty values</span><br><span class="line">  </span><br><span class="line">      //if optional is non-empty, get the value in stream, otherwise return empty</span><br><span class="line">      List&lt;String&gt; filteredList = list.stream()</span><br><span class="line">         .flatMap(o -&gt; o.isPresent() ? Stream.of(o.get()) : Stream.empty())</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">      //Optional::stream method will return a stream of either one </span><br><span class="line">      //or zero element if data is present or not.</span><br><span class="line">      List&lt;String&gt; filteredListJava9 = list.stream()</span><br><span class="line">         .flatMap(Optional::stream)</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">      System.out.println(filteredList);</span><br><span class="line">      System.out.println(filteredListJava9);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[A, B]</span><br><span class="line">[A, B]</span><br></pre></td></tr></table></figure>

<h3 id="ifPresentOrElse-方法"><a href="#ifPresentOrElse-方法" class="headerlink" title="ifPresentOrElse() 方法"></a>ifPresentOrElse() 方法</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</span><br></pre></td></tr></table></figure>

<p>ifPresentOrElse 方法的改进就是有了 else，接受两个参数 Consumer 和 Runnable。</p>
<p>ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Optional&lt;Integer&gt; optional = Optional.of(1);</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line"> </span><br><span class="line">      optional = Optional.empty();</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: 1</span><br><span class="line">Not Present.</span><br></pre></td></tr></table></figure>

<h3 id="or-方法"><a href="#or-方法" class="headerlink" title="or() 方法"></a>or() 方法</h3><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</span><br></pre></td></tr></table></figure>

<p>如果值存在，返回 Optional 指定的值，否则返回一个预设的值。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Optional&lt;String&gt; optional1 = Optional.of(&quot;Mahesh&quot;);</span><br><span class="line">      Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(&quot;Not Present&quot;);</span><br><span class="line">      optional1 = optional1.or( supplierString);</span><br><span class="line">      optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x));</span><br><span class="line">      optional1 = Optional.empty();    </span><br><span class="line">      optional1 = optional1.or( supplierString);</span><br><span class="line">      optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: Mahesh</span><br><span class="line">Value: Not Present</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>在集合上，Java 9 增加 了 List.of()、Set.of()、Map.of() 和 M ap.ofEntries()等工厂方法来创建不可变集合。</p>
<p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List.of(); </span><br><span class="line">List.of(&quot;Hello&quot;, &quot;World&quot;); </span><br><span class="line">List.of(1, 2, 3);</span><br><span class="line">Set.of(); </span><br><span class="line">Set.of(&quot;Hello&quot;, &quot;World&quot;); </span><br><span class="line">Set.of(1, 2, 3);</span><br><span class="line">Map.of();</span><br><span class="line">Map.of(&quot;Hello&quot;, 1, &quot;World&quot;, 2);</span><br></pre></td></tr></table></figure>

<h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>Java 9 增加了 ProcessHandle 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程。在使用 ProcessBuilder 来启动一个进程之后，可以通过 Process.toHandle()方法来得到一个 ProcessHandle 对象的实例。通过 ProcessHandle 可以获取到由 ProcessHandle.Info 表 示的进程的基本信息，如命令行参数、可执行文件路径和启动时间等。ProcessHandle 的 onExit()方法返回一个 CompletableFuture<ProcessHandle>对象，可以在进程结束时执行自定义的动作。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final ProcessBuilder processBuilder = new ProcessBuilder(&quot;top&quot;) </span><br><span class="line">    .inheritIO(); </span><br><span class="line">final ProcessHandle processHandle = processBuilder.start().toHandle(); </span><br><span class="line">processHandle.onExit().whenCompleteAsync((handle, throwable) -&gt; &#123; </span><br><span class="line">    if (throwable == null) &#123; </span><br><span class="line">        System.out.println(handle.pid()); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        throwable.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="I-O-流新特性"><a href="#I-O-流新特性" class="headerlink" title="I/O 流新特性"></a>I/O 流新特性</h2><p>类 java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。</p>
<ul>
<li>readAllBytes - 读取 InputStream 中的所有剩余字节。</li>
<li>readNBytes - 从 InputStream 中读取指定数量的字节到数组中。</li>
<li>transferTo - 读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestInputStream &#123;</span><br><span class="line">    private InputStream inputStream; </span><br><span class="line">    private static final String CONTENT = &quot;Hello World&quot;; </span><br><span class="line">    @Before </span><br><span class="line">    public void setUp() throws Exception &#123; </span><br><span class="line">        this.inputStream = </span><br><span class="line">            TestInputStream.class.getResourceAsStream(&quot;/input.txt&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    @Test </span><br><span class="line">    public void testReadAllBytes() throws Exception &#123; </span><br><span class="line">        final String content = new String(this.inputStream.readAllBytes()); </span><br><span class="line">        assertEquals(CONTENT, content); </span><br><span class="line">    &#125; </span><br><span class="line">    @Test </span><br><span class="line">    public void testReadNBytes() throws Exception &#123; </span><br><span class="line">        final byte[] data = new byte[5]; </span><br><span class="line">        this.inputStream.readNBytes(data, 0, 5); </span><br><span class="line">        assertEquals(&quot;Hello&quot;, new String(data)); </span><br><span class="line">    &#125; </span><br><span class="line">    @Test </span><br><span class="line">    public void testTransferTo() throws Exception &#123; </span><br><span class="line">        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); </span><br><span class="line">        this.inputStream.transferTo(outputStream); </span><br><span class="line">        assertEquals(CONTENT, outputStream.toString()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObjectInputFilter 可以对 ObjectInputStream 中 包含的内容进行检查，来确保其中包含的数据是合法的。可以使用 ObjectInputStream 的方法 setObjectInputFilter 来设置。ObjectInputFilter 在 进行检查时，可以检查如对象图的最大深度、对象引用的最大数量、输入流中的最大字节数和数组的最大长度等限制，也可以对包含的类的名称进行限制。</p>
<h2 id="平台日志-API-和-服务"><a href="#平台日志-API-和-服务" class="headerlink" title="平台日志 API 和 服务"></a>平台日志 API 和 服务</h2><p>Java 9 允许为 JDK 和应用配置同样的日志实现。新增的 System.LoggerFinder 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 LoggerFinder 实例。LoggerFinder 通 过服务查找机制来加载日志记录器实现。默认情况下，JDK 使用 java.logging 模块中的 java.util.logging 实现。通过 LoggerFinder 的 getLogger()方法就可以获取到表示日志记录器的 System.Logger 实现。应用同样可以使用 System.Logger 来记录日志。这样就保证了 JDK 和应用使用同样的日志实现。我们也可以通过添加自己的 System.LoggerFinder 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。 代码清单 9 中给出了平台日志 API 的使用示例。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123; </span><br><span class="line">    private static final System.Logger LOGGER = System.getLogger(&quot;Main&quot;); </span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) &#123; </span><br><span class="line">        LOGGER.log(Level.INFO, &quot;Run!&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进应用安全性能"><a href="#改进应用安全性能" class="headerlink" title="改进应用安全性能"></a>改进应用安全性能</h2><p>Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 S HA3-512。另外也增加了通过 java.security.SecureRandom 生成使用 DRBG 算法的强随机数。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.codec.binary.Hex; </span><br><span class="line">public class SHA3 &#123; </span><br><span class="line">    public static void main(final String[] args) throws NoSuchAlgorithmException &#123; </span><br><span class="line">        final MessageDigest instance = MessageDigest.getInstance(&quot;SHA3-224&quot;); </span><br><span class="line">        final byte[] digest = instance.digest(&quot;&quot;.getBytes()); </span><br><span class="line">        System.out.println(Hex.encodeHexString(digest)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进的-try-with-resources"><a href="#改进的-try-with-resources" class="headerlink" title="改进的 try-with-resources"></a>改进的 try-with-resources</h2><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。</p>
<p>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p>
<p>java 7 示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      System.out.println(readData(&quot;test&quot;));</span><br><span class="line">   &#125; </span><br><span class="line">   static String readData(String message) throws IOException &#123;</span><br><span class="line">      Reader inputString = new StringReader(message);</span><br><span class="line">      BufferedReader br = new BufferedReader(inputString);</span><br><span class="line">      try (BufferedReader br1 = br) &#123;</span><br><span class="line">         return br1.readLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例中我们需要在 try 语句块中声明资源 br1，然后才能使用它。</p>
<p>在 Java 9 中，我们不需要声明资源 br1 就可以使用它，并得到相同的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      System.out.println(readData(&quot;test&quot;));</span><br><span class="line">   &#125; </span><br><span class="line">   static String readData(String message) throws IOException &#123;</span><br><span class="line">      Reader inputString = new StringReader(message);</span><br><span class="line">      BufferedReader br = new BufferedReader(inputString);</span><br><span class="line">      try (br) &#123;</span><br><span class="line">         return br.readLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句实际上是不可能的。</p>
<h2 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h2><p>在 Java 8之前，接口可以有常量变量和抽象方法。</p>
<p>我们不能在接口中提供方法实现。如果我们要提供抽象方法和非抽象方法（方法与实现）的组合，那么我们就得使用抽象类。</p>
<p>在 Java 8 接口引入了一些新功能——默认方法和静态方法。我们可以在Java SE 8的接口中编写方法实现，仅仅需要使用 default 关键字来定义它们。</p>
<p>在 Java 8 中，一个接口中能定义如下几种变量/方法：</p>
<ul>
<li>常量</li>
<li>抽象方法</li>
<li>默认方法</li>
<li>静态方法</li>
</ul>
<p>Java 9 不仅像 Java 8 一样支持接口默认方法，同时还支持私有方法。</p>
<p>在 Java 9 中，一个接口中能定义如下几种变量/方法：</p>
<ul>
<li>常量</li>
<li>抽象方法</li>
<li>默认方法</li>
<li>静态方法</li>
<li>私有方法</li>
<li>私有静态方法</li>
</ul>
<p>示例</p>
<p>java 7</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"></span><br><span class="line">   void logInfo(String message);</span><br><span class="line"></span><br><span class="line">   void getConnection();</span><br><span class="line">   void closeConnection();</span><br><span class="line">&#125;</span><br><span class="line">final class LogMySql implements Logging &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void logInfo(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;INFO&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class LogOracle implements Logging &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void logInfo(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;INFO&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java 8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   default void logInfo(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;INFO&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logWarn(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;WARN&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logError(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;ERROR&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logFatal(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;FATAL&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   static void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class LogOracle implements Logging &#123; &#125;</span><br><span class="line">final class LogMySql implements Logging &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>java 9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   private void log(String message, String prefix) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + prefix);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logInfo(String message) &#123;</span><br><span class="line">      log(message, &quot;INFO&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logWarn(String message) &#123;</span><br><span class="line">      log(message, &quot;WARN&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logError(String message) &#123;</span><br><span class="line">      log(message, &quot;ERROR&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logFatal(String message) &#123;</span><br><span class="line">      log(message, &quot;FATAL&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private static void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   private static void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class LogOracle implements Logging &#123; &#125;</span><br><span class="line">final class LogMySql implements Logging &#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进的-Deprecated-注解"><a href="#改进的-Deprecated-注解" class="headerlink" title="改进的 @Deprecated 注解"></a>改进的 @Deprecated 注解</h2><p>在 Java SE 8 和更早版本上，@Deprecated 注解只是一个没有任何方法的标记类接口。它的作用是标记一个 Java API，可以是 calss，field，method，interface，constructor 等。</p>
<p>在 Java SE 9 中，Oracle 公司强化了 @Deprecated 注解，来提供更多有关废弃 API 的介绍信息，同时也提供一个工具来分析项目中的废弃 API 的静态使用情况。</p>
<p>注解 @Deprecated 可以标记 Java API 状态，可以是以下几种：</p>
<ul>
<li>使用它存在风险，可能导致错误</li>
<li>可能在未来版本中不兼容</li>
<li>可能在未来版本中删除</li>
<li>一个更好和更高效的方案已经取代它。</li>
</ul>
<p>Java 9 中注解增加了两个新元素：since 和 forRemoval。</p>
<ul>
<li>since: 元素指定已注解的API元素已被弃用的版本。</li>
<li>forRemoval: 元素表示注解的 API 元素在将来的版本中被删除，应该迁移 API。</li>
</ul>
<h2 id="Diamond-Operator-for-Anonymous-Inner-Class"><a href="#Diamond-Operator-for-Anonymous-Inner-Class" class="headerlink" title="Diamond Operator for Anonymous Inner Class"></a>Diamond Operator for Anonymous Inner Class</h2><p>在Java7之前每次声明泛型变量的时必须左右两边都同时声明泛型：</p>
<p>在Java7中，对这一点进行了改进，就不必两边都要声明泛型，这种只适用&lt;&gt;标记的操作，称之为钻石操作符Diamond Operator。</p>
<p>但是Java7中钻石操作符不允许在匿名类上使用：</p>
<p>在 Java 8 中，Oracle 公司发现在 Diamond 操作器和匿名内部类的使用中存在一些局限性，后来修复了这些问题并准备将其作为 Java 9 的一部分发布出去。在 java 9 中， 它可以与匿名的内部类一起使用，从而提高代码的可读性。</p>
<p> Java 7 之前的代码：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">Set&lt;String&gt; set = new HashSet&lt;String&gt;();</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p> Java 9 之前的代码：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p> 在 Java 9 中，我们可以在匿名类中使用 &lt;&gt; 操作符，如下所示：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return super.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">Set&lt;String&gt; set = new HashSet&lt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return super.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return super.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="多分辨率图像-API"><a href="#多分辨率图像-API" class="headerlink" title="多分辨率图像 API"></a>多分辨率图像 API</h2><p>在 Java 9 中，Oracle 公司将引入一个新的 Мulti-Resolution Image API。这个 API 中比较重要的接口是 MultiResolutionImage，在 java.awt.image 包下可获取到。</p>
<p>MultiResolutionImage 封装不同高度和宽度图片（不同解决方案）到一个集合中，并允许我们按需查询使用。</p>
<p>以下是MultiResolutionImage的主要操作方法：</p>
<ul>
<li>Image getResolutionVariant(double destImageWidth, double destImageHeight) − 获取特定分辨率的图像变体-表示一张已知分辨率单位为DPI的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li>
<li>List<Image> getResolutionVariants() − 返回可读的分辨率的图像变体列表。</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.awt.Image;</span><br><span class="line">import java.awt.image.MultiResolutionImage;</span><br><span class="line">import java.awt.image.BaseMultiResolutionImage;</span><br><span class="line"> </span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException, MalformedURLException &#123;</span><br><span class="line"> </span><br><span class="line">      List&lt;String&gt; imgUrls = List.of(&quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo@2x.png&quot;,</span><br><span class="line">         &quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png&quot;,</span><br><span class="line">         &quot;http://www.runoob.com/wp-content/themes/runoob/assets/images/qrcode.png&quot;);</span><br><span class="line"> </span><br><span class="line">      List&lt;Image&gt; images = new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">      for (String url : imgUrls) &#123;</span><br><span class="line">         images.add(ImageIO.read(new URL(url)));</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      // 读取所有图片</span><br><span class="line">      MultiResolutionImage multiResolutionImage = </span><br><span class="line">         new BaseMultiResolutionImage(images.toArray(new Image[0]));</span><br><span class="line"> </span><br><span class="line">      // 获取图片的所有分辨率</span><br><span class="line">      List&lt;Image&gt; variants = multiResolutionImage.getResolutionVariants();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Total number of images: &quot; + variants.size());</span><br><span class="line"> </span><br><span class="line">      for (Image img : variants) &#123;</span><br><span class="line">         System.out.println(img);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      // 根据不同尺寸获取对应的图像分辨率</span><br><span class="line">      Image variant1 = multiResolutionImage.getResolutionVariant(156, 45);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, </span><br><span class="line">         156, 45, variant1.getWidth(null), variant1.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant2 = multiResolutionImage.getResolutionVariant(311, 89);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 311, 89, </span><br><span class="line">         variant2.getWidth(null), variant2.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant3 = multiResolutionImage.getResolutionVariant(622, 178);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 622, 178, </span><br><span class="line">         variant3.getWidth(null), variant3.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant4 = multiResolutionImage.getResolutionVariant(300, 300);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 300, 300, </span><br><span class="line">         variant4.getWidth(null), variant4.getHeight(null));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="响应式流-（-Reactive-Streams-）"><a href="#响应式流-（-Reactive-Streams-）" class="headerlink" title="响应式流 （ Reactive Streams ）"></a>响应式流 （ Reactive Streams ）</h1><h2 id="What-is-Reactive-Streams"><a href="#What-is-Reactive-Streams" class="headerlink" title="What is Reactive Streams?"></a><strong>What is Reactive Streams?</strong></h2><blockquote>
<p>流是由生产者生产并由一个或多个消费者消费的元素（item）的序列。 这种生产者——消费者模型也被称为source/sink模型或发布者——订阅者（publisher-subscriber ）模型。 在本章中，将其称为发布者订阅者模型。<br/>有几种流处理机制，其中pull模型和push模型是最常见的。 在push模型中，发布者将元素推送给订阅者。 在pull模式中，订阅者将元素推送给发布者。 发布者和订阅者都以同样的速率工作，这是一个理想的情况，这些模式非常有效。 我们会考虑一些情况，如果他们不按同样的速率工作，这种情况下涉及的问题以及对应的解决办法。<br/>当发布者比订阅者快的时候，后者必须有一个无边界缓冲区来保存快速传入的元素，或者它必须丢弃它无法处理的元素。另一个解决方案是使用一种称为背压（backpressure）的策略，其中订阅者告诉发布者减慢速率并保持元素，直到订阅者准备好处理更多的元素。 使用背压可确保更快的发布者不会压制较慢的订阅者。 使用背压可能要求发布者拥有无限制的缓冲区，如果它要一直生成和保存元素。 发布者可以实现有界缓冲区来保存有限数量的元素，如果缓冲区已满，可以选择放弃它们。 可以使用另一策略，其中发布者将发布元素重新发送到订阅者，这些元素发布时订阅者不能接受。<br/>订阅者在请求发布者的元素并且元素不可用时，该做什么？ 在同步请求中订阅者户必须等待，无限期地，直到有元素可用。 如果发布者同步地向订阅者发送元素，并且订阅者同步处理它们，则发布者必须阻塞直到数据处理完成。 解决方案是在两端进行异步处理，订阅者可以在从发布者请求元素之后继续处理其他任务。 当更多的元素准备就绪时，发布者将它们异步发送给订阅者。</p>
</blockquote>
<p>响应式流从2013年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者有无限制的缓冲区或丢弃。</p>
<p>响应式流模型非常简单——订阅者向发布者发送多个元素的异步请求。 发布者向订阅者异步发送多个或稍少的元素。</p>
<p>响应式编程的思想最近得到了广泛的流行。 在 Java 平台上有流行的响应式库 RxJava 和 Reactor。响应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。响应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。</p>
<p>Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 Flow.Processor 等 4 个核心接口。Java 9 还提供了 SubmissionPublisher 作为 Flow.Publisher 的一个实现。RxJava 2 和 Reactor 都可以很方便的 与 Flow 类的核心接口进行互操作。</p>
<p>有关响应式流的更多信息，请访问<a><a target="_blank" rel="noopener" href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a></a>。 </p>
<hr>
<h1 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h1><h2 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h2><p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。变量句柄的含义类似于已有的方法句柄。变量句柄只是对创建的变量的类型引用，以便在不同的访问模式下提供对变量的读写访问。</p>
<p>变量句柄由 Java 类 java.lang.invoke.VarHandle 来表示。可以使用类 java.lang.invoke.MethodHandles.Lookup 中的静态工厂方法来创建 VarHandle 对象。varHandle由两个重要部分组成 - 变量类型和坐标列表。变量类型表示varHandle给出内存引用的变量类型，而坐标列表有助于定位其引用由varHandle给出的变量。通过变量句柄，可以在变量上进行各种操作。这些操作称为访问模式。不同的访问模式尤其在内存排序上的不同语义。目前一共有 31 种 访问模式，而每种访问模式都 在 VarHandle 中 有对应的方法。这些方法可以对变量进行读取、写入、原子更新、数值原子更新和按位原子操作等。VarHandle 还可以用来访问数组中的单个元素，以及把 byte[]数组 和 ByteBuffer 当成是不同原始类型的数组来访问。从本质上讲，VarHandle对象一旦创建就无法修改。</p>
<p>Variable Handle的方法分为五种访问模式：</p>
<ul>
<li>读访问模式 - 这可用于获取变量的值。get()，getVolatile()，getAcquire()和getOpaque()是一些支持读访问的方法。</li>
<li>写访问模式 - 这可用于设置变量的值。set()，setVolatile()，setRelease()和setOpaque()是一些支持写访问的方法。</li>
<li>原子更新加速模式 - 这可用于在比较当前值和新值之后以原子方式更改变量的值。属于此类访问模式的一些方法是：compareAndSet，compareAndExchangeAcquire，compareAndExchange，compareAndExchangeRelease，getAndSet，getAndSetAcquire，getAndSetRelease等。</li>
<li>数值原子更新访问模式 - 这可以用于我们想要通过添加原子设置值的情况。getAndAdd，getAndAddAcquire，getAndAddRelease等方法属于此类别。</li>
<li>按位原子更新访问模式 - 这可用于在设置值之前检索并执行按位OR，AND或XOR。属于此类别的一些方法是：getAndBitwiseOr，getAndBitwiseOrAcquire，getAndBitwiseOrRelease，getAndBitwiseAnd，getAndBitwiseAndAcquire，getAndBitwiseAndRelease，getAndBitwiseXor，getAndBitwiseXorAcquire，getAndBitwiseXorRelease等。</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class HandleTarget &#123; </span><br><span class="line">    public int count = 1; </span><br><span class="line">&#125; </span><br><span class="line">public class VarHandleTest &#123;</span><br><span class="line">    private HandleTarget handleTarget = new HandleTarget(); </span><br><span class="line">    private VarHandle varHandle; </span><br><span class="line">    @Before </span><br><span class="line">    public void setUp() throws Exception &#123; </span><br><span class="line">        this.handleTarget = new HandleTarget(); </span><br><span class="line">        this.varHandle = MethodHandles </span><br><span class="line">            .lookup() </span><br><span class="line">            .findVarHandle(HandleTarget.class, &quot;count&quot;, int.class); </span><br><span class="line">    &#125; </span><br><span class="line">    @Test </span><br><span class="line">    public void testGet() throws Exception &#123; </span><br><span class="line">        assertEquals(1, this.varHandle.get(this.handleTarget)); </span><br><span class="line">        assertEquals(1, this.varHandle.getVolatile(this.handleTarget)); </span><br><span class="line">        assertEquals(1, this.varHandle.getOpaque(this.handleTarget)); </span><br><span class="line">        assertEquals(1, this.varHandle.getAcquire(this.handleTarget)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进方法句柄"><a href="#改进方法句柄" class="headerlink" title="改进方法句柄"></a>改进方法句柄</h2><p>类 java.lang.invoke.MethodHandles 增加了更多的静态方法来创建不同类型的方法句柄。</p>
<ul>
<li>arrayConstructor - 创建指定类型的数组。</li>
<li>arrayLength - 获取指定类型的数组的大小。</li>
<li>varHandleInvoker 和 varHandleExactInvoker - 调用 VarHandle 中的访问模式方法。</li>
<li>zero - 返回一个类型的默认值。</li>
<li>empty - 返回 MethodType 的返回值类型的默认值。</li>
<li>loop、countedLoop、iteratedLoop、whileLoop 和 doWhileLoop - 创建不同类型的循环，包括 for 循环、while 循环 和 do-while 循环。</li>
<li>tryFinally - 把对方法句柄的调用封装在 try-finally 语句中。</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class IteratedLoopTest &#123; </span><br><span class="line">    static int body(final int sum, final String value) &#123; </span><br><span class="line">        return sum + value.length(); </span><br><span class="line">    &#125; </span><br><span class="line">    @Test </span><br><span class="line">    public void testIteratedLoop() throws Throwable &#123; </span><br><span class="line">        final MethodHandle iterator = MethodHandles.constant( </span><br><span class="line">            Iterator.class, </span><br><span class="line">            List.of(&quot;a&quot;, &quot;bc&quot;, &quot;def&quot;).iterator()); </span><br><span class="line">        final MethodHandle init = MethodHandles.zero(int.class); </span><br><span class="line">        final MethodHandle body = MethodHandles </span><br><span class="line">            .lookup() </span><br><span class="line">            .findStatic( </span><br><span class="line">                IteratedLoopTest.class, </span><br><span class="line">                &quot;body&quot;, </span><br><span class="line">                MethodType.methodType( </span><br><span class="line">                    int.class, </span><br><span class="line">                    int.class, </span><br><span class="line">                    String.class)); </span><br><span class="line">        final MethodHandle iteratedLoop = MethodHandles </span><br><span class="line">            .iteratedLoop(iterator, init, body); </span><br><span class="line">        assertEquals(6, iteratedLoop.invoke()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="并发的改进"><a href="#并发的改进" class="headerlink" title="并发的改进"></a>并发的改进</h1><p>Java 8 引入了 CompletableFuture<T> 类，可能是 java.util.concurrent.Future<T> 明确的完成版（设置了它的值和状态），也可能被用作java.util.concurrent.CompleteStage 。支持 future 完成时触发一些依赖的函数和动作。Java 9 引入了一些CompletableFuture 的改进，增加了几个新的方法。</p>
<p>对原 CompletableFuture 做了改进：</p>
<ul>
<li>支持 delays 和 timeouts</li>
<li>提升了对子类化的支持</li>
<li>新的工厂方法</li>
</ul>
<p>增加的方法：</p>
<ul>
<li>completeAsync 使用一个异步任务来获取结果并完成该 CompletableFuture。</li>
<li>orTimeout 在 CompletableFuture 没有在给定的超时时间之前完成，使用 TimeoutException 异常来完成 CompletableFuture。</li>
<li>completeOnTimeout 与 orTimeout 类似，只不过它在超时时使用给定的值来完成 CompletableFuture。</li>
<li>新的 Thread.onSpinWait 方法在当前线程需要使用忙循环来等待时，可以提高等待的效率。</li>
</ul>
<h2 id="支持-delays-和-timeouts"><a href="#支持-delays-和-timeouts" class="headerlink" title="支持 delays 和 timeouts"></a>支持 delays 和 timeouts</h2><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>如果没有在给定的 timeout 内完成，就以 java.util.concurrent.TimeoutException 完成这个 CompletableFutrue，并返回这个 CompletableFutrue。</p>
<p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>在 timeout（单位在 java.util.concurrent.Timeunits units 中，比如 MILLISECONDS ）前以给定的 value 完成这个 CompletableFutrue。返回这个 CompletableFutrue。</p>
<h2 id="增强了对子类化的支持"><a href="#增强了对子类化的支持" class="headerlink" title="增强了对子类化的支持"></a>增强了对子类化的支持</h2><p>做了许多改进使得 CompletableFuture 可以被更简单的继承。比如，你也许想重写新的 public Executor defaultExecutor() 方法来代替默认的 executor。</p>
<p>另一个新的使子类化更容易的方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture()</span><br></pre></td></tr></table></figure>

<h2 id="新的工厂方法"><a href="#新的工厂方法" class="headerlink" title="新的工厂方法"></a>新的工厂方法</h2><p>ava 8引入了 &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) 工厂方法来返回一个已经以给定 value 完成了的 CompletableFuture。Java 9以一个新的 &lt;U&gt; CompletableFuture&lt;U&gt; failedFuture(Throwable ex) 来补充了这个方法，可以返回一个以给定异常完成的 CompletableFuture。</p>
<p>除此以外，Java 9 引入了下面这对 stage-oriented 工厂方法，返回完成的或异常完成的 completion stages:</p>
<ul>
<li>&lt;U&gt; CompletionStage&lt;U&gt; completedStage(U value): 返回一个新的以指定 value 完成的CompletionStage ，并且只支持 CompletionStage 里的接口。</li>
<li>&lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex): 返回一个新的以指定异常完成的CompletionStage ，并且只支持 CompletionStage 里的接口。</li>
</ul>
<hr>
<h1 id="多版本兼容-jar-包"><a href="#多版本兼容-jar-包" class="headerlink" title="多版本兼容 jar 包"></a>多版本兼容 jar 包</h1><p>多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</p>
<p>通过 –release 参数指定编译版本。</p>
<p>具体的变化就是 META-INF 目录下 MANIFEST.MF 文件新增了一个属性：<em>Multi-Release: true</em></p>
<p>META-INF 目录下还新增了一个 versions 目录，如果是要支持 java9，则在 versions 目录下有 9 的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">multirelease.jar</span><br><span class="line">├── META-INF</span><br><span class="line">│   └── versions</span><br><span class="line">│       └── 9</span><br><span class="line">│           └── multirelease</span><br><span class="line">│               └── Helper.class</span><br><span class="line">├── multirelease</span><br><span class="line">    ├── Helper.class</span><br><span class="line">    └── Main.class</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><p>javadoc 工具可以生成 Java 文档， Java 9 的 javadoc 的输出现在符合兼容 HTML5 标准。</p>
<p>Java 9 之前的旧版本文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @author MahKumar</span><br><span class="line">  * @version 0.1</span><br><span class="line">*/</span><br><span class="line">public class Tester &#123;</span><br><span class="line">   /**</span><br><span class="line">      * Default method to be run to print </span><br><span class="line">      * &lt;p&gt;Hello world&lt;/p&gt;</span><br><span class="line">      * @param args command line arguments</span><br><span class="line">   */</span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      System.out.println(&quot;Hello World&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 jdk 7 的 javadoc 生成文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ javadoc -d C:/JAVA Tester.java</span><br><span class="line">Loading source file tester.java...</span><br><span class="line">Constructing Javadoc information...</span><br><span class="line">Standard Doclet version 1.7.0_21</span><br><span class="line">Building tree for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\Tester.html...</span><br><span class="line">Generating C:\JAVA\package-frame.html...</span><br><span class="line">Generating C:\JAVA\package-summary.html...</span><br><span class="line">Generating C:\JAVA\package-tree.html...</span><br><span class="line">Generating C:\JAVA\constant-values.html...</span><br><span class="line">Building index for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\overview-tree.html...</span><br><span class="line">Generating C:\JAVA\index-all.html...</span><br><span class="line">Generating C:\JAVA\deprecated-list.html...</span><br><span class="line">Building index for all classes...</span><br><span class="line">Generating C:\JAVA\allclasses-frame.html...</span><br><span class="line">Generating C:\JAVA\allclasses-noframe.html...</span><br><span class="line">Generating C:\JAVA\index.html...</span><br><span class="line">Generating C:\JAVA\help-doc.html...</span><br></pre></td></tr></table></figure>

<p><strong>Java 9 生成的文档兼容 HTML5 标准</strong></p>
<p>使用 jdk 9 javadoc 命令中的 -html5 参数可以让生成的文档支持 HTML5 标准：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C:\JAVA&gt; javadoc -d C:/JAVA -html5 Tester.java</span><br><span class="line">Loading source file Tester.java...</span><br><span class="line">Constructing Javadoc information...</span><br><span class="line">Standard Doclet version 9.0.1</span><br><span class="line">Building tree for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\Tester.html...</span><br><span class="line">Generating C:\JAVA\package-frame.html...</span><br><span class="line">Generating C:\JAVA\package-summary.html...</span><br><span class="line">Generating C:\JAVA\package-tree.html...</span><br><span class="line">Generating C:\JAVA\constant-values.html...</span><br><span class="line">Building index for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\overview-tree.html...</span><br><span class="line">Generating C:\JAVA\index-all.html...</span><br><span class="line">Generating C:\JAVA\deprecated-list.html...</span><br><span class="line">Building index for all classes...</span><br><span class="line">Generating C:\JAVA\allclasses-frame.html...</span><br><span class="line">Generating C:\JAVA\allclasses-frame.html...</span><br><span class="line">Generating C:\JAVA\allclasses-noframe.html...</span><br><span class="line">Generating C:\JAVA\allclasses-noframe.html...</span><br><span class="line">Generating C:\JAVA\index.html...</span><br><span class="line">Generating C:\JAVA\help-doc.html...</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="HTTP-2-Client"><a href="#HTTP-2-Client" class="headerlink" title="HTTP/2 Client"></a>HTTP/2 Client</h1><h2 id="What-is-HTTP-2"><a href="#What-is-HTTP-2" class="headerlink" title="What is HTTP/2?"></a><strong>What is HTTP/2?</strong></h2><blockquote>
<p>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接），是HTTP协议的的第二个主要版本，使用于万维网。<br/><br>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。它由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组进行开发。该组织于2014年12月将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。<br/><br>HTTP/2标准于2015年5月以RFC 7540正式发表。HTTP/2的标准化工作由Chrome、Opera、Firefox、Internet Explorer 11、Safari、Amazon Silk及Edge等浏览器提供支持。<br/><br>多数主流浏览器已经在2015年底支持了该协议。此外，根据W3Techs的数据，在2017年5月，在排名前一千万的网站中，有13.7%支持了HTTP/2。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP/2">Wiki</a></p>
</blockquote>
<p>在 Java 9 中，Oracle 公司将发布新的 HTTP 2 Client API 来支持 HTTP/2 协议和 WebSocket 特性。现有的 HTTP Client API 存在很多问题（如支持 HTTP/1.1 协议但是不支持 HTTP/2 协议和 WebSocket，仅仅作用在 Blocking 模式中，并存在大量性能问题），他们正在被使用新的 HTTP 客户端的 HttpURLConnection API 所替代。</p>
<p>Oracle 公司准备在 “java.net.http” 包下引入新的 HTTP 2 Client API。它将同时支持 HTTP/1.1 和 HTTP/2 协议，也同时支持同步（Blocking Mode）和异步模式，支持 WebSocket API 使用中的异步模式。</p>
<h2 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a><strong>Usage</strong></h2><p>注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest req =</span><br><span class="line">   HttpRequest.newBuilder(URI.create(&quot;http://www.google.com&quot;))</span><br><span class="line">            .header(&quot;User-Agent&quot;,&quot;Java&quot;)</span><br><span class="line">            .GET()</span><br><span class="line">            .build();</span><br><span class="line">HttpResponse&lt;String&gt; resp = client.send(req, HttpResponse.BodyHandler.asString());</span><br></pre></td></tr></table></figure>

<p>HttpResponse<String> resp = client.send(req, HttpResponse.BodyHandler.asString());<br>除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。</p>
<h1 id="统一-JVM-日志"><a href="#统一-JVM-日志" class="headerlink" title="统一 JVM 日志"></a>统一 JVM 日志</h1><p>Java 9 中 ，JVM 有了统一的日志记录系统，可以使用新的命令行选项-Xlog 来控制 JVM 上 所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合，同时 把 G1 设为默认的垃圾回收器实现。另外，CMS 垃圾回收器已经被声明为废弃。Java 9 也增加了很多可以通过 jcmd 调用的诊断命令。</p>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>tutorialspoint : <a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/java9/index.htm">https://www.tutorialspoint.com/java9/index.htm</a></li>
<li>ibm-developerworks : <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html</a></li>
<li>journaldev : <a target="_blank" rel="noopener" href="https://www.journaldev.com/13121/java-9-features-with-examples">https://www.journaldev.com/13121/java-9-features-with-examples</a></li>
<li>Java 9 docs : <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/">https://docs.oracle.com/javase/9/</a></li>
<li>Java 9 docs api : <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/overview-summary.html">https://docs.oracle.com/javase/9/docs/api/overview-summary.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2018/12/20/JavaVersionCharacter9/" data-id="ckvgcipjg000lplqh4x044okf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java9/" rel="tag">java9</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaVersionCharacter8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/17/JavaVersionCharacter8/" class="article-date">
  <time datetime="2018-12-17T02:20:40.000Z" itemprop="datePublished">2018-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/17/JavaVersionCharacter8/">Java8 版本特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h2 id="What-is-functional-interface"><a href="#What-is-functional-interface" class="headerlink" title="What is functional interface?"></a><strong>What is functional interface?</strong></h2><blockquote>
<p>函数式接口（functional interface）就是只定义一个抽象方法的接口，比如 Java API 中的 Predicate、Comparator 和 Runnable 等。Lambda 表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。</p>
</blockquote>
<p>Java 8 引入的一个核心概念是函数式接口（Functional Interfaces）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义个唯一一个抽象方法，那么这个接口就成为函数式接口。同时，引入了一个新的注解：@FunctionalInterface。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。</p>
<p>java.lang.Runnable 就是一个函数式接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">   public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="What-is-lambda-expression"><a href="#What-is-lambda-expression" class="headerlink" title="What is lambda expression?"></a><strong>What is lambda expression?</strong></h2><blockquote>
<p>“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">百度百科</a></p>
<blockquote>
<p>匿名函数,在计算机编程中，匿名函数（英语：anonymous function）是指一类无需定义标识符（函数名）的函数或子程序，普遍存在于多种编程语言中。1958年LISP首先采用匿名函数，自此之后，越来越多编程语言陆续采用，主流的编程语言如PHP和C++也在不久前采用。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">Wiki</a></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>λ演算（英语：lambda calculus，λ-calculus）是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它由数学家阿隆佐·邱奇在20世纪30年代首次发表。lambda演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值，它能模拟单一磁带图灵机的计算过程；尽管如此，lambda演算强调的是变换规则的运用，而非实现它们的具体机器。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">Wiki</a></p>
</blockquote>
</blockquote>
<p>Lambda 表达式可以理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。它的核心思想是将面向对象中的传递数据变成传递行为。</p>
<p>重要特征</p>
<ul>
<li><strong>可选类型声明</strong> - 无需声明参数类型。编译器可以从参数的值推断出相同的值</li>
<li><strong>参数的可选括号</strong> - 无需在括号中声明单个参数。对于多个参数，需要括号</li>
<li><strong>可选的花括号</strong> - 如果主体包含单个语句，则无需在表达式主体中使用花括号</li>
<li><strong>可选的return关键字</strong> - 如果正文具有单个表达式以返回值，则编译器会自动返回该值。需要使用大括号来表示表达式返回一个值</li>
</ul>
<p>重要特点</p>
<ul>
<li><strong>匿名</strong> - 它不像普通方法那样有一个明确的名称</li>
<li><strong>函数</strong> - Lambda 表达式是函数是因为它不像方法那样属于某个特定的类，但和方法一样，Lambda 有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表</li>
<li><strong>传递</strong> - Lambda 表达式可以作为参数传递给方法或存储在变量中</li>
<li><strong>简洁</strong> - 无需像匿名类那样写很多模板代码</li>
</ul>
<p>Lambda表达式在Java 8中引入.Lambda表达式有助于函数式编程，并简化了很多开发。</p>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a><strong>Syntax</strong></h2><p>Lambda 表达式由参数列表、箭头和 Lambda 主体组成。</p>
<p><code>parameter -&gt; expression body</code></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a><strong>Example</strong></h2><blockquote>
<p>函数式编程（functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">Wiki</a></p>
<blockquote>
<p>lambda演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式。因此普遍公认是一种更接近软件而非硬件的方式。对函数式编程语言造成很大影响，比如Lisp、ML语言和Haskell语言。在1936年邱奇利用λ演算给出了对于判定性问题（Entscheidungsproblem）的否定：关于两个lambda表达式是否等价的命题，无法由一个“通用的算法”判断，这是不可判定性能够证明的头一个问题，甚至还在停机问题之先。</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      Java8Tester tester = new Java8Tester();</span><br><span class="line">		</span><br><span class="line">      //with type declaration</span><br><span class="line">      MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line">		</span><br><span class="line">      //with out type declaration</span><br><span class="line">      MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">		</span><br><span class="line">      //with return statement along with curly braces</span><br><span class="line">      MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;;</span><br><span class="line">		</span><br><span class="line">      //without return statement and without curly braces</span><br><span class="line">      MathOperation division = (int a, int b) -&gt; a / b;</span><br><span class="line">		</span><br><span class="line">      System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));</span><br><span class="line">      System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));</span><br><span class="line">      System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));</span><br><span class="line">      System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));</span><br><span class="line">		</span><br><span class="line">      //without parenthesis</span><br><span class="line">      GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">		</span><br><span class="line">      //with parenthesis</span><br><span class="line">      GreetingService greetService2 = (message) -&gt; System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">		</span><br><span class="line">      greetService1.sayMessage(&quot;Mahesh&quot;);</span><br><span class="line">      greetService2.sayMessage(&quot;Suresh&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   @FunctionalInterface</span><br><span class="line">   interface MathOperation &#123;</span><br><span class="line">      int operation(int a, int b);</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   @FunctionalInterface</span><br><span class="line">   interface GreetingService &#123;</span><br><span class="line">      void sayMessage(String message);</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">      return mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是对使用上述例子认为是重要的观点:</p>
<ul>
<li>Lambda表达式主要用于定义功能接口的内联实现，即仅具有单个方法的接口。在上面的例子中，我们使用了各种类型的lambda表达式来定义MathOperation接口的操作方法。然后我们定义了GreetingService的sayMessage的实现。</li>
<li>Lambda表达式消除了对匿名类的需求，并为Java提供了非常简单但功能强大的函数编程功能。</li>
</ul>
<table>
<thead>
<tr>
<th>使用案例</th>
<th align="left">Lambda案例</th>
</tr>
</thead>
<tbody><tr>
<td>布尔表达式</td>
<td align="left"><code>(List&lt;String&gt; list) -&gt; list.isEmpty()</code></td>
</tr>
<tr>
<td>创建对象</td>
<td align="left"><code>() -&gt; new Object()</code></td>
</tr>
<tr>
<td>打印信息</td>
<td align="left"><code>(String str) -&gt; System.out.println(str)</code></td>
</tr>
<tr>
<td>遍历集合</td>
<td align="left"><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(e -&gt; System.out.println( e ))</code></td>
</tr>
<tr>
<td>排序比较</td>
<td align="left"><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort(( e1, e2 ) -&gt; e1.compareTo( e2 ))</code></td>
</tr>
</tbody></table>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h2><p>使用lambda表达式，您可以引用任何最终变量或有效的最终变量（仅分配一次）。如果第二次为变量赋值，则Lambda表达式会抛出编译错误。</p>
<hr>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h2 id="What-is-method-references"><a href="#What-is-method-references" class="headerlink" title="What is method references"></a><strong>What is method references</strong></h2><p>方法引用有助于通过名称指向方法，可以使语言的构造更紧凑简洁，减少冗余代码。使用“::”符号描述方法引用。方法引用可用于指出以下类型的方法</p>
<ul>
<li>静态方法</li>
<li>实例方法</li>
<li>使用new运算符的构造函数（TreeSet :: new）</li>
</ul>
<h2 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a><strong>Syntax</strong></h2><ul>
<li>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br><span class="line">class Car &#123;</span><br><span class="line">    public static Car create(final Supplier&lt;Car&gt; supplier) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void collide(final Car car) &#123;</span><br><span class="line">        System.out.println(&quot;Collided &quot; + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void follow(final Car another) &#123;</span><br><span class="line">        System.out.println(&quot;Following the &quot; + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void repair() &#123;</span><br><span class="line">        System.out.println(&quot;Repaired &quot; + this.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Main &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      final Car car = Car.create( Car::new );</span><br><span class="line">      final List&lt; Car &gt; cars = Arrays.asList( car );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>静态方法引用：它的语法是Class::static_method，实例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure></li>
<li>特定类的任意对象的方法引用：它的语法是Class::method实例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure></li>
<li>特定对象的方法引用：它的语法是instance::method实例如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car police = Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="默认方法和静态方法"><a href="#默认方法和静态方法" class="headerlink" title="默认方法和静态方法"></a>默认方法和静态方法</h1><h2 id="What-is-default-method-and-static-method"><a href="#What-is-default-method-and-static-method" class="headerlink" title="What is default method and static method?"></a><strong>What is default method and static method?</strong></h2><p>Java 8 对接口做了进一步的增强。在接口中可以添加使用 default 关键字修饰的非抽象方法。还可以在接口中定义静态方法。如今，接口看上去与抽象类的功能越来越类似了。</p>
<p>Java 8在接口中引入了默认方法实现的新概念。添加此功能是为了向后兼容，以便可以使用旧接口来利用Java 8的lambda表达式功能。给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做扩展方法。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。但扩展方法不能够重载 Object 中的方法。例如：toString、equals、 hashCode 不能在接口中被重载。</p>
<p>在接口中，还允许定义静态的方法。接口中的静态方法可以直接用接口来调用。</p>
<h2 id="Syntax-2"><a href="#Syntax-2" class="headerlink" title="Syntax"></a><strong>Syntax</strong></h2><p>Default：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface vehicle &#123;</span><br><span class="line"></span><br><span class="line">   default void print() &#123;</span><br><span class="line">      System.out.println(&quot;I am a vehicle!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mutiple Defaults：</p>
<p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface vehicle &#123;</span><br><span class="line"></span><br><span class="line">   default void print() &#123;</span><br><span class="line">      System.out.println(&quot;I am a vehicle!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface fourWheeler &#123;</span><br><span class="line"></span><br><span class="line">   default void print() &#123;</span><br><span class="line">      System.out.println(&quot;I am a four wheeler!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种解决方案，创建自己的默认方法来重写接口的默认方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class interface Car implements Vehicle, fourWheeler&#123;</span><br><span class="line"></span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;I am a four wheeler car vehicle!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种解决方案，使用super调用指定接口的默认方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line"></span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Static Default Methods：</p>
<p>在接口中，还允许定义静态的方法，可以声明（并且可以提供实现）的静态方法。接口中的静态方法可以直接用接口来调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface vehicle &#123;</span><br><span class="line">	</span><br><span class="line">   static void blowHorn() &#123;</span><br><span class="line">      System.out.println(&quot;Blowing horn!!!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestStaticFun &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      vehicle.blowHorn();</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h1><h2 id="What-is-Stream"><a href="#What-is-Stream" class="headerlink" title="What is Stream?"></a><strong>What is Stream?</strong></h2><p>Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。</p>
<p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。以下是流的特征</p>
<ul>
<li>元素序列 - 流以顺序方式提供特定类型的一组元素。流按需获取/计算元素。它从不存储元素。</li>
<li>Source - Stream将集合，数组，I/O channel，产生器generator等作为输入源。</li>
<li>聚合操作 - Stream支持聚合操作，如过滤，映射，限制，缩减，查找，匹配等。</li>
<li>中间操作 - 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代 - 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h2 id="Syntax-3"><a href="#Syntax-3" class="headerlink" title="Syntax"></a><strong>Syntax</strong></h2><h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>流有串行和并行两种, 集合接口有两个方法来生成流：</p>
<ul>
<li>stream() − 为集合创建串行流。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>stream.sequential() − 返回串行的流。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">strings.stream().sequential().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>parallelStream() − 为集合创建并行流。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">long count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></li>
<li>stream.parallel() − 返回并行的流。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">long count = strings.stream().parallel().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>串行流上的操作是在一个线程中依次完成，而并行流则是在多个线程上同时执行。并行与串行的流可以相互切换。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>该操作会保持 stream 处于中间状态，允许做进一步的操作。它返回的还是的 Stream，允许更多的链式操作。常见的中间操作有：</p>
<ul>
<li>filter() - 对元素进行过滤,用于通过设置的条件过滤出元素<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></li>
<li>sorted() - 对元素排序,用于对流进行排序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>map() - 元素的映射,用于映射每个元素到对应的结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">// 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
<li>distinct() - 去除重复元素,去除流中重复的元素<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">stream.distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>subStream() - 获取子 Stream 等</li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/java-8-stream/">more</a></li>
</ul>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>该操作必须是流的最后一个操作，一旦被调用，Stream 就到了一个终止状态，而且不能再使用了。常见的终止操作有：</p>
<ul>
<li>forEach() - 对每个元素做处理,迭代流中的每个数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>toArray() - 把元素导出到数组</li>
<li>findFirst() - 返回第一个匹配的元素</li>
<li>anyMatch() - 是否有匹配的元素等</li>
<li>collect() - Collectors 类实现了很多归约操作,例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/java-8-stream/">more</a></li>
</ul>
<hr>
<h1 id="Optional-Class"><a href="#Optional-Class" class="headerlink" title="Optional Class"></a>Optional Class</h1><h2 id="What-is-Optional-Class"><a href="#What-is-Optional-Class" class="headerlink" title="What is Optional Class?"></a><strong>What is Optional Class?</strong></h2><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional 类的引入很好的解决空指针异常。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">官方文档</a></p>
<h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>java.util.Optional<T> 类的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table>
<thead>
<tr>
<th>Modifier and Type</th>
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td>static&lt;T&gt;Optional&lt;T&gt;</td>
<td align="left">empty()</td>
<td align="left">返回空的 Optional 实例</td>
</tr>
<tr>
<td>boolean</td>
<td align="left">equals(Object obj)</td>
<td align="left">判断其他对象是否等于 Optional</td>
</tr>
<tr>
<td>Optional&lt;T&gt;</td>
<td align="left">filter(Predicate&lt;? super &lt;T&gt; predicate)</td>
<td align="left">如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional</td>
</tr>
<tr>
<td>&lt;U&gt; Optional&lt;U&gt;</td>
<td align="left">flatMap(Function&lt;?superT,Optional&lt;U&gt;&gt;mapper)</td>
<td align="left">如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</td>
</tr>
<tr>
<td>T</td>
<td align="left">get()</td>
<td align="left">如果在这个Optional中包含这个值，返回值，否则抛出异常NoSuchElementException</td>
</tr>
<tr>
<td>int</td>
<td align="left">hashCode()</td>
<td align="left">返回存在值的哈希码，如果值不存在 返回 0</td>
</tr>
<tr>
<td>void</td>
<td align="left">ifPresent(Consumer&lt;? super T&gt; consumer)</td>
<td align="left">如果值存在则使用该值调用 consumer , 否则不做任何事情</td>
</tr>
<tr>
<td>boolean</td>
<td align="left">isPresent()</td>
<td align="left">如果值存在则方法会返回true，否则返回 false</td>
</tr>
<tr>
<td>&lt;U&gt;Optional&lt;U&gt;</td>
<td align="left">map(Function&lt;? super T,? extends U&gt; mapper)</td>
<td align="left">如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional</td>
</tr>
<tr>
<td>static <T> Optional<T></td>
<td align="left">of(T value)</td>
<td align="left">返回一个指定非null值的Optional</td>
</tr>
<tr>
<td>static <T> Optional<T></td>
<td align="left">ofNullable(T value)</td>
<td align="left">如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional</td>
</tr>
<tr>
<td>T</td>
<td align="left">orElse(T other)</td>
<td align="left">如果存在该值，返回值， 否则返回 other</td>
</tr>
<tr>
<td>T</td>
<td align="left">orElseGet(Supplier&lt;? extends T&gt; other)</td>
<td align="left">如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果</td>
</tr>
<tr>
<td><X extends Throwable> T</td>
<td align="left">orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</td>
<td align="left">如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</td>
</tr>
<tr>
<td>String</td>
<td align="left">toString()</td>
<td align="left">返回一个Optional的非空字符串，用来调试</td>
</tr>
</tbody></table>
<p>注意： 这些方法是从 java.lang.Object 类继承来的。</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a><strong>Example</strong></h2><p>解决空指针异常,可能为空的值或者某个类型的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private String getUserName(User user) &#123;</span><br><span class="line">    Optional&lt;User&gt; userOptional = Optional.ofNullable(user);</span><br><span class="line">    return userOptional.map(User::getUserName).orElse(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usage Demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      Java8Tester java8Tester = new Java8Tester();</span><br><span class="line">      Integer value1 = null;</span><br><span class="line">      Integer value2 = new Integer(10);</span><br><span class="line">        </span><br><span class="line">      // Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        </span><br><span class="line">      // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">      System.out.println(java8Tester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123;</span><br><span class="line">    </span><br><span class="line">      // Optional.isPresent - 判断值是否存在</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());</span><br><span class="line">      System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());</span><br><span class="line">        </span><br><span class="line">      // Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">      Integer value1 = a.orElse(new Integer(0));</span><br><span class="line">        </span><br><span class="line">      //Optional.get - 获取值，值需要存在</span><br><span class="line">      Integer value2 = b.get();</span><br><span class="line">      return value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="安全性增强"><a href="#安全性增强" class="headerlink" title="安全性增强"></a>安全性增强</h2><p>现今，互联网环境中存在各种各种潜在的威胁，对于 Java 平台来说，安全显得特别重要。为了保证新版本具有更高的安全性，Java 8 在安全性上对许多方面进行了增强，也为此推迟了它的发布日期。下面例举其中几个关于安全性的更新：</p>
<p>支持更强的基于密码的加密算法。基于 AES 的加密算法，例如 PBEWithSHA256AndAES_128 和 PBEWithSHA512AndAES_256，已经被加入进来。</p>
<p>在客户端，TLS1.1 和 TLS1.2 被设为默认启动。并且可以通过新的系统属性包 jdk.tls.client.protocols 来对它进行配置。</p>
<p>Keystore 的增强，包含新的 Keystore 类型 java.security.DomainLoadStoreParameter 和为 Keytool 这个安全钥匙和证书的管理工具添加新的命令行选项-importpassword。同时，添加和更新了一些关于安全性的 API 来支持 KeyStore 的更新。</p>
<p>支持安全的随机数发生器。如果随机数来源于随机性不高的种子，那么那些用随机数来产生密钥或者散列敏感信息的系统就更易受攻击。SecureRandom 这个类的 getInstanceStrong 方法如今可以获取各个平台最强的随机数对象实例，通过这个实例生成像 RSA 私钥和公钥这样具有较高熵的随机数。</p>
<p>JSSE（Java(TM) Secure Socket Extension）服务器端开始支持 SSL/TLS 服务器名字识别 SNI（Server Name Indication）扩展。SNI 扩展目的是 SSL/TLS 协议可以通过 SNI 扩展来识别客户端试图通过握手协议连接的服务器名字。在 Java 7 中只在客户端默认启动 SNI 扩展。如今，在 JSSE 服务器端也开始支持 SNI 扩展了。</p>
<p>安全性比较差的加密方法被默认禁用。默认不支持 DES 相关的 Kerberos 5 加密方法。如果一定要使用这类弱加密方法需要在 krb5.conf 文件中添加 allow_weak_crypto=true。考虑到这类加密方法安全性极差，开发者应该尽量避免使用它。</p>
<h2 id="Java8-Base64"><a href="#Java8-Base64" class="headerlink" title="Java8 Base64"></a>Java8 Base64</h2><p>在Java 8中，Base64编码已经成为Java类库的标准。<br>Java 8 内置了 Base64 编码的编码器和解码器。<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li>基本 - 输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li>URL - 输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li>MIME - 输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h3 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h3><table>
<thead>
<tr>
<th>内嵌类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>static class Base64.Decoder</td>
<td align="left">该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td>
</tr>
<tr>
<td>static class Base64.Encoder</td>
<td align="left">该类实现一个编码器，使用 Base64 编码来编码字节数据。</td>
</tr>
</tbody></table>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>static Base64.Decoder getDecoder()</td>
<td align="left">返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>static Base64.Encoder getEncoder()</td>
<td align="left">返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>static Base64.Decoder getMimeDecoder()</td>
<td align="left">返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>static Base64.Encoder getMimeEncoder()</td>
<td align="left">返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</td>
<td align="left">返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td>
</tr>
<tr>
<td>static Base64.Decoder getUrlDecoder()</td>
<td align="left">返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
<tr>
<td>static Base64.Encoder getUrlEncoder()</td>
<td align="left">返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
</tbody></table>
<p>注意：Base64 类的很多方法从 java.lang.Object 类继承。</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a><strong>Example</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        </span><br><span class="line">         // 使用基本编码</span><br><span class="line">         String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">         System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         // 解码</span><br><span class="line">         byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">        </span><br><span class="line">         System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line">         base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">         System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">         for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">            stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">         String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">         System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br><span class="line">         </span><br><span class="line">      &#125;catch(UnsupportedEncodingException e)&#123;</span><br><span class="line">         System.out.println(&quot;Error :&quot; + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="日期时间-API"><a href="#日期时间-API" class="headerlink" title="日期时间 API"></a>日期时间 API</h1><h2 id="Date-time-API的改进"><a href="#Date-time-API的改进" class="headerlink" title="Date/time API的改进"></a>Date/time API的改进</h2><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理，支持新的 Unicode 6.2.0 标准。</p>
<p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p>
<ul>
<li>非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li>设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li>
<li>时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li>
</ul>
<p>Java 8 在 java.time 包下提供了很多新的 API。常用的几个类有：</p>
<ul>
<li>Clock - 使用时区来返回当前的纳秒时间和日期</li>
<li>Instant - 一个instant对象表示时间轴上的一个时间点，Instant.now()方法会返回当前的瞬时点（格林威治时间）</li>
<li>Duration - 用于表示两个瞬时点相差的时间量</li>
<li>LocalDate − 个带有年份，月份和天数的日期，可以使用静态方法now或者of方法进行创建</li>
<li>LocalTime − 表示一天中的某个时间，同样可以使用now和of进行创建</li>
<li>LocalDateTime - 兼有日期和时间</li>
<li>ZonedDateTime - 通过设置时间的id来创建一个带时区的时间</li>
<li>DateTimeFormatter - 日期格式化类，提供了多种预定义的标准格式</li>
</ul>
<p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>
<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a><strong>Example</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class TimeTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      Clock clock = Clock.systemUTC();</span><br><span class="line">      Instant instant = clock.instant();</span><br><span class="line">      System.out.println(instant.toString());</span><br><span class="line"></span><br><span class="line">      // Get duration between two dates</span><br><span class="line">      final LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</span><br><span class="line">      final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );</span><br><span class="line">      final Duration duration = Duration.between( from, to );</span><br><span class="line">      System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</span><br><span class="line">      System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</span><br><span class="line"></span><br><span class="line">      LocalDate localDate = LocalDate.now();</span><br><span class="line">      System.out.println(localDate.toString());</span><br><span class="line"></span><br><span class="line">      LocalTime localTime = LocalTime.now();</span><br><span class="line">      System.out.println(localTime.toString());</span><br><span class="line"></span><br><span class="line">      LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">      System.out.println(localDateTime.toString());</span><br><span class="line"></span><br><span class="line">      ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));</span><br><span class="line">      System.out.println(zonedDateTime.toString());</span><br><span class="line"></span><br><span class="line">      System.out.println(DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).format(LocalDateTime.now()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的更新"><a href="#注解的更新" class="headerlink" title="注解的更新"></a>注解的更新</h2><p>对于注解，Java 8 主要有两点改进：类型注解和重复注解。</p>
<p>Java 8 的类型注解扩展了注解使用的范围。在该版本之前，注解只能是在声明的地方使用。现在几乎可以为任何东西添加注解：局部变量、类与接口，就连方法的异常也能添加注解。新增的两个注释的程序元素类型 ElementType.TYPE_USE 和 ElementType.TYPE_PARAMETER 用来描述注解的新场合。ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中。而 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中（例如声明语句、泛型和强制转换语句中的类型）。</p>
<p>对类型注解的支持，增强了通过静态分析工具发现错误的能力。原先只能在运行时发现的问题可以提前在编译的时候被排查出来。Java 8 本身虽然没有自带类型检测的框架，但可以通过使用 Checker Framework 这样的第三方工具，自动检查和确认软件的缺陷，提高生产效率。</p>
<p>例如，下面的代码可以通过编译，但是运行时会报 NullPointerException 的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestAnno &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Object obj = null;</span><br><span class="line">      obj.toString();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能在编译期间就自动检查出这类异常，可以通过类型注解结合 Checker Framework 提前排查出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import org.checkerframework.checker.nullness.qual.NonNull;</span><br><span class="line">public class TestAnno &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      @NonNull Object obj = null;</span><br><span class="line">      obj.toString();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时自动检测结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\workspace\TestJava8\src\TestAnno.java:4: Warning:</span><br><span class="line">  (assignment.type.incompatible) $$ 2 $$ null $$ @UnknownInitialization @NonNull Object $$ ( 152, 156 )</span><br><span class="line">  $$ incompatible types in assignment.</span><br><span class="line">@NonNull Object obj = null;</span><br><span class="line"> ^</span><br><span class="line"> found : null</span><br><span class="line"> required: @UnknownInitialization @NonNull Object</span><br></pre></td></tr></table></figure>

<p>另外，在该版本之前使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8 引入了重复注解机制，这样相同的注解可以在同一地方声明多次。重复注解机制本身必须用 @Repeatable 注解。</p>
<p>例如，下面就是用 @Repeatable 重复注解的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</span><br><span class="line">@interface Annots &#123;</span><br><span class="line">   Annot[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) \\该注解存在于类文件中并在运行时可以通过反射获取</span><br><span class="line">@Repeatable(Annots.class)</span><br><span class="line">@interface Annot &#123;</span><br><span class="line">   String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Annot(&quot;a1&quot;)</span><br><span class="line">@Annot(&quot;a2&quot;)</span><br><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Annots annots1 = Test.class.getAnnotation(Annots.class);</span><br><span class="line">      System.out.println(annots1.value()[0]+&quot;,&quot;+annots1.value()[1]); </span><br><span class="line">      // 输出: @Annot(value=a1),@Annot(value=a2)</span><br><span class="line">      Annot[] annots2 = Test.class.getAnnotationsByType(Annot.class);</span><br><span class="line">      System.out.println(annots2[0]+&quot;,&quot;+annots2[1]); </span><br><span class="line">      // 输出: @Annot(value=a1),@Annot(value=a2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释 Annot 被 @Repeatable( Annots.class ) 注解。Annots 只是一个容器，它包含 Annot 数组, 编译器尽力向程序员隐藏它的存在。通过这样的方式，Test 类可以被 Annot 注解两次。重复注释的类型可以通过 getAnnotationsByType() 方法来返回。</p>
<hr>
<h1 id="IO-NIO"><a href="#IO-NIO" class="headerlink" title="IO/NIO"></a>IO/NIO</h1><h2 id="IO-NIO-的改进"><a href="#IO-NIO-的改进" class="headerlink" title="IO/NIO 的改进"></a>IO/NIO 的改进</h2><p>Java 8 对 IO/NIO 也做了一些改进。主要包括：改进了 java.nio.charset.Charset 的实现，使编码和解码的效率得以提升，也精简了 jre/lib/charsets.jar 包；优化了 String(byte[],*) 构造方法和 String.getBytes() 方法的性能；还增加了一些新的 IO/NIO 方法，使用这些方法可以从文件或者输入流中获取流（java.util.stream.Stream），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。</p>
<p>新增的 API 如下：</p>
<ul>
<li>BufferedReader.line() - 返回文本行的流 Stream<String></li>
<li>File.lines(Path, Charset) - 返回文本行的流 Stream<String></li>
<li>File.list(Path) - 遍历当前目录下的文件和目录</li>
<li>File.walk(Path, int, FileVisitOption) - 遍历某一个目录下的所有文件和指定深度的子目录</li>
<li>File.find(Path, int, BiPredicate, FileVisitOption… ) - 查找相应的文件</li>
</ul>
<h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a><strong>Example</strong></h2><p>下面就是用流式操作列出当前目录下的所有文件和目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.list(new File(&quot;.&quot;).toPath()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Nashorn-JavaScript"><a href="#Nashorn-JavaScript" class="headerlink" title="Nashorn JavaScript"></a>Nashorn JavaScript</h1><h2 id="What-is-Nashorn-JavaScript"><a href="#What-is-Nashorn-JavaScript" class="headerlink" title="What is Nashorn JavaScript?"></a><strong>What is Nashorn JavaScript?</strong></h2><p><a target="_blank" rel="noopener" href="https://www.javacodegeeks.com/2014/02/java-8-compiling-lambda-expressions-in-the-new-nashorn-js-engine.html">Nashorn JavaScript引擎</a> </p>
<p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p>
<p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a><strong>Usage</strong></h2><h3 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h3><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</p>
<p>例如，我们创建一个具有如下内容的sample.js文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;Hello World!&#x27;);</span><br></pre></td></tr></table></figure>

<p>打开控制台，输入以下命令并输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs sample.js</span><br><span class="line">$ Hello World!</span><br></pre></td></tr></table></figure>

<h3 id="Java-中调用-JavaScript"><a href="#Java-中调用-JavaScript" class="headerlink" title="Java 中调用 JavaScript"></a>Java 中调用 JavaScript</h3><p>使用 ScriptEngineManager, JavaScript 代码可以在 Java 中执行，实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptException;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      ScriptEngineManager scriptEngineManager = new ScriptEngineManager();</span><br><span class="line">      ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">        </span><br><span class="line">      String name = &quot;Runoob&quot;;</span><br><span class="line">      Integer result = null;</span><br><span class="line">      </span><br><span class="line">      try &#123;</span><br><span class="line">         nashorn.eval(&quot;print(&#x27;&quot; + name + &quot;&#x27;)&quot;);</span><br><span class="line">         result = (Integer) nashorn.eval(&quot;10 + 2&quot;);</span><br><span class="line">         </span><br><span class="line">      &#125;catch(ScriptException e)&#123;</span><br><span class="line">         System.out.println(&quot;执行脚本错误: &quot;+ e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      System.out.println(result.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">Runoob</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-中调用-Java"><a href="#JavaScript-中调用-Java" class="headerlink" title="JavaScript 中调用 Java"></a>JavaScript 中调用 Java</h3><p>以下实例演示了如何在 JavaScript 中引用 Java 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var BigDecimal = Java.type(&#x27;java.math.BigDecimal&#x27;);</span><br><span class="line"></span><br><span class="line">function calculate(amount, percentage) &#123;</span><br><span class="line"></span><br><span class="line">   var result = new BigDecimal(amount).multiply(</span><br><span class="line">   new BigDecimal(percentage)).divide(new BigDecimal(&quot;100&quot;), 2, BigDecimal.ROUND_HALF_EVEN);</span><br><span class="line">   </span><br><span class="line">   return result.toPlainString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = calculate(568000000000000000023,13.9);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure>

<p>我们使用 jjs 命令执行以上脚本，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs sample.js</span><br><span class="line">78952000000000002017.94</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="原文资料"><a href="#原文资料" class="headerlink" title="原文资料"></a>原文资料</h1><ul>
<li>tutorialspoint : <a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/java8/index.htm">https://www.tutorialspoint.com/java8/index.htm</a></li>
<li>geeksforgeeks : <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/java-8-stream">https://www.geeksforgeeks.org/java-8-stream</a></li>
<li>ibm-developerworks : <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html</a></li>
<li>Javacodegeeks : <a target="_blank" rel="noopener" href="https://www.javacodegeeks.com/2014/05/java-8-features-tutorial.html">https://www.javacodegeeks.com/2014/05/java-8-features-tutorial.html</a></li>
<li>Java 8 docs : <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/">https://docs.oracle.com/javase/8/</a></li>
<li>Java 8 docs api : <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/overview-summary.html">https://docs.oracle.com/javase/8/docs/api/overview-summary.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leigaorobot.github.io/2018/12/17/JavaVersionCharacter8/" data-id="ckvgcipje000iplqhcpb0gp7k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java8/" rel="tag">java8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lambda/" rel="tag">lambda</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Command-Line/">Command Line</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Network/">Computer Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Container-Orchestration/">Container Orchestration</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DatabaseTransaction/">DatabaseTransaction</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hacker-Laws/">Hacker Laws</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Internet-Protocol-Suite/">Internet Protocol Suite</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Script/">Java Script</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kubernetes/">Kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Message-Queue/">Message Queue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OSI-Model/">OSI Model</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-Paradigms/">Programming Paradigms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Software-Design-Patterns/">Software Design Patterns</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Transaction/">Transaction</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache-Kafka/" rel="tag">Apache Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Authentication/" rel="tag">Authentication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Authorization/" rel="tag">Authorization</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/" rel="tag">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DatabaseTransaction/" rel="tag">DatabaseTransaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OAuth/" rel="tag">OAuth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OAuth-2-0/" rel="tag">OAuth 2.0</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Token/" rel="tag">Token</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transaction/" rel="tag">Transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cloud-platform/" rel="tag">cloud platform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/command/" rel="tag">command</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/command-line/" rel="tag">command-line</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compuer-network/" rel="tag">compuer network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/container/" rel="tag">container</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/creational/" rel="tag">creational</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/" rel="tag">data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design-patterns/" rel="tag">design patterns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hacker-laws/" rel="tag">hacker laws</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/internet/" rel="tag">internet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-annotation/" rel="tag">java annotation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-script/" rel="tag">java script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java10/" rel="tag">java10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java8/" rel="tag">java8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java9/" rel="tag">java9</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/" rel="tag">lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/laws/" rel="tag">laws</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/message-queue/" rel="tag">message queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/" rel="tag">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oop/" rel="tag">oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/osi/" rel="tag">osi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/protocol/" rel="tag">protocol</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/protocol-suite/" rel="tag">protocol suite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-security/" rel="tag">spring security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/structural/" rel="tag">structural</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Apache-Kafka/" style="font-size: 10px;">Apache Kafka</a> <a href="/tags/Authentication/" style="font-size: 10px;">Authentication</a> <a href="/tags/Authorization/" style="font-size: 10px;">Authorization</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/DatabaseTransaction/" style="font-size: 10px;">DatabaseTransaction</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/OAuth/" style="font-size: 10px;">OAuth</a> <a href="/tags/OAuth-2-0/" style="font-size: 10px;">OAuth 2.0</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/RocketMQ/" style="font-size: 10px;">RocketMQ</a> <a href="/tags/Token/" style="font-size: 10px;">Token</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/cloud-platform/" style="font-size: 10px;">cloud platform</a> <a href="/tags/command/" style="font-size: 10px;">command</a> <a href="/tags/command-line/" style="font-size: 10px;">command-line</a> <a href="/tags/compuer-network/" style="font-size: 10px;">compuer network</a> <a href="/tags/container/" style="font-size: 10px;">container</a> <a href="/tags/creational/" style="font-size: 10px;">creational</a> <a href="/tags/data-structure/" style="font-size: 10px;">data structure</a> <a href="/tags/design-patterns/" style="font-size: 16.67px;">design patterns</a> <a href="/tags/hacker-laws/" style="font-size: 10px;">hacker laws</a> <a href="/tags/internet/" style="font-size: 10px;">internet</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java-annotation/" style="font-size: 10px;">java annotation</a> <a href="/tags/java-script/" style="font-size: 10px;">java script</a> <a href="/tags/java10/" style="font-size: 10px;">java10</a> <a href="/tags/java8/" style="font-size: 10px;">java8</a> <a href="/tags/java9/" style="font-size: 10px;">java9</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/laws/" style="font-size: 10px;">laws</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/message-queue/" style="font-size: 10px;">message queue</a> <a href="/tags/microservice/" style="font-size: 10px;">microservice</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/osi/" style="font-size: 10px;">osi</a> <a href="/tags/protocol/" style="font-size: 16.67px;">protocol</a> <a href="/tags/protocol-suite/" style="font-size: 10px;">protocol suite</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/spring-security/" style="font-size: 10px;">spring security</a> <a href="/tags/structural/" style="font-size: 10px;">structural</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.33px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/20/ECMAScript6/">ECMAScript6</a>
          </li>
        
          <li>
            <a href="/2019/05/30/LinuxCommandLine/">Linux Command-Line</a>
          </li>
        
          <li>
            <a href="/2019/05/24/OSIApplicationLayer/">Application Layer</a>
          </li>
        
          <li>
            <a href="/2019/05/21/TransactionProcessing/">Transaction</a>
          </li>
        
          <li>
            <a href="/2019/05/20/HackerLaws/">HackerLaws</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Paul Gao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>